<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient multivariate low-degree tests via interactive oracle proofs of proximity for polynomial codes</title>
				<funder>
					<orgName type="full">Capgemini</orgName>
				</funder>
				<funder ref="#_pju3VSH">
					<orgName type="full">l'X -École polytechnique</orgName>
				</funder>
				<funder>
					<orgName type="full">Fondation de l'École polytechnique</orgName>
				</funder>
				<funder>
					<orgName type="full">Caisse des dépôts</orgName>
				</funder>
				<funder>
					<orgName type="full">Nomadi-cLabs</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
				<date type="published" when="2021-08-11">August 11, 2021</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Augot</surname></persName>
							<email>daniel.augot@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">Inria</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">École polytechnique</orgName>
								<orgName type="laboratory" key="lab1">LIX</orgName>
								<orgName type="laboratory" key="lab2">CNRS UMR 7161</orgName>
								<orgName type="institution">Institut polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sarah</forename><surname>Bordage</surname></persName>
							<email>sarah.bordage@lix.polytechnique.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">Inria</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">École polytechnique</orgName>
								<orgName type="laboratory" key="lab1">LIX</orgName>
								<orgName type="laboratory" key="lab2">CNRS UMR 7161</orgName>
								<orgName type="institution">Institut polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jade</forename><surname>Nardi</surname></persName>
							<email>jade.nardi@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">Inria</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">École polytechnique</orgName>
								<orgName type="laboratory" key="lab1">LIX</orgName>
								<orgName type="laboratory" key="lab2">CNRS UMR 7161</orgName>
								<orgName type="institution">Institut polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient multivariate low-degree tests via interactive oracle proofs of proximity for polynomial codes</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2021-08-11">August 11, 2021</date>
						</imprint>
					</monogr>
					<idno type="MD5">B5624070B5E6A931E7E8541D900C250D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-03-07T09:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Algebraic coding theory</term>
					<term>Reed-Solomon codes</term>
					<term>Product codes</term>
					<term>Reed-Muller codes</term>
					<term>Low degree testing</term>
					<term>Interactive proof systems</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>We consider the proximity testing problem for error-correcting codes which consist in evaluations of multivariate polynomials either of bounded individual degree or bounded total degree. Namely, given an oracle function f : L m Ñ F q , where L Ă F q , a verifier distinguishes whether f is the evaluation of a low-degree polynomial or is far (in relative Hamming distance) from being one, by making only a few queries to f . This topic has been studied in the context of locally testable codes, interactive proofs, probabilistically checkable proofs, and interactive oracle proofs. We present the first interactive oracle proofs of proximity (IOPP) for tensor products of Reed-Solomon codes (evaluation of polynomials with bounds on individual degrees) and for Reed-Muller codes (evaluation of polynomials with a bound on the total degree).</p><p>Such low-degree polynomials play a central role in constructions of probabilistic proof systems and succinct non-interactive arguments of knowledge with zero-knowledge. For these applications, highly-efficient multivariate low-degree tests are desired, but prior probabilistic proofs of proximity required super-linear proving time. In contrast, for multivariate codes of length N , our constructions admit a prover running in time linear in N and a verifier which is logarithmic in N .</p><p>For fixed constant number of variables m, the efficiency parameters of our IOPPs for multivariate codes compare well, all things equal, with those of the IOPP for Reed-Solomon codes of [Ben-Sasson et al., ICALP 2018]  from which they are directly inspired.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">Introduction</head><p>Let F q be a finite field of size q. Any function f : F m q Ñ F q can be written as a polynomial of individual degrees at most q ´1, hence a polynomial of total degree ď mpq ´1q. The problem of low-degree testing can be formulated as follows. Given a proximity parameter δ P p0, 1q and oracle access to a function f : F m q Ñ F q (as a table of values), check with a few queries whether f is is a polynomial function of low degree compared to q, or δ-far in relative Hamming distance from being low-degree. The main focus of this paper is the problem of low-degree testing applied to a function f : L m Ñ F q with L Ă F q . Multivariate low-degree tests fall into two flavours, depending on whether one requires a bound on the total degree or the individual degree. In the former case, the low-degree test can be considered as a proximity test to a Reed-Muller code. In the latter case, it corresponds to a proximity test to the m-wise tensor product of a Reed-Solomon code. See Section 2 for formal definitions of those codes.</p><p>Low-degree tests have been the subject of a substantial body of research during the past four decades. Indeed, design and better analysis of low-degree tests have gone hand in hand with the construction of efficient probabilistically checkable proofs (PCPs), interactive proofs (IPs) and locally testable codes (LTCs). One motivation for designing probabilistic proof systems with low communication complexity, fast generation and sublinear verification is the application to verifiable computation. In <ref type="bibr" target="#b7">[BBHR18]</ref>, the authors point out that a subsequent bottleneck of PCP-based proof systems is that of computing solutions to the low-degree testing problem for multivariate polynomials. A few years ago, <ref type="bibr" target="#b16">[BCS16,</ref><ref type="bibr" target="#b47">RRR16]</ref> introduced interactive oracle proofs (IOPs), which generalize both PCPs, IPs and interactive PCPs <ref type="bibr" target="#b40">[KR08]</ref> and open a new large design space. On the contrary of known PCPs constructions, it turns out that the IOP model enable the design of proofs systems that are efficient enough for practical applications of zero-knowledge proofs and schemes for delegated computation. Indeed, highly-efficient IOPs lead to efficient succinct transparent noninteractive arguments [AHIV17, BCG `17, BBHR18, BBHR19, KPV19, BCR `19, BCG20] with realworld deployments <ref type="bibr" target="#b8">[BBHR19,</ref><ref type="bibr" target="#b53">Sta21]</ref>. Interactive oracle proofs of proximity (IOPP) are the natural generalization of probabilistically checkable proofs of proximity (PCPP) <ref type="bibr" target="#b29">[DR04,</ref><ref type="bibr">BGH `04]</ref> to the IOP model. Several of the aforementioned constructions crucially rely on a prover-efficient IOPP for Reed-Solomon codes (see Definition 1) which the authors of <ref type="bibr" target="#b7">[BBHR18]</ref> named FRI protocol. Improved soundness analysis of the FRI protocal appear in subsequent works <ref type="bibr" target="#b23">[BKS18,</ref><ref type="bibr" target="#b22">BGKS20,</ref><ref type="bibr">BCI `20]</ref>. While multivariate low degree tests have been extensively studied in the PCPP model, they have not been the subject of any direct construction in the IOPP model.</p></div>
<div><head n="1.1">Interactive oracle proof of proximity to a code</head><p>In this work, we will consider linear codes C with evaluation domain D of size n " |D| and alphabet F q (i.e., C Ď F D q ). An IOPP pP, Vq for a code C is a pair of probabilistic algorithms, P is designated as prover and V as verifier.</p><p>The IOPP pP, Vq has round complexity rpnq if the prover and the verifier interact over at most rpnq rounds. At each round, the verifier sends a message to the prover, and the prover answers with an oracle. We denote by xP Ø Vy P taccept, rejectu the output of V after interacting with P. The notation V f pCq means that f is given as an oracle input to V, while PpC, f q means that the prover has excess to full codeword. Both know the code C.</p><p>Definition 1 (IOPP for a code C). We say that a pair of probabilistic algorithms pP, Vq is an IOPP system for a code C with soundness error s : p0, 1s Ñ r0, 1s if the following two conditions hold: Perfect completeness: If f P C, then PrrxPpC, f q Ø V f pCqy " accepts " 1.</p><p>Soundness: For any function f P F D q such that δ :" ∆pf, Cq ą 0 and any unbounded malicious prover P ˚, PrrxP ˚Ø V f pCqy " accepts ď spδq.</p><p>The IOPP is public-coin if verifier's messages are generated by public randomness and queries are performed after the end of the interaction with the prover. Throughout this paper, we will consider arithmetic complexities, and we assume each arithmetic operation performed in F q takes constant time. Relevant measures for an IOPP system are the following. The alphabet of the IOPP we consider will be a finite field F q . The total number of field elements of all the oracles built by the prover during the interaction is the proof length lpnq of the IOPP. The query complexity qpnq is the total number of symbols queried by the verifier to both the purported codeword f and the oracles sent by the prover during the interaction. The prover complexity t p pnq is the time needed to generate prover messages. The verifier complexity t v pnq is the time spent by the verifier to make her decision when queries and query-answers are given as inputs.</p></div>
<div><head n="1.2">Contributions and outline</head><p>As mentioned above, the focus of the present paper is to tackle the low-degree testing problem for an oracle function f : L m Ñ F q and a degree d ă |L|. Specifically, we propose two direct constructions: the first is an IOPP for the tensor product of Reed-Solomon codes, the second an IOPP for Reed-Muller codes. The alphabets F q which we consider admit either smooth multiplicative subgroups or smooth affine subspaces, where smooth means that the size of the set is a power of a small fixed integer.</p><p>Our two IOPPs are generalizations of the FRI protocol <ref type="bibr" target="#b7">[BBHR18]</ref> to the multivariate case. If m is a constant, they have strictly linear-time prover and strictly logarithmic-time verifier (with respect to the blocklength |L| m of the code). In particular, query complexity is logarithmic in the degree bound d. Previous low-degree tests required the verifier to query a number of field elements linear in d. Since our constructions are explicit, all efficiency measures of the two IOPPs are explicitly presented. These parameters match the IOPP for Reed-Solomon codes of <ref type="bibr" target="#b7">[BBHR18]</ref>, from which they are inspired. Concerning applications to IOP constructions, having a constant number of variables m can be relevant. Indeed, linear-size IOPs have already been constructed from m-wise tensor product codes <ref type="bibr" target="#b11">[BCG20]</ref> and m were a fixed integer there. For Reed-Muller codes and unlike previous works, we are able to consider a support L m where L Ă F q can can be much smaller than F q . We think that allowing smaller support might give more flexibility in the design of proof systems.</p><p>The organization of the paper is the following. Basic definitions and notations are given in Section 2. In Section 3, we define generic folding operators, which allow to reduce the initial proximity testing problem to a constant-size problem by a divide-and-conquer procedure. Then, a generic construction of an IOPP based on such folding operators is presented. The main purpose of Section 3 is to provide once and for all a unified soundness analysis of IOPP constructions which are based on properties of folding operators. This soundness analysis can be applied to the two explicit constructions of IOPPs we give in the present work, and generalizes the analyses of <ref type="bibr" target="#b7">[BBHR18,</ref><ref type="bibr" target="#b24">BN20]</ref>. Section 4 provides technical lemmas about decomposition of multivariate polynomials and multivariate interpolation complexities. In Section 5, we study a special case of worst-case to average-case reduction of distance for linear subspaces, which will be used in our soundness analyses. In Section 7 and Section 8, we instantiate the generic construction of Section 3 to provide an IOPP for tensor products of Reed-Solomon codes and an IOPP Reed-Muller codes, respectively.</p></div>
<div><head n="1.3">Related work and comparisons</head><p>Proximity problem for tensor product of Reed-Solomon codes Low-degree tests for bounded individual degree appear in numerous constructions of probabilistic proof systems [BFL90, BFLS91, PS94, FHS94, ALM `, RS97, FGL `96, BS08] and play a central role in constructing short PCPs <ref type="bibr" target="#b45">[PS94,</ref><ref type="bibr" target="#b26">BS08,</ref><ref type="bibr" target="#b42">Mie09]</ref>. The common idea of such tests is to rely on the following characterization. A function f : F m q Ñ F q is a m-variate polynomial function of individual degrees at most d if and only if, for any k-dimensional axis-parallel affine subspace S of F m q , the restriction of f to S is a k-variate polynomial of individual degree d.</p><p>Ben-Sasson and Sudan <ref type="bibr" target="#b26">[BS08]</ref> constructed a PCPP for the tensor product of RS codes by relying on their PCPP for Reed-Solomon codes. The PCPP to test a function f : L m Ñ F is composed by a PCPP for Reed-Solomon codes (RS-PCPP) for each restrictions of f to an axis-parallel line. Therefore, the prover needs to compute m |L| m´1 RS-PCPP, which yields prover complexity and proof length less than m|L| m log 1.5 |L|. Both verifier complexity and query complexity are polylogarithmic in |L|. Our IOPP for the tensor of RS codes outperforms on all these parameters.</p><p>In the IOP model, there is no IOPP specifically tailored for tensor product of Reed-Solomon codes. Ron-Zewi and Rothblum <ref type="bibr" target="#b46">[RR20]</ref> proposed an IOPP for any language computable in polypn m q time and bounded space. In particular, this gives a linear-size IOPP for Reed-Muller codes and tensor product of Reed-Solomon codes with polynomial prover complexity and sublinear verifier complexity.</p><p>However, there are a couple of IOPP constructions for m-wise tensor product of a generic linear code C. Indeed, axis-parallel tests enable local testability of repeated tensor products of any linear codes <ref type="bibr" target="#b25">[BS06,</ref><ref type="bibr" target="#b54">Vid15,</ref><ref type="bibr" target="#b28">CMS17]</ref>. Ben-Sasson et al. <ref type="bibr">[BCG `17]</ref> suggested a 1-round IOPP system for tensor product codes C bm , where C is an arbitrary linear code and m ě 3. Through interactive proof composition, Ben-Sasson et al. combine the robust local tester of <ref type="bibr" target="#b25">[BS06,</ref><ref type="bibr" target="#b54">Vid15,</ref><ref type="bibr" target="#b28">CMS17]</ref> for tensor product codes with the Mie's PCP of Proximity for non-deterministic languages <ref type="bibr" target="#b42">[Mie09]</ref>. The IOPP system constructed there has sublinear proof length and constant query complexity, which is significantly better than our protocol. However, for fixed m ą 3, the verifier in [BCG <ref type="bibr">`17]</ref> runs in time which is polylogarithmic in the length n of the base code C, whereas our verifier decision complexity is strictly logarithmic in n. Besides, and as opposed as our work, the IOPP system of [BCG <ref type="bibr">`17]</ref> assume the proximity parameter to be smaller than half the minimum distance of the tensor code. Our construction is arguably much simpler to implement, as we do not rely on an heavy PCPP for NTIME, like Mie's one <ref type="bibr" target="#b42">[Mie09]</ref>.</p><p>Recently, Bootle, Chiesa and Groth <ref type="bibr" target="#b11">[BCG20]</ref> showed how to construct a m-rounds IOPP for tensor codes C bm , where C is an arbitrary linear code of length n and dimension k. Their construction also relies on a folding operation (inspired by the FRI protocol of <ref type="bibr" target="#b8">[BBHR19]</ref>) but takes a different approach than ours due to their need to work with linear-time encodable codes. In particular, performing the folding operation defined in <ref type="bibr" target="#b11">[BCG20]</ref> requires to run an encoding algorithm for the m-wise tensor code C bm . When considering C a Reed-Solomon code, best known encoding algorithms run in time at least quasi-linear in n. In contrast, our IOPP does not rely on any encoding procedure of neither the tensor code, nor the base code.</p><p>Proximity problem for Reed-Muller codes A substantial body of research studies low total degree test [GLR `91, RS92, RS96, RS97, AS03, BSVW03, MR08] with evaluations over the entire domain F m q . For this setting, considering restrictions of f to affine subspaces of fixed dimension is quite natural. Indeed, if f : F m q Ñ F q has total degree at most d then all its restrictions to u-dimensional affine subspaces are u-variate polynomials of degree at most d.</p><p>For example, the "line-versus-point" test of Rubinfeld and Sudan <ref type="bibr" target="#b49">[RS96]</ref> consists in checking the </p><formula xml:id="formula_0">[RR20] ; polypn m q pn m q ε Op1q ă n m Op1q [BCG20] ; Opmn m log nq Opnm log nq Opnmq Opn m q m Ours ; ă p2m `4qn m ă 4p2 m `mq log n ă 2 m log n ă n m 2 m ´1</formula><p>ă log n : : PCPP. ; : IOPP. ˚: restricted to m ě 3 and δ smaller than half the minimum distance of the tensor code.</p><p>Figure <ref type="figure">1</ref>: Partial comparison of protocols solving the problem of proximity testing for tensor product of RS codes of length n m . Soundness is omitted since it is difficult to provide and compare uniformly. restriction of the function f to a randomly chosen line in F m q . Analyses [RS96, AS03, ALM `] showed that if the test accepts a function f with probability δ, then f agrees with a degree-d polynomial on » δ fraction of points. The verifier queries Opd 3 q field elements to achieve constant soundness error. The original low-degree test of <ref type="bibr" target="#b49">[RS96]</ref> can be reformulated in terms of a PCPP if we consider that an auxiliary oracle is given in addition to f . Such oracle proof is supposed to contain the restrictions of f to every line, represented as the d `1 coefficients of a univariate polynomial. Then, the number of queries of the PCPP is only two, but symbols of the oracle proof belong are in a large alphabet F d q . Similarly, restrictions to affine subspaces of higher dimensions have also been considered, such as the plane-versus-plane test <ref type="bibr" target="#b50">[RS97,</ref><ref type="bibr" target="#b43">MR08]</ref> and cube-versus-cube test <ref type="bibr" target="#b17">[BDN17]</ref>. The number of field elements needed to be queried is at least linear in d.</p><p>Most results apply to polynomials over fields that are larger than the degree bound d. The local testability of Reed-Muller codes when the degree is larger than the field size has been studied in [AKK `03, AKK `05, JPRZ04, KR04]. Aformentioned results show that generalized Reed-Muller codes are locally testable, and query complexity increases as the size of the field decreases.</p><p>Note however all the above constructions do not apply to the setting we consider where the function f has domain L m where L is strictly contained in F q . Indeed, in such case, the notion of affine subspace does not exist.</p><p>By working in the IOPP model, we are able to construct a low-degree test for total degree with strictly linear oracle proof length which can be generated in linear time and admit logarithmic query complexity and verification time. As mentioned above, previous works require the verifier to make a number of queries which is at least linear in d. Moreover, the size of the oracle proof <ref type="bibr" target="#b48">[RS92]</ref> is polynomial in q m . In order to further reduce the proof size, constructions using a smaller subset of lines have been investigated <ref type="bibr" target="#b36">[GS02,</ref><ref type="bibr" target="#b27">BSVW03,</ref><ref type="bibr" target="#b43">MR08]</ref>. However, such constructions do not achieve a strictly linear oracle proof length, but only proofs of almost linear size. Needlessly to say that proof length is a lower bound on prover running time.</p></div>
<div><head n="2">Definitions and notations</head></div>
<div><head n="2.1">Notations</head><p>Throughout this paper, we denote by F q the finite field of size q and and by F q the multiplicative group of F q . The multiplicative subgroup generated by an element ω P F q will be denoted xωy. The set of functions with domain D and values in F q is denoted by F D q . We use the notation ra . . bs for the set of integers ta, a `1, . . . , bu. Let m ě 1 be an integer.</p><p>Vectors are written in bold, and for two tuples x " px 1 , . . . , x m q and u " pu 1 , . . . , u m q, x u refers to x u :" x u 1 1 ¨¨¨x u k k . We use the notation X " pX 1 , . . . , X m q, and F q rXs refers to the ring of polynomials in the indeterminates X 1 , . . . , X m . For a multivariate polynomial P P F q rXs, we denote by deg P the total degree of P and deg X j P the individual degree of P with respect to the indeterminate X j .</p><p>The Hamming weight w H puq of a vector u P F n q is the number of non-zero symbols of u. We denote by ∆ : F n q ˆFn q Ñ r0, 1s the relative Hamming distance over F q ; namely for u, u 1 P F n q , ∆pu, u 1 q equals the ratio of coordinates in which they differ. A code is any subset of F n q , and a linear code is a F q -linear subspace of F n q . Given u P F n q and a code C Ď F n q , we define ∆pu, Cq to be the minimal distance between u and any codeword of C. If ∆pu, Cq ą δ, we say that u is δ-far from C, otherwise u is δ-close to C. We will consider evaluation codes. In this setting, we view codewords as functions in F D q , and for f P C and x P D, f pxq naturally denotes the x-entry of the codeword f . Henceforth, the term code will always refer to a linear code.</p></div>
<div><head n="2.2">Tensor product of Reed-Solomon codes</head><p>Given two linear codes C 1 Ď F n 1 q and C 2 Ď F n 2 q , a matrix M P F n 2 ˆn1 belongs to the tensor product code C 2 b C 1 if and only if each row of M belongs to C 1 and each column of M belongs to C 2 . For m ě 1 and a code C Ď F n q , we write C bm for the m-wise tensor product of C, where C bm is inductively defined by C 1 " C and C bm " C bm´1 b C for m ą 1.</p><p>Definition 2 (Reed-Solomon code). Given L Ď F q and k ď |L|, we denote by RS rF q , L, ks the Reed-Solomon (RS) code over alphabet F q defined by RS rF q , L, ks :" f P F L q | DP P F q rXs, deg P ă k s.t. @x P L, f pxq " P pxq ( .</p><p>The code RS rF q , L, ks is a linear code of blocklength |L|, dimension k, rate ρ " k |L| and relative minimum distance λ " 1 ´k´1</p><p>|L| . The tensor product of Reed-Solomon codes admits the following aternative definition.</p><p>Definition 3 (Tensor product of Reed-Solomon code). Given L Ă F q , and m, k ě 1, such that k ď |L|, we denote by pRS rF q , L, ksq bm the m-wise tensor product of the code RS rF q , L, ks. Equivalently, the pRS rF q , L, ksq bm can be defined as follows pRS rF q , L, ksq bm :" f P F L m q | DP P F q rXs, deg X i P ă k, i P r1 . . ms , such that</p><formula xml:id="formula_1">@x P L, f pxq " P pxq ( .<label>(1)</label></formula><p>The tensor product code pRS rF q , L, ksq bm has length |L| m , dimension k m , rate ´k |L| ¯m and relative distance ´1 ´k´1 |L| ¯m.</p></div>
<div><head n="2.3">Short Reed-Muller codes</head><p>Reed-Muller codes consist of evaluation of multivariate polynomials with coefficients in F q of bounded total degree. The classical definition of (generalized) Reed-Muller codes involves evaluations over the whole finite field. We introduce here codes whose support is L m Ă F m q , where L may be much smaller than F q . This is an easy generalization, and we call these codes short Reed-Muller codes.</p><p>Definition 4 (Short Reed-Muller code). A short Reed-Muller code with support L m Ă F m q is defined as follows SRM rF q , L, m, ks :" f P F L m q | DP P F q rXs, deg P ă k s.t. @x P L m , f pxq " P pxq ( .</p><p>If k ď |L|, the evaluation map from the space of multivariate polynomials of total degree less than k to the space of functions F L m q is injective, thus the dimension of SRM rF q , L, m, ks is `m`k´1 m ˘. A bound on the minimum distance of SRM rF q , L, m, ks follows from the Schwartz-Zippel lemma <ref type="bibr" target="#b56">[Zip79,</ref><ref type="bibr" target="#b52">Sch80]</ref>, which states that any non-zero multivariate polynomial P P F q rXs of total degree less than q cannot vanish in more than deg P |L| fraction of L m . The code SRM rF q , L, m, ks has length |L m |, rate `m`k´1 m ˘|L| ´m and relative distance at least 1 ´k´1 |L| .</p><p>Remark 1. The setting where the support L m Ă F m q with |L| ! |F q | is not commonly encountered in coding theory. We introduce the non-standard term short Reed-Muller codes to emphasize this fact. Notice that, strictly speaking, short Reed-Muller codes correspond to punctured codes, and not shortened codes.</p></div>
<div><head n="3">Generic interactive oracle proof of proximity based on folding operators</head><p>Given m a positive integer and L Ă F q , the aim of this section is to give an abstract analysis of a generic construction of an IOPP for an evaluation code C Ă tL m Ñ F q u. The protocol presented in Section 3.2 can be seen as an abstract formalization of the IOPP for Reed-Solomon codes of <ref type="bibr" target="#b7">[BBHR18]</ref>, which has been subsequently generalized to algebraic-geometry codes <ref type="bibr" target="#b24">[BN20]</ref>. The framework proposed here handles codes composed by not only functions of m " 1 variable, but also multivariate ones.</p><p>In this section, we assume that one can define a sequence of codes pC i q 0ďiďr for some integer r, where, starting from C 0 :" C, each code C i is a subset of functions L m i Ñ F q and each L i Ă F q satisfy the following. For any i P r0 . . r ´1s, assume there exists a map π i : F m q Ñ F m q such that π i pL m i q " L m i`1 which is l i -to-1 on L m i for a positive integer l i . In particular, |L i`1 | " |L i | l i . For any y P L m i`1 , we will denote S y :" π ´1 i ptyuq the set of the l m i preimages of y by the function π i . The generic IOPP relies on the existence of a family of folding operators for each code C i , as defined next.</p></div>
<div><head n="3.1">Folding operators</head><p>We benefit from the the relations between the evaluation domains to iteratively reduce the proximity test to the code C to a much simpler code C r . To do so, we fix once and for all a positive integer t and for each i P r0 . . r ´1s, we define a family of linear operators Fold r¨, ps :</p><formula xml:id="formula_2">F L m i q Ñ F L m i`1 q</formula><p>parametrized by p P `Fm q ˘t, called folding operators. These operators are designed to "compress" functions on L m i into functions on L m i`1 and feature nice properties with respect to the evaluation codes C i and C i`1 .</p><p>Definition 5 (Folding operator). A folding operator for the code C i is a map Fold r¨, ¨s :</p><formula xml:id="formula_3">F L m i q Fm q ˘t Ñ F L m i`1 q</formula><p>satisfying the following properties.</p><p>1. (Completeness) For any p P `Fm q ˘t, Fold rC i , ps Ď C i`1 .</p><p>2. (Locality) For any function f : L m i Ñ F q , p P `Fm q ˘t and y P L m i`1 , one can compute Fold rf, ps pyq by making l i queries to the function f .</p><p>To ensure soundness of the IOPP based on folding, we will also require that a folding operator preserves the relative distance. Namely, if a function f : L m i Ñ F q is far from the code C i , we expect the folding of the function f to be far from the code C i`1 with high probability over p P `Fm q ˘t. For soundness analysis, we express the distance preservation property in terms of weighted agreements instead of relative Hamming distance.</p><p>Definition 6 (Weighted agreement). For any function of weights φ : D Ñ r0, 1s, we define the φ-agreement of u, v P F D q , denoted µ φ pu, vq, as follows:</p><formula xml:id="formula_4">µ φ pu, vq :" 1 |D| ÿ xPD upxq"vpxq φpxq.</formula><p>Moreover, given C Ă F D q and u P F D q , we define the φ-agreement of u with C, denoted µ φ pu, Cq, as</p><formula xml:id="formula_5">µ φ pu, Cq :" max vPC µ φ pu, vq.</formula><p>Definition 7 (Distance preservation). Let λ i be the minimum relative distance of C i . Let us consider a function ν q,m : p0, 1q Ñ r0, 1s and a function γ : p0, 1q ˆr0, 1s Ñ r0, 1s. We say that a folding operator Fold r¨, ¨s satisfies distance preservation if, for any functions of weights φ i :</p><formula xml:id="formula_6">L m i Ñ r0, 1s and φ i`1 : L m i`1 Ñ r0, 1s such that @y P L m i`1 , φ i`1 pyq ě 1 l i ÿ xPπ ´1 i pyq φ i pxq,<label>(2)</label></formula><p>any ε P p0, 1q, any δ P p0, γpε, λ i qq and any function f :</p><formula xml:id="formula_7">L m i Ñ F q of φ i -agreement µ φ i pf, C i q ă 1´δ, we have Pr pPpF m q q t " µ φ i`1 pFold rf, ps , C i`1 q ą 1 ´δ `mε ‰ ă ν q,m pεq.</formula></div>
<div><head n="3.2">Generic IOPP to a code C based on folding</head><p>Now we describe a generic way of constructing a public-coin IOPP to test proximity to a code C Ď F L m q using folding operators. Taking C 0 " C and L 0 " L, we consider a sequence of codes pC i q with a family of folding operators defined as per Section 3.1. As in the FRI protocol <ref type="bibr" target="#b7">[BBHR18]</ref>, our protocol is divided into two phases. The interactive phase is referred to as COMMIT phase, while the non-interactive one is named QUERY phase.</p><p>The COMMIT phase is an interaction over r rounds between a prover P and a verifier V. At each round i, the verifier samples a random element p i P `Fm q ˘t. The prover answers with an oracle function f i`1 : L m i Ñ F q , which is expected to coincide with Fold rf i , p i s. An honest prover P computes the values taken by the function Fold rf i , p i s on L m i`1 by leveraging the local property of the folding operator (Definition 5).</p><p>During the QUERY phase, the task of V is to check that each pair of oracle functions pf i , f i`1 q is consistent. The standard idea is to test whether the equality</p><formula xml:id="formula_8">f i`1 pyq " Fold rf i , p i s pyq<label>(3)</label></formula><p>holds at a random point y. Thanks to the local property of the folding operator, V only needs to make l m i queries f i and one to f i`1 . As in <ref type="bibr" target="#b7">[BBHR18]</ref>, we call this step of verification a round consistency test. The verifier begins by sampling uniformly at random y 0 P L m 0 and once this is done, all the locations of the round consistency tests below the current query test are determined. More specifically, for each i, V defines y i`1 :" π i py i q to be the point where Equation (3) is checked. Through this process, the round consistency tests are correlated to improve soundness. Such a query test can be seen as a global consistency test, similar to the one run by the FRI protocol. As a final test, the verifier checks membership of the oracle function f r to the last code C r .</p><p>Remark 2. Depending on the evaluation codes considered, it may be convenient to adapt the final round as follows. During the last round of the COMMIT phase, instead of sending a codeword f r P C r , an honest P may "unencodes" f r , meaning he retrieves a word w r from the messages space of C r whose encoding leads to f r P C r . Since C r is an evaluation code, the message space of C r is a space of functions M with the evaluation domain of C r . Prover P sends k r message symbols to represent w r , where k r refers to the dimension of C r . In that case, the verifier no longer needs to run a membership test to the code C r during the QUERY phase. Instead, V computes f r py r q " w r py r q by herself, and checks that this value is equal to Fold " f r´1 , p r´1 ‰ py r q. This variant of the protocol is the one presented in the FRI protocol <ref type="bibr" target="#b7">[BBHR18]</ref> for Reed-Solomon codes (there, w r is a polynomial function of bounded degree). It also appears in the AG-IOPP on Kummer curves proposed in <ref type="bibr" target="#b24">[BN20]</ref>.</p><p>Let us consider a function ν q,m : p0, 1q Ñ r0, 1s, and a function γ : p0, 1q ˆr0, 1s Ñ r0, 1s which is strictly increasing with respect to the second variable. Theorem 1. Let pC i q 0ďiďr be a sequence of codes such that there exists a family of folding operators for each code C i satisfying Definitions 5 and 7. The r-rounds IOPP system pP, Vq for the code C " C 0 described in Figure <ref type="figure" target="#fig_0">2</ref> is public-coin and fulfills the following properties: Perfect completeness: If f P C and if the oracles f 1 , . . . f r are computed by an honest prover P, then V outputs accept with probability 1.</p><p>Soundness: Assume f : L m Ñ F q is δ-far from C. For any ε P p0, 1q and any unbounded prover P ˚, the verifier V outputs accept after α repetitions of the QUERY phase with probability at most rν q,m pεq `p1 ´minpδ, γpε, λqq `rmεq α , where λ denotes the smallest relative minimum distance of the codes C i , i P r0 . . rs.</p><p>Proof. (Perfect completeness) Assume that f 0 P C 0 . An honest prover who follows the prescription of the COMMIT phase will make the round consistency tests pass with probability 1 for all rounds i. By completeness of the folding operator for every round i, we have f r P C r . Therefore, the final test also passes. Thus, the verifier always accepts.</p><p>(Soundness) Our analysis relies on techniques of proofs from <ref type="bibr" target="#b22">[BGKS20]</ref>. A similar analysis appears in <ref type="bibr" target="#b24">[BN20]</ref>. We perform our analysis for α " 1 repetition of the query test. We observe that the soundness error for α ą 1 directly follows from this case. Let pf i q 1ďiďr be the output of the COMMIT phase and py i q 1ďiďr be the query points selected for the QUERY phase. The verifier accepts if both 1. for all i P r0 . . r ´1s, f i`1 py i`1 q " Fold rf i , p i s py i`1 q, 2. f r P C r .</p><p>Observe that if f r R C r , the verifier rejects with probability 1, therefore we continue the analysis assuming f r P C r .</p></div>
<div><head>Input common to Prover and Verifier:</head><p>• m a number of variables,</p><p>• r a number of rounds,</p><p>• pC i q 0ďiďr a sequence of codes.</p></div>
<div><head>COMMIT Phase (interactive)</head><p>Prover's input:</p><formula xml:id="formula_9">• f " f 0 : L m 0 Ñ F q . Protocol:</formula><p>1. For each round i from 0 to r ´1 :</p><p>(a) Verifier V picks uniformly at random an element p i P pF m q q t ; (b) Verifier V sends p i to Prover P;</p><p>(c) An honest Prover P computes Fold rf i , p i s :</p><formula xml:id="formula_10">L m i`1 Ñ F q</formula><p>Prover's output:</p><p>• a sequence of oracle functions</p><formula xml:id="formula_11">f 0 P F L m 1 q , . . . , f r P F L m r q .</formula><p>QUERY Phase (run by V only)</p><p>Verifier's input:</p><p>• p 0 , . . . p r´1 the challenges sent during steps 1b of the COMMIT phase,</p><p>• oracle access to the Prover's output functions</p><formula xml:id="formula_12">f 0 P F L m 1 q , . . . , f r P F L m r</formula><p>q , • a repetition parameter α. Output: acccept or reject. Protocol:</p><p>1. Repeat α times the following query test:</p><p>(a) Sample y 0 P L m 0 uniformly at random; (b) For i " 0 to r ´1: i. Define y i`1 P L m i`1 as y i`1 " π i py i q; ii. Query f i on S y i`1 of size l i to compute Fold rf i , p i s py i`1 q; iii. Query f i`1 py i`1 q; iv. If f i`1 py i`1 q ‰ Fold rf i , p i s py i`1 q, outputs reject (Round consistency check) ; 2. Outputs acccept if and only if f r P C r (Final test). </p><formula xml:id="formula_13">\ L m 1 \ ¨¨¨\ L m r .</formula><p>The edges of G consist in the couples py i , y i`1 q P L m i ˆLm i`1 such that π i py i q " y i`1 . For any edge of G, the vertex y i`1 is called the parent of y i . Vertices sharing the same parent are said to be siblings. For any vertex within the last layer y r P L m r , we denote by G y r the subgraph of G corresponding to the complete tree with root y r . Therefore the trees G y r are disjoint.</p><p>A query test starts by selecting a leaf y 0 P L m 0 , which belongs to a unique tree G y r for a certain y r P L m r . The verifier queries one set of siblings at each layer i P r0 . . r ´1s of G y r , whose union forms a subset of vertices of G that we call the path from y 0 to y r . Note that a path to y r does not include y r .</p><p>We now color the vertices of G (except those in the last layer) according to their success in passing the round consistency test. For i P r0 . . r ´1s, a vertex</p><formula xml:id="formula_14">y i P L m i is colored green if f i`1 pπ i py i qq " Fold rf i , p i s pπ i py i qq</formula><p>and colored red otherwise. Notice siblings have the same color. The verifier outputs accept if and only if every vertex along the queried path from y 0 to y r is green.</p><p>Tracking agreement between f i and the folding of f i´1 Define ψ 0 : L m 0 Ñ r0, 1s such that ψ 0 pxq " 1 if and only if x P L m 0 is green. For all i P r1, r ´1s, define function</p><formula xml:id="formula_15">ψ i : L m i Ñ r0, 1s</formula><p>such that ψ i pxq is equal to the fraction of leaves x 0 P L m 0 for which the path from x 0 to x contains only green vertices.</p><p>By construction, the probability err query that the verifier accepts during the QUERY phase is given by</p><formula xml:id="formula_16">err query " 1 |L r | m ÿ xPL m r ψ r pxq.</formula><p>For i P r0 . . r ´1s, let us set µ f i :" µ ψ i pf i , C i q, where the ψ-agreement µ ψ is defined in Definition 6. Since f r P C r , observe that err query " µ fr .</p><p>For i P r0 . . r ´1s, we define E i`1 Ď L m i`1 to be the set of coordinates where f i`1 differs from Fold rf i , p i s, i.e. E i`1 :" y P L m i`1 | @x P S y , x is red ( . Let us fix i P r0 . . r ´1s. We aim to show that</p><formula xml:id="formula_18">µ ψ i`1 pFold rf i , p i s , C i`1 q ě µ ψ i`1 pf i`1 , C i`1 q. Let v P C i`1 such that µ ψ i`1 pf i`1 , vq " µ ψ i`1 pf i`1 , C i`1 q (breaking</formula><p>ties arbitrarily). Since for any y P E i`1 , ψ i`1 pyq " 0, we can write</p><formula xml:id="formula_19">µ ψ i`1 pFold rf i , p i s , vq " 1 ˇˇL m i`1 ˇˇÿ yPL m i`1 zE i`1 Foldrf i ,p i spyq"vpyq ψ i`1 pyq and µ ψ i`1 pf i`1 , vq " 1 ˇˇL m i`1 ˇˇÿ yPL m i`1 zE i`1 f i`1 pyq"vpyq ψ i`1 pyq.</formula><p>But Fold rf i , p i s and f i`1 coincide on the set L m i`1 zE i`1 , hence</p><formula xml:id="formula_20">µ ψ i`1 pFold rf i , p i s , vq " µ ψ i`1 pf i`1 , vq.</formula><p>Moreover, we have µ ψ i`1 pFold rf i , p i s , C i`1 q ě µ ψ i`1 pFold rf i , p i s , vq by definition of the ψ i`1agreement. Thus,</p><formula xml:id="formula_21">µ ψ i`1 pFold rf i , p i s , C i`1 q ě µ ψ i`1 pf i`1 , C i`1 q. (<label>5</label></formula><formula xml:id="formula_22">)</formula><p>Let ε P p0, 1q and δ i ă minp1 ´µf i , γpε, λ i qq. Observe that</p><formula xml:id="formula_23">ψ i`1 pyq " $ ' &amp; ' % 0 if y P E i`1 , 1 l i ÿ xPSy ψ i pxq if y P L m i`1 zE i`1 .</formula><p>Thus, the functions ψ i satisfy (2):</p><formula xml:id="formula_24">@y P L m i`1 , ψ i`1 pyq ě 1 l i ÿ xPSy ψ i pxq.</formula><p>Since the folding operators satisfy distance preservation (Definition 7), we have for all i P r0 . . r ´1s</p><p>Pr</p><formula xml:id="formula_25">p i PpF m q q t " µ ψ i`1 pFold rf i , p i s , C i`1 q ą 1 ´δi `mε ‰ ď ν q,m pεq,</formula></div>
<div><head>which yields</head><p>Pr</p><formula xml:id="formula_26">p i PpF m q q t " µ ψ i`1 pFold rf i , p i s , C i`1 q ą max pµ f i , 1 ´γpε, λ i qq `mε ‰ ď ν q,m pεq.</formula><p>Let λ " min i pλ i q. As the function γpε, ¨q is strictly increasing, we have</p><formula xml:id="formula_27">Pr p i PpF m q q t " µ ψ i`1 pFold rf i , p i s , C i`1 q ą max pµ f i , 1 ´γpε, λqq `mε ‰ ď ν q,m pεq.</formula><p>Recalling (5), we deduce that</p><formula xml:id="formula_28">Pr p i PpF m q q t " µ f i`1 ą max pµ f i , 1 ´γpε, λqq `mε ‰ ď ν q,m pεq.</formula><p>Thus, the event that for all i P r0 . . r ´1s, µ f i`1 ď max pµ f i , 1 ´γpε, λqq `mε occurs with probability at least 1 ´rν q,m pεq. If this event occurs, then µ fr ď max pµ f 0 , 1 ´γpε, λqq `rmε. Therefore Pr p 0 ,...,p r´1 PpF m q q t rµ fr ď max pµ f 0 , 1 ´γpε, λqq `rmεs ě 1 ´rν q,m pεq.</p><p>Recall that µ f 0 ď 1 ´∆pf 0 , C 0 q ă 1 ´δ and err query " µ fr . Set err commit :" rν q,m pεq. We deduce that with probability at least 1 ´err commit over the randomness of the verifier during the COMMIT phase, the verifier accepts with probability at most err query " µ fr ď maxpµ f 0 , 1 ´γpε, λqq `rmε ă 1 ´minpδ, γpε, λqq `rmε.</p><p>Remark 3. An analogous proof yield the same completeness and soundness when applied to the variant of the protocol described in Remark 2.</p><p>4 Preliminaries about multivariate polynomials</p></div>
<div><head n="4.1">Low-degree extensions</head><p>To benefit from the algebraic structure of an evaluation code C Ă F D q , it is classical to recover a polynomial which coincides with f on D for any f P C. We choose such a polynomial to have low degree with respect to the size of the domain D, when D is a cartesian product.</p><p>Proposition 1 (Low-degree extension ([BFLS91])). Let H 1 , . . . , H m Ď F q and let f : H 1 ˆ¨¨¨Ĥ m Ñ F q be a function. Then there exists a unique polynomial p f in m variables over F q such that :</p><formula xml:id="formula_29">1. p f has degree deg X i p f ă |H i | in its i-th variable, 2. p f agrees with f on H 1 ˆ¨¨¨ˆH m .</formula><p>The polynomial p f is referred to as the low-degree extension of the function f (with respect to F q and H 1 , . . . , H m ).</p><p>Proof. For H Ă F q and h P H, denote L H,h pXq :" ś kPHzthu X´k h´k the Lagrange polynomial. The existence follows from the observation that the polynomial defined by</p><formula xml:id="formula_30">ÿ hPH 1 ˆ¨¨¨ˆHm f phq m ź j"1 L H j ,h j pX j q</formula><p>has degree less than |H j | in each variable and agrees with f on H 1 ˆ¨¨¨ˆH m . An easy induction on m leads to uniqueness.</p><p>The arithmetic complexity of solving the interpolation problem of computing the coefficients of the low-degree extension of a function f : H 1 ˆ¨¨¨ˆH m Ñ F q appears in <ref type="bibr" target="#b44">[Pan94]</ref> for general subsets H 1 , . . . , H m Ă F q . In our work, we will be specifically interested in the cost of interpolating and evaluating low-degree extensions of a function defined on a grid of size 2 m . Definition 8. A multilinear polynomial is a multivariate polynomial whose degree in each variable is at most one.</p><p>Lemma 1 (Multilinear interpolation ([Pan94])). Let H 1 , . . . , H m Ă F q of size 2 and let f : H 1 Ĥm Ñ F q be a function. The low-degree extension of f is a multilinear polynomial p f P F q rXs. The number of operations required to interpolate p f is at most m2 m arithmetic operations.</p><p>Lemma 2 (Efficient multilinear extension). Let H 1 , . . . , H m Ă F q of size 2 and let f : H 1 ˆ¨¨¨Ĥ m Ñ F q be a function. The low-degree extension of f is a multilinear polynomial p f P F q rXs and, given p P F m q , evaluating p f at p can be done in less than 4p2 m `mq arithmetic operations.</p><p>Proof. For any h " ph 1 , . . . , h m q P H 1 ˆ¨¨¨ˆH m , define L h pXq :" ś m j"1 L H j ,h j pX j q. For any p " pp 1 , . . . , p m q P F m q , we have</p><formula xml:id="formula_31">p f ppq " ÿ hPH 1 ˆ¨¨¨ˆHm f phqL h ppq.<label>(6)</label></formula><p>As suggested by <ref type="bibr" target="#b55">[VSBW13]</ref> regarding multilinear extensions over the boolean hypercube, we observe that pL h ppqq hPH 1 ˆ¨¨¨ˆHm can be computed in linear time and linear space using dynamic programming.</p><p>Notice that for all k P r1 . . ms,</p><formula xml:id="formula_32">k ź j"1 L H j ,h j pp j q " L H k ,h k pp k q k´1 ź j"1 L H j ,h j pp j q</formula><p>and deg L H k ,h k " 1. Given a table of values containing ś k´1 j"1 L H j ,h j pp j q for all ph 1 , . . . , h k´1 q P H 1 ˆ¨¨¨ˆH k´1 , one can get the values ś k j"1 L H j ,h j pp j q for all ph 1 , . . . , h k q P H 1 ˆ¨¨¨ˆH k by computing the couple of values pL H k ,h k pp k qq h k PH k using 2 additions and 2 divisions, and multiplying both of them by all the 2 k´1 precomputed values. In sum, this step requires 2 k `4 operations. Thus, computing L h ppq for all h P H 1 ˆ¨¨¨ˆH m takes ř m j"1 `2j `4˘ă 2 ¨2m `4m arithmetic operations. Finally, given the table of values of f and pL h ppqq hPH 1 ˆ¨¨¨ˆHm , computing the right-hand side of (6) takes 2 m multiplications and p2 m ´1q additions.</p></div>
<div><head n="4.2">Multivariate polynomial decomposition</head><p>One efficient way to build folding operators on codes formed by evaluations of polynomials relies on some ingenious decompositions, as in <ref type="bibr" target="#b26">[BS08,</ref><ref type="bibr" target="#b7">BBHR18]</ref>. This section gathers all the technical results about such decompositions and their properties.</p><p>Lemma 3. Let R be an integral domain, and let q P RrXs be a monic polynomial of degree l. For every f P RrXs there exists a unique sequence of polynomials pf u pXqq 0ďuďt deg f l u such that f pXq "</p><formula xml:id="formula_33">tdeg f {lu ÿ u"0 f u pXqqpXq u .</formula><p>Furthermore, deg f u ă l, for u P r0 . . tdeg f {lus.</p><p>Proof. As in [BS08, Proposition 6.3], we consider the Euclidean division of f pXq by pY ´qpXqq in the polynomial ring RrY srXs, i.e. with respect to the X variable. Polynomial division by a monic polynomial over an integral domain shares the same properties as polynomial division over a field. There exists a unique pair of polynomials A, B P RrXsrY s such that f pXq " pY ´qpXqqApX, Y q `BpX, Y q such that deg X B ă deg q. Writing BpX, Y q " ř f u pXqY u , with deg f u ă deg q, and evaluating the above identity at Y " qpXq gives f pXq " ř f u pXqqpXq u as required, with appropriate degree bounds. The uniqueness of the decomposition follows from the one of the remainder B in the Euclidean division, as any other decomposition ř u"0 f 1 u pXqqpXq u with the same degree bounds would induce another remainder</p><formula xml:id="formula_34">ř u"0 f 1 u pXqY u ‰ B.</formula><p>Lemma 4. Let R be an integral domain, and let q P RrXs be a monic polynomial of degree l. For every f P RrXs there exists a unique sequence pf u q uPU of polynomials in RrXs such that</p><formula xml:id="formula_35">f pXq " ÿ u"pu 1 ,...,umqPU f u pX 1 , . . . , X m qqpX 1 q u 1 ¨¨¨qpX m q um ,<label>(7)</label></formula><p>where U " " 0 . .</p><formula xml:id="formula_36">X deg X 1 f {l \‰ ˆ¨¨¨ˆ"0 . . X deg Xm f {l \‰</formula><p>and deg X i f u pXq ă l for i P r1 . . ms and u P U .</p><p>Proof. The proof is done by induction on the number m of indeterminates, the case m " 1 being established in Lemma 3. Suppose the result holds for m ´1 indeterminates and consider f pXq as a polynomial in RrX 1 srX 2 , . . . , X m s. Since RrX 1 s is an integral domain, we can apply the induction hypothesis, and there exists a unique sequence pf u 1 pX 1 , X 2 , . . . , X m qq u 1 PU 1 P RrX 1 srX 2 , . . . , X m s such that f pX 1 , X 2 , . . . , X m q " ÿ pu 2 ,...,umqPU 1 f u 2 ,...,um pX 1 , X 2 , . . . , X m qqpX 2 q u 2 ¨¨¨qpX m q um where U</p><formula xml:id="formula_37">1 " " 0 . . X deg X 2 f {l \‰ ˆ¨¨¨ˆ"0 . . X deg Xm f {l \‰</formula><p>and, for each i P r2 . . ms:</p><formula xml:id="formula_38">deg X i f u 2 ,...,um pX 1 , X 2 , . . . , X m q ă l. Writing f u 2 ,...,um " ÿ 0ďu 2 ,...,umăl g u 2 ,...,um pX 1 qX u 2 2 ¨¨¨X um m</formula><p>and applying Lemma 3 to each polynomial g u 2 ,...,um P RrX 1 s, we obtain a unique sequence</p><formula xml:id="formula_39">pg u 1 ,u 2 ,...,um pX 1 qq 0ďu 1 ďtpdeg X 1 f {lu of polynomials in RrX 1 s such that g u 2 ,...,um pX 1 q " tpdeg X 1 f {lu ÿ u 1 "0 g u 1 ,u 2 ,...,um pX 1 qqpX 1 q u 1</formula><p>and deg g u 1 ,u 2 ,...,um pX 1 q ă l. This gives</p><formula xml:id="formula_40">f u 2 ,...,um " ÿ 0ďu 2 ,...,umăl tpdeg X 1 f {lu ÿ u 1 "0 g u 1 ,u 2 ,...,um pX 1 qX u 2 2 ¨¨¨X um m qpX 1 q u 1 ,</formula><p>which leads to the expected decomposition after collecting terms.</p><p>Proposition 2 (Multivariate decomposition). Let R be an integral domain, and let q P RrXs be a monic polynomial of degree l. For every f P RrXs there exists a unique sequence pg e q ePr0. .l´1s m of polynomials in RrXs such that</p><formula xml:id="formula_41">f pXq " ÿ ePr0. .l´1s m</formula><p>X e g e pqpX 1 q, . . . , qpX m qq ,</p><p>• for all e P r0 . . l ´1s m and j P r1 . . ms, deg</p><formula xml:id="formula_43">X j g e ď Z deg X j f l ^,</formula><p>• for all e P r0 . . l ´1s m , deg g e ď</p><formula xml:id="formula_44">Y deg f ´wH peq l ] .</formula><p>Proof. We use the notation of Lemma 4. For each u P U , writing each polynomial f u as f u pXq " ř ePr0. .l´1s m a u,e X e , Equation (7) becomes</p><formula xml:id="formula_45">f pXq " ÿ uPU ÿ ePr0.</formula><p>.l´1s m a u,e X e qpX 1 q u 1 ¨¨¨qpX m q um , " ÿ ePr0. .l´1s m X e ÿ uPU a u,e qpX 1 q u 1 ¨¨¨qpX m q um .</p><p>For each e P r0 . . l ´1s m , define g e pXq " ř uPU a u,e X u . We thus get the decomposition of Equation (8). The bounds for individual degrees of each g e comes from the definition of U . Moreover, we have deg f " max e tdegpX e g e pqpX 1 q, . . . , qpX m qqqu, thus deg f ě w H peq `l deg g e .</p><p>The uniqueness of the sequence of polynomials pg e q e follows from the one of the sequence of polynomials pf u q u .</p></div>
<div><head n="5">Distance preservation for random multilinear combinations</head><p>In this section, we study a special case worst-case to average-case reduction of distance for linear subspaces. Several works looked at this question [RVW13, AHIV17, BKS18, BGKS20] for general linear subspaces, but we are interested in the following specific context. For u " pu e q ePt0,1u m Ă F D q , and p P F m q , we consider the set</p><formula xml:id="formula_46">S u :" $ &amp; % ÿ ePt0,1u m p e u e | p P F m q , .</formula><p>of multilinear combinations of elements of u. Given a linear code C Ă F D q , we estimate the averagedistance to C of an element u 1 P S u compared to the maximum distance to C of a member u e from u.</p></div>
<div><head n="5.1">Hamming distance version</head><p>Proposition 3. Let m be a positive integer. Let C Ă F D q be a linear code of relative distance λ " ∆pCq. Let ε, δ ą 0 such that ε ă 1{3 and δ ă 1 ´p1 ´λ `εq 1{3 .</p><p>(9)</p><p>Let u " pu e q ePt0,1u m such that</p><formula xml:id="formula_47">Pr pPF m q » -∆ ¨ÿ ePt0,1u m p e u e , C ‚ă δ fi fl ě 2m ε 2 q . (<label>10</label></formula><formula xml:id="formula_48">)</formula><p>Then there exist T Ă D and a family v " pv e q ePt0,1u m P C 2 m such that</p><formula xml:id="formula_49">• |T | ě p1 ´δ ´mεq |D|,</formula><p>• for each e P t0, 1u m , u e|T " v e|T .</p><p>Proof. We proceed by induction on the number of variables m. The case m " 1 is dealt with in [BGKS20, Lemma 3.2]. Let us assume that the proposition is true for m ´1 and prove that it also holds for m. For p P F m q , we write p " pp, p m q, with p P F m´1 q and p m P F q . Similarly, for e P t0, 1u m , we write e " pẽ, e m q, with ẽ P t0, 1u m´1 and e m P t0, 1u. Equation (10) gives</p><formula xml:id="formula_50">Pr pmPFq » -Pr pPF m´1 q » -∆ ¨ÿ ẽPt0,1u m´1 pẽ `upẽ,0q `pm u pẽ,1q ˘, C ‚ă δ fi fl ě 2pm ´1q ε 2 q fi fl ě 2 ε 2 q .</formula><p>For any z P F q , we write u ẽ,z " u pẽ,0q `zu pẽ,1q . Let A be the set</p><formula xml:id="formula_51">A " $ &amp; % z P F q ; Pr pPF m´1 q » -∆ ¨ÿ ẽPt0,1u m´1 pẽ u ẽ,z , C ‚ă δ fi fl ě 2pm ´1q ε 2 q , .</formula><p>-.</p><p>By assumption, |A| ě 2{ε 2 . Moreover the inductive hypothesis implies that for each z P A, there exist T z Ă D and v ẽ,z P C such that |T z | ě p1 ´δ ´pm ´1qεq |D| and u ẽ,z |Tz " v ẽ,z |Tz for all ẽ P t0, 1u m´1 .</p><p>We are now in a position where we can mimic the proof of <ref type="bibr" target="#b22">[BGKS20]</ref>.</p><p>Let us prove there exists a large subset A 1 Ă A such that for all ẽ P t0, 1u m´1 and for all z P A 1 , v ẽ,z depends linearly on z, i.e. there exists some v pẽ,0q , v pẽ,1q P C such that v ẽ,z " v pẽ,0q `zv pẽ,1q .</p><p>For z 0 , z 1 , z 2 , picked uniformly and independently in A and y picked uniformly from D, we have</p><formula xml:id="formula_52">E z 0 ,z 1 ,z 2 " |T z 0 X T z 1 X T z 2 | |D|  " E y,z 0 ,z 1 ,z 2 " 1 yPTz 0 XTz 1 XTz 2 ‰ " E y " E z r1 yPTz s 3 ı ě E y,z r1 yPTz s 3 ě p1 ´δq 3 ě 1 ´δ `ε.</formula><p>From this, one obtains:</p><formula xml:id="formula_53">Pr z 0 ,z 1 ,z 2 r|T z 0 X T z 1 X T z 2 | ě p1 ´δq |D|s ě ε.</formula><p>The probability of z 0 , z 1 , z 2 being all distinct is at least 1 ´3 |A| , which is greater than 1 ´ε 2 since |A| ě 2 ε 2 ą 6 ε . Thus, we get</p><formula xml:id="formula_54">Pr z 0 ,z 1 ,z 2 rz 0 , z 1 , z 2 are all distinct and |T z 0 X T z 1 X T z 2 | ě p1 ´δq |D|s ě ε{2.</formula><p>Consequently, there are distinct z 1 and z 2 such that</p><formula xml:id="formula_55">Pr z 0 r|T z 0 X T z 1 X T z 2 | ě p1 ´δq |D|s ě ε{2. Fix z 0 P F q such that |T z 0 X T z 1 X T z 2 | ě p1 ´δq |D| and set S " T z 0 X T z 1 X T z 2 .</formula><p>For each ẽ P t0, 1u m´1 , the vectors pz 0 , u ẽ,z 0 q , pz 1 , u ẽ,z 1 q , pz 2 , u ẽ,z 2 q are collinear. Then their restrictions to S, ´zi , u ẽ,z i |S ¯, which coincide with ´zi , v ẽ,z i |S ¯by definition of S, are also collinear. Since S is an information set of C, we can linearly map the vectors v ẽ,z i |S to elements v ẽ,z i of the code C, which preserves collinearity. Therefore, the vectors v ẽ,z i (z " z 0 , z 1 , z 2 ) all belong to a same line v pẽ,0q `zv pẽ,1q ; z P F q ( Ă F D q where v pẽ,0q , v pẽ,1q P C.</p><formula xml:id="formula_56">Set A 1 " z P A | v ẽ,z " v pẽ,0q `zv pẽ,1q ( . Then we have |A 1 | ě ε 2 |A| ě 1 ε . Now consider the set</formula><p>T " ! x P D|@ẽ P t0, 1u m´1 , u pẽ,0q pxq " v pẽ,0q pxq and u pẽ,1q pxq " v pẽ,1q pxq ) .</p><p>For any x P DzT , there exists at most one z P F q such that, for all ẽ P t0, 1u m´1 , u pẽ,0q pxq `zu pẽ,1q pxq " v pẽ,0q pxq `zv pẽ,1q pxq.</p><p>For any z P A 1 , for any ẽ P t0, 1u m´1 , we have</p><formula xml:id="formula_57">1 ´|T z | |D| ě ∆ D pu ẽ,z , v ẽ,z q.</formula><p>We thus also have</p><formula xml:id="formula_58">1 ´|T z | |D| ě E zPA 1 r∆ D pu ẽ,z , v ẽ,z qs ě |Dzx| |D| ˆ1 ´1 |A 1 | ě ˆ1 ´|T | |D| ˙p1 ´εq ě 1 ´|T | |D| ´ε</formula><p>Using |T z | ě p1 ´δ ´pm ´1qεq |D|, and rearranging, we get |T | ě p1 ´δ ´mεq |D|.</p></div>
<div><head n="5.2">Weighted agreement version</head><p>For soundness analysis, we need a variant of Proposition 3 stated in terms of weighted agreement. This technical result will be used to prove distance preservation properties in Section 7 and Section 8.</p><p>Proposition 4. Let m be a positive integer. Let C Ă F D q be a linear code of distance λ " ∆pCq. Let ε, δ ą 0 such that ε ă 1{3 and δ ă 1 ´p1 ´λ `εq 1{3 .</p><p>For any weight function φ : D Ñ r0, 1s and any u " pu e q ePt0,1u m satisfying Pr</p><formula xml:id="formula_59">pPF m q » -µ φ ¨ÿ ePt0,1u m p e u e , C ‚ą 1 ´δfi fl ě 2m ε 2 q , (<label>11</label></formula><formula xml:id="formula_60">)</formula><p>there exist T Ă D and a family v " pv e q ePt0,1u m P C 2 m such that</p><formula xml:id="formula_61">• ř xPT φpxq ě p1 ´δ ´mεq |D|, • for each e P t0, 1u m , u e|T " v e|T .</formula><p>Before proving Proposition 4, we first state a variant of [BGKS20, Lemma 3.2]. The proof of Lemma 5 is relatively straigthforward, based on the original proof of [BGKS20, Lemma 3.2]. We provide it in Appendix A for completeness.</p></div>
<div><head>Lemma 5 ([BGKS20]</head><p>). Let C Ă F D q be a linear code of distance λ " ∆pCq. Let ε, δ ą 0 such that ε ă 1{3 and δ ă 1 ´p1 ´λ `εq 1{3 .</p><p>For any weight function φ : D Ñ r0, 1s and any functions u 0 , u 1 P F D q satisfying Pr zPFq</p><formula xml:id="formula_62">rµ φ pu 0 `zu 1 , Cq ą 1 ´δs ě 2 ε 2 q , (<label>12</label></formula><formula xml:id="formula_63">)</formula><p>there exist T Ă D and v 0 , v 1 P C, such that</p><formula xml:id="formula_64">• ř xPT φpxq ě p1 ´δ ´εq |D|, • for each i P t0, 1u, u i|T " v i|T .</formula><p>Proof of Proposition 4. As for Proposition 3, we proceed by induction on m. The case m " 1 is treated by Lemma 5. Let us assume that the statement is true for m ´1.</p><p>Observe that if the function φ : D Ñ r0, 1s is constant equal to 1, then µ φ pu, vq " 1 ´∆pu, vq. Therefore, for any weight function φ : D Ñ r0, 1s and any u, v P F D q , µ φ pu, vq ď 1 ´∆pu, vq. Consequently, µ φ pu, Cq ď 1 ´∆pu, Cq.</p><p>Thus we get from (11):</p><formula xml:id="formula_65">$ &amp; % p P F m q | µ φ ¨ÿ ePt0,1u m p e u e , C ‚ą 1 ´δ, . - Ď $ &amp; % p P F m q | ∆ ¨ÿ ePt0,1u m p e u e , C ‚ă δ , .</formula><p>-</p><formula xml:id="formula_66">.</formula><p>The latter set has size at least 2m ε 2 q m´1 . Then, the proof follows the proof of Proposition 3, until we get a set A 1 Ă A of size at least 1{ε and v pa,0q , v pa,1q P C such that for all a P t0, 1u m´1 , for all z P A 1 , v a,z " v pa,0q `zv pa,1q .</p><p>Let T be the set T "</p></div>
<div><head>!</head><p>x P D| for all a P t0, 1u m´1 , u pa,0q pxq " v pa,0q pxq and u pa,1q pxq " v pa,1q pxq</p><p>) .</p><p>For all a P t0, 1u m´1 , for all z P A 1 , ∆pu pa,0q `zu pa,1q , v pa,0q `zv pa,1q q ă δ `pm ´1qε. Still noting u a,z " u a,0 `zu a,1 and v a,z " v a,0 `zv a,1 , we get µ φ pu a,z , v a,z q ą 1 ´δ ´pm ´1qε. We have:</p><formula xml:id="formula_67">1 ´δ ´pm ´1qε ă 1 |A 1 | ÿ zPA 1 µ φ pu a,z , v a,z q ă 1 |A 1 | |D| ÿ zPA 1 ÿ xPD `φpxq ¨1ua,zpxq"va,zpxq ă 1 |D| ÿ xPD φpxq ¨˜1 |A 1 | ÿ zPA 1</formula><p>1 ua,zpxq"va,zpxq ¸.</p><p>For x P DzT , there is at most one element z P F q such that u pa,0q pxq `zu pa,1q pxq " v pa,0q pxq zv pa,1q pxq. Thus, we get</p><formula xml:id="formula_68">1 ´δ ´pm ´1qε ă 1 |D| ÿ xPT φpxq `1 |D| ÿ xPDzT φpxq 1 |A 1 | ă 1 |D| ÿ xPT φpxq `ε.</formula><p>Rearranging, we have ř xPT φpxq ą p1 ´δ ´mεq |D|.</p></div>
<div><head n="6">Sequence of evaluation domains defined by two-to-one maps</head><p>In this section, we provide a common notation for two different settings, depending on the algebraic nature of the evaluation domain L. The first one will be prime fields which admit a 2-smooth multiplicative subgroup. The second one will be fields of characteristic two. These two settings also appear in <ref type="bibr" target="#b26">[BS08,</ref><ref type="bibr" target="#b7">BBHR18]</ref> in the context of proximity testing to Reed-Solomon codes.</p></div>
<div><head n="6.1">Case of a smooth multiplicative group</head><p>Let us assume that F q is a prime field and q ´1 is divisible by a power of two, i.e. q " a ¨2n `1 for some positive integers a and n. We will consider L 0 Ă F q a cyclic multiplicative group of order 2 n . For any integer r, we define a sequence of evaluation sets pL i q 0ďiďr as: L i`1 :" q i pL i q where q i pXq " X 2 . Let A i Ă L i a multiplicative subgroup of L i of size 2, each multiplicative coset of A i is mapped to a single element of L i`1 by the map x Þ Ñ q i pxq.</p></div>
<div><head n="6.2">Case of an affine subspace in characteristic 2</head><p>If F q has characteristic two, we consider L 0 Ă F q an affine subspace over F 2 of dimension n. Let A i Ă L 0 be an F 2 -affine subspace with dim A i " 1. Define q i pXq :" ś aPA i pX ´aq. Then q i pXq is a so-called subspace polynomial, also known as linearized polynomials when A i is a vector space. It has the form X 2 `αX `β for α, β P F q , and each additive coset of A i is mapped to a single element of L i`1 by the map x Þ Ñ q i pxq, and dim L i`1 " dim L i ´dim A i " dim L i ´1. For more on affine and linearized polynomials, see [LN97, Section 3.4].</p></div>
<div><head n="6.3">Common properties</head><p>In both cases, we have that</p><formula xml:id="formula_69">|L i`1 | " 1 2 |L i | " 1 2 i |L 0 |. Moreover, the map π i : L m i Ñ L m i`</formula><p>1 defined by π i pxq :" pq i px 1 q, . . . , q i px m qq is 2 m -to-1 on its domain.</p><p>A crucial ingredient of the constructions presented in the two next sections will be the following fact: if f : L m i Ñ F q corresponds to the evaluation of a polynomial p f P F q rXs of bounded degree, then Proposition 2 gives a decomposition of f in terms of functions pg e ˝πi q ePt0,1u m where g e : L m i`1 Ñ F q is the evaluation of a polynomial of half degree. Remark 4. The choice to consider degree-2 maps q i is intended to simplify the exposition. Recall that Proposition 2 is stated for q i of arbitrary degree l. After examining proofs of Sections 7 and 8, one can see that the generalization to maps of higher degree is also valid.</p></div>
<div><head n="7">Tensor product of Reed-Solomon codes</head></div>
<div><head n="7.1">Sequence of codes</head><p>Let k be a power of two and set r " log 2 k. As suggested in Section 6, depending on whether we work in case 6.1 or 6.2, consider L Ă F q of size |L| ą k which is either a cyclic group of order a power of two, or an affine subspace over F 2 . We will use the notations introduced in Section 6 and will consider L 0 " L, L 1 , . . . , L r as defined there.</p><p>Set k 0 :" k. For 0 ă i ď r, define k i`1 :" k i 2 . In particular, for all i, we have k i ă |L i |. In the sequel, we denote by pRS m i q 0ďiďr where RS m i the sequence of tensor product of RS codes refers to the code pRS rF q , L i , k i sq bm , regardless we are in case 6.1 or 6.2.</p><p>Notice that, for all i P r0, rs, we have k i ă |L i |. Moreover, each code RS m i has same rate R :" ´k |L| ¯m. The first code RS m 0 has relative distance λ :" ´1 ´k´1 |L| ¯m and the sequence of relative distances corresponding to pRS m i q 0ďiďr is strictly increasing.</p></div>
<div><head n="7.2">Folding operators</head><p>For each code RS m i , 0 ď i ă r, we define a family of folding operators satisfying the distance preservation property. They will enable us to iteratively reduce the problem of proximity testing to a code RS m i to a problem of size 2 m times smaller, namely proximity testing to RS m i`1 .</p><p>Definition 9 (Folding operators). Let i P r0, r ´1s. Let f : L m i Ñ F q be an arbitrary function and let p f be its low-degree extension. Let pp g e q ePt0,1u m be the 2 m m-variate polynomials provided by Proposition 2 applied to p f . We consider their evaluations on L m i`1 , respectively denoted by g e . For any p P F m q , we define the folding of f Fold rf, ps as the following function:</p><p>Fold rf, ps :</p><formula xml:id="formula_70">$ &amp; % L m i`1 Ñ F q , y Þ Ñ ÿ ePt0,1u m</formula><p>p e g e pyq.</p><p>(13)</p><p>First, we show that this defines a folding operator for the code RS m i as per Definition 5.</p><p>Lemma 6 (Completeness). For any p P F m q , if f P RS m i , then Fold rf, ps P RS m i`1 .</p><p>Proof. Proposition 2 shows that, for all e P t0, 1u m and all j P r1, ms, deg</p><formula xml:id="formula_71">X j p g e ď Y k i ´1<label>2</label></formula><p>] , which is strictly less than k i`1 since k i is even.</p><p>Lemma 7 (Locality). Let f : L m i Ñ F q be an arbitrary function and let p P F m q . The value of Fold rf, ps at any y P L m i`1 can be computed with exactly 2 m queries to f .</p><p>Proof. Take y " py 1 , . . . , y m q P L m i`1 . For each j P r1 . . ms, define S y j Ă L i the coset of A i such that q i pS y j q " y j (i.e. S y j is the set of roots of the polynomial q i pXq ´yj ). Set S y " ś m j"1 S y j and consider P f,y P F q rXs the unique low-degree extension of f Sy .</p><p>Let us prove that for all p P F m q , we have P f,y ppq " Fold rf, ps pyq, which would induce that the value of Fold rf, ps pyq can be computed by interpolating the set of points tpx, f pxqq, x P S y u of size 2 m .</p><p>By Lemma 4, one can write p f pXq "</p><formula xml:id="formula_72">ÿ uPU p f u pXqq i pX 1 q u 1 ¨¨¨q i pX m q um</formula><p>with for all u P U and j P r1, ms, deg X j f u ă 2. Since the polynomial p f pXq and P f,y pXq agree on S y , we get that p f pXq " P f,y pXq mod pq i pX 1 q ´y1 , . . . , q i pX m q ´ym q.</p><p>By definition of the low-degree extension, deg X j P f,y ă 2 for all j, thus P f,y pXq "</p><formula xml:id="formula_73">ÿ uPU p f u pXqy u .</formula><p>For each u P U , write each polynomial f u as f u pXq " ř ePt0,1u m a u,e X e . Proof of Proposition 2 shows that each polynomial p g e is equal to ř uPU a u,e X u . Therefore, for all y P L m i`1 , we have</p><formula xml:id="formula_74">P f,y pXq " ÿ ePt0,1u m X e p g e pyq.</formula><p>Finally, for all p P F m q and y P L m i`1 , the evaluation of Fold rf, ps at y can be obtained by evaluating P f,y at p.</p><p>Let us now show that Definition 9 satisfies distance preservation (Definition 7) for ν q,m pεq " 2m ε 2 q and γpε, λq " 1 ´p1 ´λ `εq 1 3 .</p><p>Proposition 5 (Distance preservation). Let f i : L m i Ñ F q be an arbitrary function. Let ε P `0, 1 3 ȃnd δ ă 1 ´p1 ´λ `εq 1 3 . Let φ i : L m i Ñ r0, 1s and φ i`1 : L m i`1 Ñ r0, 1s be weight functions such that</p><formula xml:id="formula_75">@y P L m i`1 , φ i`1 pyq ď 1 2 m ÿ xPSy φ i pxq. If f : L m i Ñ F q has weighted agreement µ φ i pf, RS m i q ă 1 ´δ, then Pr pPF m q " µ φ i`1 pFold rf, ps , RS m i`1 q ą 1 ´δ `mε ‰ ă 2m ε 2 q .</formula><p>Proof. We proceed by contraposition and we assume</p><formula xml:id="formula_76">Pr pPF m q " µ φ i`1 pFold rf, ps , RS m i`1 q ą 1 ´δ `mε ‰ ě 2m ε 2 q .</formula><p>Applying Proposition 4 on Fold rf, ps " ř ePt0,1u m p e g e , we get that there exist T Ă L m i`1 and pv e q ePt0,1u m , v e P RS m i`1 , satisfying</p><formula xml:id="formula_77">• ÿ yPT φ i`1 pyq ě p1 ´δq ˇˇL m i`1 ˇˇ,</formula><p>• for all e P t0, 1u m , g e T " v e T .</p><p>For each e P t0, 1u m , let us consider p v e P F q rY s the polynomial of individual degrees less than k i`1 associated with the codeword v e P RS m i`1 . Let R be the polynomial defined by</p><formula xml:id="formula_78">RpXq :" ÿ ePt0,1u m X e</formula><p>p v e pq i pX 1 q, . . . , q i pX m qq and v be the evaluation of R on</p><formula xml:id="formula_79">L m i . Since k i`1 ď k i {2, we have deg X j R ď 1 `2 ¨pk i`1 ´1q ă k i , hence v P RS m i .</formula><p>For all y P T and x P S y , i.e. πpxq " y, vpxq " ř ePt0,1u m x e v e pπpxqq and f pxq "</p><formula xml:id="formula_80">ÿ ePt0,1u m</formula><p>x e p g e pyq " ÿ ePt0,1u m</p><p>x e g e pyq " ÿ ePt0,1u m</p><p>x e v e pyq " vpxq.</p><p>Thus v agrees with f on S T :" Ů yPT S y . Since v P RS m i , we have</p><formula xml:id="formula_82">µ φ i pf, RS m i q ě 1 |L m i | ÿ xPS T φ i pxq " 1 |L m i | ÿ yPT ÿ xPSy φ i pxq ě 1 ˇˇL m i`1 ˇˇÿ yPT φ i`1 pyq.</formula><p>Eventually, we conclude that µ φ i pf, RS m i q ě 1 ´δ by definition of T . This contradicts the hypothesis on f .</p></div>
<div><head n="7.3">IOPP for tensor product of RS codes</head><p>Given a sequence of codes pRS m i q 0ďiďr as defined in Section 7.1 and a family of folding operators for each code RS m i (see Section 7.2), the generic construction described proposed in Section 3.2 leads to a public-coin IOPP pP RS m , V RS m q for the code RS m 0 .</p><p>Notice that the last function f r is supposed to be constant. Therefore, we use the variant of the protocol described in Remark 2. Specifically, instead of sending f r during the COMMIT phase, the prover P RS m sends a single field element β P F q . The verifier V RS m does not run a membership test to C r but checks the equation β " Fold " f r´1 , p r´1 ‰ py r q. The properties of the resulting IOPP system pP RS m , V RS m q are displayed in the following theorem.</p><p>Theorem 2. Let k, m be positive integers such that k ą 1 is a power of two. Let L Ă F q as described in Section 6 such that k ă |L|. Then, the generic construction of Section 3.2 leads to public-coin IOPP system pP RS m , V RS m q for the tensor product code pRS rF q , L, ksq bm of blocklength n m with the following properties.</p><p>1. Round complexity is rpn m q ă log n.</p><p>2. Query complexity is qpn m q ă α2 m log n `1 for α repetitions of the QUERY phase.</p></div>
<div><head n="3.">Proof length is lpn</head><formula xml:id="formula_83">m q ă n m 2 m ´1 .</formula><p>4. Prover complexity is t p pn m q ă 4pm `2qn m . 5. Verifier decision complexity is t v pn m q ă 4αp2 m `mq log n.</p><p>6. Perfect completeness: If f P pRS rF q , L, ksq bm and if the oracles f 1 , . . . f r are computed by an honest prover P RS m , then V RS m outputs accept with probability 1.</p><p>7. Soundness: Assume that f : L m Ñ F q is δ-far from pRS rF q , L, ksq bm . Denote λ the relative minimum distance of pRS rF q , L, ksq bm and, for any ε P `0, 1 3 ˘, set γpλ, εq :" 1 ´p1 ´λ `εq 1{3 . Then, for any unbounded prover P ˚, the verifier V RS m outputs accept after α repetitions of the QUERY phase with probability at most 2m log n ε 2 q `p1 ´minpδ, γpε, λqq `εm log nq α .</p><p>Proof. We apply the construction of the public-coin IOPP system presented in Section 3.2 with the family of folding operators defined in Section 7.2. Completeness and soundness follow from Theorem 1. The number of round is r " log k ă log |L| by definition. For a single repetition of the query test, V RS m queries each oracle f i , i P r0 . . r ´1s, at 2 m locations. The verifier retrieves β a single time, which yields the claimed query complexity. The total proof length is</p><formula xml:id="formula_84">r ÿ i"1 |L m i | " r ÿ i"1 n m 2 mi ă n m 2 m ´1 .</formula><p>We examine prover complexity. Let f : L m i Ñ F q and p P F m q . For each y P L m i`1 , the prover evaluates the low-degree extension P f,y pXq of f Sy at p, where S y " π ´1 i ptyuq. It follows from Lemma 2 that the number of operations to evaluate Fold rf, ps on L m i`1 is 4p2 m `mq ˇˇL m i`1 ˇˇ. We deduce that the cost of honestly generating P RS m 's messages is</p><formula xml:id="formula_85">r ÿ i"1 4p2 m `mq ˇˇL m i`1 ˇˇă 4p2 m `mq n m 2 m ´1 ď 4pm `2qn m .</formula><p>We also deduce from Lemma 2 that the verifier complexity is less than α ř r i"1 4p2 m `mq.</p><p>Comparisons with the univariate case Soundness of the FRI protocol <ref type="bibr" target="#b7">[BBHR18]</ref> has been analyzed in [BBHR18, BKS18, BGKS20, BCI `20]. For a Reed-Solomon code of blocklength N , relative distance λ and alphabet F q of size linear in N , the soundness is given by <ref type="bibr" target="#b22">[BGKS20]</ref>. Specifically, for a single repetition of the QUERY phase, soundness error of the FRI protocol is at most</p><formula xml:id="formula_86">2 log N ε 2 |F q | `p1 ´minpδ, δ 0 q `ε log N q,</formula><p>where δ 0 " 1 ´p1 ´λ `εq 1{3 . Authors of <ref type="bibr" target="#b22">[BGKS20]</ref> also showed that this bound on soundness error of the FRI protocol is tight for RS codes evaluated over the entire field, and when this field has characteristic two. Subsequently, [BCI `20] improved soundness of the FRI protocol for quadraticsize fields using formal list-decoding algorithms for RS codes. We point out that the soundness error of our IOPP for tensor product of RS code is given by the exact same formula than the one shown in <ref type="bibr" target="#b22">[BGKS20]</ref> for the univariate case, albeit tensor codes have worse relative distance.</p><p>In Figure <ref type="figure">3</ref>, we present the parameters of the FRI protocol for RS codes and our IOPP for tensor product of RS codes side by side. We consider codes of blocklength N and dimension K and a single repetition of the QUERY phase. In order to achieve arbitrary constant soundness error, both protocols require to repeat the QUERY phase. This process increases query complexity and verifier running time by a multiplicative factor. However, the FRI protocol has better soundness, thus requires less repetitions.</p></div>
<div><head>Scheme</head><p>Prover Verifier Query Length Rounds RS IOPP <ref type="bibr" target="#b7">[BBHR18]</ref> ă 6N</p><formula xml:id="formula_87">ă 42 log K 2 log K ă N 3 log K Tensor RS IOPP ă p2m `4qN ă 4 `2m m `1˘l og K 2 m m log K ă N 2 m ´1 log K m</formula><p>Figure <ref type="figure">3</ref>: Comparison between the IOPP for a RS code of <ref type="bibr" target="#b7">[BBHR18]</ref> and our IOPP for a tensor product of RS code. We compare codes with the same blocklength N and same dimension K.</p></div>
<div><head n="7.4">Remarks on partial folding</head><p>In this subsection, we make some remarks (without proofs) about the possibilty of folding with respect to a single indeterminate, instead of folding along all the indeterminates at once. We call this partial folding. For simplicity, we limit ourselves to the case m " 2, and to the polynomial qpXq " X 2 . Then, instead of folding at once and reducing the length of the code by 4, it is possible to fold first along the X 1 indeterminate, reducing the length by 2, then to fold along the X 2 coordinates, reducing again the length by 2. One can also intertwine partial foldings with respect to the X 1 indeterminate and partial foldings with respect to the X 2 indeterminate, in any order. It is also possible to fold only with respect to the X 1 coordinate, and keep the X 2 coordinate intact.</p><p>Statements below are true when exchanging the roles of X 1 and X 2 . For L 1 , L 2 Ă F q , given a function f : L 1 ˆL2 Ñ F q , and p f pX 1 , X 2 q its associated low-degree extention, we can decompose it as p f 1 pX 1 , X 2 q " p g 0 pX 2 1 , X 2 q `X1 p g 1 pX 2 1 , X 2 q.</p><p>For a P F, the notation Fold X 1 rf, as : qpL 1 q ˆL2 Ñ F q will refer to the function whose low-degree extension is the polynomial p g 0 pX 1 , X 2 q `ap g 1 pX 1 , X 2 q.</p><p>Similarly, after writing p f pX 1 , X 2 q " p h 0 pX 1 , X 2 2 q `X2 p h 1 pX 1 , X 2 2 q, given b P F q , we can define Fold X 2 rf, bs : L 1 ˆqpL 2 q Ñ F q whose low-degree extension is p h 0 pX 1 , X 2 q `bp h 1 pX 1 , X 2 q. We have the following local property. Proposition 6. Let f : L 1 ˆL2 Ñ F and a P F. For any px, yq P qpL 1 q ˆL2 , it is possible to compute the value Fold X 1 rf, as px, yq with only 2 queries to f . A simple calculation shows that for f : L 1 ˆL2 Ñ F q , and p " pa, bq P F 2 , we have Fold rf, ps " Fold X 2 rFold X 1 rf, as , bs .</p><p>(15)</p><p>Thus, doing two partial foldings outputs the same word as a single two-variables folding. The number of queries for computing a local value this way is also 4.</p><p>Proposition 7. Let RS 1 be the Reed-Solomon code of support L 1 and dimension k 1 and RS 2 the Reed-Solomon codes of support L 2 and dimension k 2 . Let RS 1 1 the Reed-Solomon of support qpL 1 q and dimension k 1 {2. If f P RS 1 b RS 2 then Fold X 1 rf, as P RS 1 1 b RS 2 . We state a variant of Proposition 5 in the setting of a partial folding. For simplicity, we state the result in terms of the Hamming distance.</p><p>Proposition 8. Let f : L 1 ˆL2 Ñ F q be an arbitrary function. Let ε P `0, 1 3 ˘and δ ă 1´p1´λ`εq 1 3 . Let RS 1 be the Reed-Solomon code of support L 1 and dimension k 1 and RS 2 the Reed-Solomon codes of support L 2 and dimension k 2 . Let RS 1 1 the Reed-Solomon of support qpL 1 q and dimension k 1 {2.</p><formula xml:id="formula_88">If ∆pf, RS 1 b RS 2 q ą δ, then Pr aPFq " ∆pFold X 1 rf, as , RS 1 1 b RS 2 q ă δ ´ε‰ ă 2 ε 2 q .</formula><p>From the above observations, we could design another IOPP for the tensor product of two Reed-Solomon codes. For instance, we could replace a round with a two-variables folding by two rounds with a single-variable folding each. The above considerations give correcteness and locality. Concerning soundness, Proposition 8 applied two times leads to the same probabilities 4{pε 2 qq for distance preservation, which is exactly the same as in Proposition 5 for m " 2. So the soundness will not degrade. However, some disadvantages appear. First, the number of rounds will double, and second, instead of having a new oracle at each round of size |L 1 ˆL2 | {4, we get an oracle of size |L 1 | ˆ|L 2 | {2 followed by an oracle of size p|L 1 | ˆ|L 2 |q {4, which is three times more.</p></div>
<div><head n="7.5">Generalization to distinct individual degrees</head><p>The IOPP for m-wise tensor product of RS codes can easily be extended to a tensor product of m distinct Reed-Solomon codes</p><formula xml:id="formula_89">RS " F q , L p1q , k p1q ı b RS " F q , L p2q , k p2q ı b ¨¨¨b RS " F q , L pmq , k pmq ı</formula><p>with different degree bounds `kpjq ˘1ďjďm and supports `Lpjq ˘0ďjďm . We briefly explain how to proceed without giving details. It suffices to notice that the natural generalization of folding operators of Definition 9 for distinct degrees satisfies Definition 5 and Definition 7. Assuming each code RS " F q , L pjq , k pjq ‰ has same rate ρ and every k pjq is a power of two, one can apply the folding operations over a number of rounds r 0 " log `min j k pjq ˘. After r 0 rounds, we have reduced the initial problem to the one of testing proximity to a tensor product code of RS codes where one of the RS code has dimension one. If necessary, some rounds of interactions can be added to end up with a constant function f r by using partial folding over the remaining indeterminates, as described in Section 7.4.</p></div>
<div><head n="8">Short Reed-Muller codes</head></div>
<div><head n="8.1">Sequence of codes</head><p>Similarly to Section 7.1, we will consider two families of short Reed-Muller codes, depending on whether case 6.1 or case 6.2 holds. Let k be a power of two, k ă |L| and set r " log 2 k. We consider L 0 " L, L 1 , . . . , L r as constructed in Section 6.</p><p>Set k 0 :" k. For 0 ă i ď r, define k i`1 :" k i 2 . In particular, for all i, we have k i ă |L i |. Let us denote by SRM i the short Reed-Muller code SRM rF q , L i , m, k i s.</p><p>Starting from the code SRM 0 " SRM rF q , L, m, ks, this defines a sequence of Reed-Muller codes pSRM i q 0ďiďr . For each i, the relative distance λ i of SRM i is at least</p><formula xml:id="formula_90">1´k i ´1 |L i | , hence min i λ i ě 1´2 k 0 |L 0 | .</formula></div>
<div><head n="8.2">Folding operators</head><p>Let pSRM i q 0ďiďr be a sequence of short Reed-Muller codes defined as described in Section 8.1 (regardless we are in case 6.1 or 6.2). For each i P r0 . . r ´1s, we define a family of folding operators which will enables us to iteratively reduce the problem of proximity testing to a code SRM i to a problem of size 2 m times smaller, namely proximity testing to SRM i`1 . Note that the sequences of evaluation domains pL m i q i and degree bounds pk i q i are defined exactly the same way as in the tensor product case. However, if we design folding operators for Reed-Muller codes by following the same construction than in Definition 9, then the distance preservation property does not hold anymore. For this reason, some balancing functions are involved in the definition of folding operators for Reed-Muller codes.</p><p>Definition 10 (Balancing functions). Let i P r0 . . r ´1s. For any e P t0, 1u m , we call a balancing function any map h e : L m i`1 Ñ F q which corresponds to the evaluation of a m-variate multilinear monic monomial p h e of total degree exactly</p><formula xml:id="formula_91">Y w H peq<label>2</label></formula><p>] . We call ph e q ePt0,1u m a balancing tuple for the code SRM i`1 .</p><p>Definition 11 (Folding operator). Let i P r0, r´1s. Let ph e q ePt0,1u m be a balancing tuple for SRM i`1 and let f : L m i Ñ F q be an arbitrary function. Given pp g e q ePt0,1u m the 2 m m-variate polynomials of the decomposition of Proposition 2, denote g e the evaluation on L m i`1 of p g e . For any pp, p 1 q P `Fm q ˘2, we define the folding of f as the function Fold rf, pp, p 1 qs :</p><formula xml:id="formula_92">L m i`1 Ñ F q such that Fold " f, pp, p 1 q ‰ pyq " ÿ ePt0,1u m p e g e pyq `ÿ ePt0,1u m e‰0</formula><p>p 1 e h e pyqg e pyq.</p><p>Lemmas 8 and 9 show that this defines a folding operator for SRM i as per Definition 5.</p><p>Lemma 8 (Completeness). Let pp, p 1 q P `Fm q ˘2, and f : L m i Ñ F q P SRM i , then Fold rf, pp, p 1 qs :</p><formula xml:id="formula_94">L m i`1 Ñ F q belongs to SRM i`1 .</formula><p>Proof. Proof relies on Proposition 2. If f P SRM i , then the polynomial p f pXq associated to f has total degree at most k i ´1. Therefore, for any e P t0, 1u </p><formula xml:id="formula_95">] `Y k i ´1´w H peq 2 ] ă k i`1</formula><p>. This means Fold rf, pp, p 1 qs : L m i`1 Ñ F q corresponds to the evaluation of a polynomial in F q rXs of total degree less than k i`1 .</p><p>Lemma 9 (Locality). Let f : L m i Ñ F q be an arbitrary function and let pp, p 1 q P `Fm q ˘2. Given y P L m i`1 , the value Fold rf, pp, p 1 qs pyq can be computed with exactly 2 m queries to f .</p><p>Proof. The proof follows from the one of Lemma 7. For any y P L m i`1 , the vector pg e pyqq ePt0,1u m corresponds to the vector of coefficients of the low-degree extension of the function f Sy .</p><p>Let us now show that the folding operator of Definition 11 satisfies distance preservation (Definition 7).</p><p>Proposition 9 (Distance preservation). Denote λ i`1 the minimum relative distance of SRM i`1 . Let f : L m i Ñ F q be an arbitrary function. Let ε P `0, 2 3 ˘and δ ă min ˆ1 ´p1 ´λi`1 `εq</p><formula xml:id="formula_96">1 3 , 1 2 pλ i`1 `m ε 2 q ˙.</formula><p>Let φ i : L m i Ñ r0, 1s and φ i`1 : L m i`1 Ñ r0, 1s be weight functions such that</p><formula xml:id="formula_97">@y P L m i`1 , φ i`1 pyq ď 1 2 m ÿ xPSy φ i pxq, if f : L m i Ñ F q has weighted agreement µ φ i pf, SRM i q ą 1 ´δ, then Pr p,p 1 PF m q " µ φ i`1 `Fold " f, pp, p 1 q ‰ , SRM i`1 ˘ą 1 ´δ `mε ‰ ă 16m ε 2 q .</formula><p>Proof. Let f : L m i Ñ F q be such that µ φ i pf, SRM i q ą 1 ´δ, and pp g e q ePt0,1u m the 2 m m-variate polynomials appearing in the decomposition of p f in Proposition 2. For any p P F m q , denote u p the function u p " ř ePt0,1u m p e g e , and for any e P t0, 1u m z t0u, define u e " h e g e . One can rewrite Fold rf, pp, p 1 qs as follows:</p><p>Fold " f, pp, p 1 q ‰ " u p `ÿ ePt0,1u m e‰0 p 1 e u e .</p><p>We proceed by contraposition, assuming that</p><formula xml:id="formula_98">Pr p,p 1 PF m q " µ φ i`1 `Fold " f, pp, p 1 q ‰ , SRM i`1 ˘ą 1 ´δ `mε ‰ ě 16m ε 2 q ,</formula><p>or, in other words,</p><formula xml:id="formula_99">Pr pPF m q " Pr p 1 PF m q " µ φ i`1 `Fold " f, pp, p 1 q ‰ , SRM i`1 ˘ą 1 ´δ `mε ‰ ě 8m ε 2 q  ě 8m ε 2 q . Let A :" " p P F m q | Pr p 1 PF m q " µ φ i`1 `Fold " f, pp, p 1 q ‰ , SRM i`1 ˘ą 1 ´δ `mε ‰ ě 8m ε 2 q * .</formula><p>Proposition 4 implies that, for any p P A, there exist T p Ă L m i`1 and pw p,e q ePt0,1u m with w p,e P SRM i`1 such that</p><formula xml:id="formula_100">• ÿ yPTp φ i`1 pyq ě p1 ´δ `m ε 2 q ˇˇL m i`1 ˇˇ,</formula><p>• w p,0 Tp " u p Tp ,</p><p>• for each e P t0, 1u m z t0u, w p,e Tp " u e Tp .</p><p>Thus, for all p P A,</p><formula xml:id="formula_101">µ φ i`1 ¨ÿ ePt0,1u m p e g e , SRM i`1 ‚ě 1 ˇˇL m i`1 ˇˇÿ yPTp φ i`1 pyq ě 1 ´δ `m ε 2 .</formula><p>Since |A| ą 2m ε 2 q m´1 , we have</p><formula xml:id="formula_102">Pr pPF m q » -µ φ i`1 ¨ÿ ePt0,1u m p e g e , SRM i`1 ‚ą 1 ´δ `m ε 2 fi fl ě 8m ε 2 q .</formula><p>Again, by Proposition 4, we obtain T Ă L m i`1 and pv e q ePt0,1u m with v e P SRM i`1 such that</p><formula xml:id="formula_103">• ÿ yPT φ i`1 pyq ě p1 ´δq ˇˇL m i`1 ˇˇ,</formula><p>• for each e P t0, 1u m , v e T " g e T .</p><p>Fix p P A. For any e P t0, 1u m , e ‰ 0, we have w p,e TpXT " u e TpXT " ph e g e q TpXT " ph e v e q TpXT .</p><p>Besides, the intersection of T p and T satisfies</p><formula xml:id="formula_104">|T p X T | " |T p | `|T | ´|T p Y T | ě ÿ yPTp φ i`1 pyq `ÿ yPT φ i`1 pyq ´ˇL m i`1 ˇě ´1 ´2δ `m ε 2 ¯ˇL m i`1 ˇˇ, ě p1 ´λi`1 q ˇˇL m i`1 ˇˇ.</formula><p>Since λ i`1 is the minimum relative distance of SRM i`1 , we deduce that w p,e " h e v e for every e P t0, 1u m z t0u.</p><p>For any e P t0, 1u m , consider polynomials p v e , p w e,p P F q rXs of total degrees at most k i`1 , such that for all x P L m i`1 , p v e pxq " v e pxq and p w e,p pxq " w e,p pxq. Hence, for all x P L m i`1 , p w e,p pxq " p v e pxq p h e pxq, which means that p w e,p ´p v e p h e " 0 mod pZ i`1 pX 1 q, . . . , Z i`1 pX m qq ,</p><p>where Z i`1 pXq " x e v e pyq " vpxq.</p><formula xml:id="formula_106">ś aPL i`1 pX ´aq has degree |L i`1 |. Since k i`1 ă |L i`1 |,</formula><p>Hence, v agrees with the function f on the set S T :" Ů yPT S y . Since v P SRM i , we have</p><formula xml:id="formula_107">µ φ i pf, SRM i q ě 1 |L m i | ÿ xPS T φ i pxq " 1 |L m i | ÿ yPT ÿ xPSy φ i pxq ě 1 ˇˇL m i`1 ˇˇÿ yPT φ i`1 pyq.</formula><p>Eventually, we conclude that µ φ i pf, SRM i q ě 1 ´δ by definition of T .</p></div>
<div><head n="8.3">IOPP for short Reed-Muller codes</head><p>Given a sequence of codes pSRM i q 0ďiďr as defined in Section 8.1 and a family of folding operators for each code SRM i (see Section 8.2), the generic construction described proposed in Section 3.2 leads to a public-coin IOPP pP RM , V RM q for the code SRM 0 . As in Section 7, the last function f r is supposed to be constant. Therefore, we use the variant of the protocol described in Remark 2. Specifically, instead of sending f r during the COMMIT phase, the prover P RM sends a single field element β P F q . The verifier V RM does not run a membership test to C r but checks the equation β " Fold " f r´1 , p r´1 ‰ py r q. The properties of the resulting IOPP system pP RM , P RM q are displayed in the following theorem.</p><p>Theorem 3. Let k, m be positive integers. Assume k is a power of two. Let L Ă F q as described in Section 6 such that k ă |L|. There exists a public-coin IOPP system pP RM , V RM q testing proximity of a function f : L m Ñ F q to the short Reed-Muller code SRM rF q , L, m, ks with the following properties:</p><p>1. Round complexity is rpn m q ă log n.</p><p>2. Query complexity is qpn m q ă αp2 m log n `1q for a QUERY phase with repetition parameter α.</p><p>3. Proof length is lpn m q ă n m p2 m ´1q .</p><p>4. Prover complexity is t p pn m q ă `5 2 m `14 ˘nm .</p><p>5. Verifier decision complexity is t v pn m q ă α2 m `5 4 m `7˘l og n.</p><p>6. Perfect completeness: If f P SRM rF q , L, m, ks and if the oracles f 1 , . . . f r are computed by an honest prover, then V RM outputs accept with probability 1.</p><p>7. Soundness: Assume that f : L m Ñ F q is δ-far from SRM rF q , L, m, ks. Denote λ " 1 2 k |L| . For any ε P p0, 2 3 q, set γpε, λq :" min `1 ´p1 ´λ `εq 1{3 , 1 2 pλ `m ε 2 q ˘. Then, for any unbounded prover P ˚, the verifier V outputs accept after α repetitions of the QUERY phase with probability at most r 16m ε 2 q `p1 ´minpδ, γpε, λqq `rmεq α .</p><p>Proof. We apply the construction of the public-coin IOPP system presented in Section 3.2 with the family of folding operators define in Section 8.2. Completeness and soundness follow from Theorem 1.The number of round is r " log k ă log |L|. Query complexity and proof length are the same than in Theorem 2. For soundness, recall that min i λ i ě 1 ´2 k |L| where λ i is the relative distance of SRM i .</p><p>Let f : L m i Ñ F q be an arbitrary function and let pp, p 1 q P `Fm q ˘2. We analyze prover complexity by first computing the cost of evaluating Fold rf, pp, p 1 qs on L m i`1 . The prover P RM can compute the vectors pp e q ePt0,1u m and `p1 e ˘ePt0,1u m in less than 2 ¨2m multiplications. Given y P L m i`1 , we look at the cost of computing Fold rf, pp, p 1 qs pyq (see Equation ( <ref type="formula" target="#formula_93">16</ref>)). Recalling Definition 10, computing the values p h e pyq for all e P t0, 1u m takes at most m2 m´2 operations. As shown in proof of Lemma 7, the vector pg e pyqq corresponds to the coefficients of the multilinear low-degree extension of f Sy . By Lemma 1, this interpolation can be performed with m2 m arithmetic operations. Prover then computes the first sum of Equation ( <ref type="formula" target="#formula_93">16</ref>) using 2 m multiplications and 2 m ´1 additions. Similarly, the second sum can be computed in less than 3 ¨2m arithmetic operations.</p><p>Overall, for any function f : L m i Ñ F q and p, p 1 P F m q , the prover can evaluate Fold rf, pp, p 1 qs : L m i`1 Ñ F q in less than From the discussion about prover complexity, we also get that the number of operations made by V RM for a single consistency test is less than 2 ¨2m `5 ¨2m `1 `m 4 ˘. Thus, verifier complexity is less than αr2 m `5 4 m `7˘.</p><formula xml:id="formula_108">2</formula><p>Comparisons with the univariate case When we compared the FRI protocol with our IOPP for the tensor product of RS codes in Section 7.3, we argued that soundness is affected by the worse relative distance of tensor codes. In constrast, a short Reed-Muller code SRM rF q , L, m, ks has relative distance which is at least the one of a Reed-Solomon code RS rF q , L, ks. However, soundness of our IOPP for Reed-Muller code is worse than soundness of the FRI protocol for linear-size field <ref type="bibr" target="#b22">[BGKS20]</ref> due to the more complex expression of the folding operators.</p><p>In Figure <ref type="figure" target="#fig_1">4</ref>, we present the parameters of the FRI protocol for RS codes and our IOPP for Reed-Muller codes side by side for codes of blocklength N and a single repetition of the QUERY phase. The use of balancing functions in Definition 11 induces some extra costs compared to the IOPP for product codes. </p></div>
<div><head n="9">Conclusion</head><p>In this paper, tensor product of Reed-Solomon codes and Reed-Muller codes over fields with smooth additive subgroups or smooth multiplicative subgroups have been shown to admit quite efficient interactive oracle proofs of proximity (IOPPs). These results can be interpreted as multivariate low degree tests, i.e. given a function f : L m Ñ F q , a verifier distinguishes whether f corresponds to the evaluation of a degree-d polynomial or is far in relative Hamming distance from any evaluations of low-degree polynomials, either using the notion of individual degrees or total degree. For a constant dimension m, our constructions have linear oracle proof length and prover complexity, logarithmic query and verifier complexities. In the case of tensor product of Reed-Solomon codes, our construction can be generalized to distinct degree bounds and different evaluation domain.</p><p>Many constructions of succinct non-interactive arguments (SNARG) rely on univariate polynomials for arithmetization. One of the reason is that there exists an efficient IOPP for Reed-Solomon codes <ref type="bibr" target="#b7">[BBHR18]</ref>. Proposing highly-efficient IOPPs for multivariate polynomial codes might open up a range of different arithmetization techniques for designing explicit constructions of proof systems.</p><p>Regarding total degree tests, we think that allowing support L m with L much smaller than F q gives more flexibility in the design of proof systems. However, we had to require d to be less than |L| to ensure completeness and soundness. A natural question is whether an IOPP for multivariate polynomial codes with total degree d ą |L| can be designed.</p><p>We also note that our proximity parameter is not as good as the one from [BCI `20], where a formal Guruswami-Sudan <ref type="bibr" target="#b35">[GS01]</ref> decoding algorithm is analyzed for a worst-case to averagecase reduction. Obtaining such a large proximity parameter would involve an analysis of algebraic decoding algorithms of multivariate codes over the field of rational functions.</p></div><figure xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: IOPP pP, Vq for a code C based on folding operators</figDesc></figure>
<figure xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>SchemeProver Verifier Query Length Rounds RS IOPP<ref type="bibr" target="#b7">[BBHR18]</ref> ă 6Nă 42 log N ă 2 log N ă N {3 ă log N RM IOPP ă p2m `7qN 2 m `5 4 `7 m ˘log N ă 2 m m log N ă N 2 m ´1 ă log N mFigure 4: Comparison between the IOPP for a RS code of [BBHR18] and our IOPPs for tensor of RS codes and RM codes. Blocklength of the codes is denoted by N and m is the number of variables of the multivariate codes.</figDesc></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>we have that for any j, deg X j p v e ď |L i`1 | ´2. Moreover, deg X i p h e ď 1, thus the above equality is true without the modulo: pq i pX 1 q . . . , q i pX m qq has total degree deg R ă k i . Thus the evaluation of R on L m i is a codeword v P SRM i . For any y P T and x P S y , we have</figDesc><table><row><cell>p w e,p ´p v e p h e " 0. ÿ ePt0,1u m X e p v e f pxq " ÿ x e g e pyq " ÿ v RpXq :" Therefore, deg p ePt0,1u m ePt0,1u m</cell><cell>(18)</cell></row></table><note><p><p>e ă k i`1 ´Y w H peq 2 ]</p>. For all e P t0, 1u m , we have deg X e p v e pq i pX 1 q . . . , q i pX m qq ď w H peq `2 ˆki`1 ´1 ´wH peq 2 ˙ă k i , hence the polynomial R P F q rXs defined by</p></note></figure>
<figure type="table" xml:id="tab_3"><head /><label /><figDesc>We deduce that the cost of honestly generating P RS m 's messages is</figDesc><table><row><cell cols="4">¨2m `5 ¨2m ´1</cell><cell>`m 4</cell><cell cols="4">¯ˇL m i`1 ˇˇď 2 m</cell><cell>ˆ5 4</cell><cell>m</cell><cell>i`1 `7˙ˇˇL m</cell><cell>ˇǎrithmetic</cell></row><row><cell>operations. r´1 ÿ i"0 2 m ˆ5 4</cell><cell>m</cell><cell>`7˙ˇˇL</cell><cell cols="3">m i`1 ˇˇă 2 m</cell><cell>ˆ5 4</cell><cell>m</cell><cell cols="2">`7˙n m 2 m ´1 ď</cell><cell>ˆ5 2</cell><cell>m `14 ˙nm .</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p><rs type="person">Sarah Bordage</rs> benefits from the support of the <rs type="programName">Chair "Blockchain &amp; B2B Platforms</rs>", led by <rs type="funder">l'X -École polytechnique</rs> and the <rs type="funder">Fondation de l'École polytechnique</rs>, sponsored by <rs type="funder">Capgemini</rs>, <rs type="funder">Nomadi-cLabs</rs>, <rs type="funder">Caisse des dépôts</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_pju3VSH">
					<orgName type="program" subtype="full">Chair "Blockchain &amp; B2B Platforms</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div><head>A Proof of Lemma 5</head><p>The beginning of the proof of Lemma 5 is the same as the one of [BGKS20, Lemma 3.2]. We rewrite the proof entirely since we need to rely notations introduced along the analysis.</p><p>Proof of Lemma 5. First, observe that if the function φ : D Ñ r0, 1s is constant equal to 1, then µ φ pu, Cq " 1 ´∆pu, vq. Therefore, for any weight function φ : D Ñ r0, 1s and any u, v P F D q , µ φ pu, vq ď 1 ´∆pu, vq. Consequently, µ φ pu, Cq ď 1 ´∆pu, Cq. Thus, the set tz P F q | µ φ pu 0 `zu 1 , Cq ą 1 ´δu is contained in A :" tz P F q | ∆pu 0 `zu 1 , Cq ă δu and the hypothesis implies |A| ě 2 ε 2 . Now, the proof follows the one of [BGKS20, Lemma 3.2].</p><p>For each z P F q , denote u z " u 0 `zu 1 and let v z P C be a codeword such that ∆pu z , Cq " ∆pu z , v z q. Let T z :" tx P D | u z pxq " v z pxqu be the agreement set of u z and v z .</p><p>For z 0 , z 1 , z 2 , picked uniformly and independently in A and y picked uniformly from D, we have</p><p>From this, one obtains Pr</p><p>The probability of z 0 , z 1 , z 2 being all distinct is at least 1 ´3 |A| , which is greater than 1 ´ε 2 since |A| ą 6 ε . Thus, we get</p><p>Consequently, there are distinct z 1 and z 2 such that</p><p>Fix a z 0 such that |T z 0 X T z 1 X T z 2 | ě p1 ´δq |D|, and let S " T z 0 X T z 1 X T z 2 . We have that u z 0 , u z 1 , u z 2 all lie on the line l " tu 0 `zu 1 : z P F q u Ă F D q . As a consequence, when restricted to S, we have that u z 0 |S , u z 1 |S , u z 2 |S all lie on the line l |S " u 0|S `zu 0|S : z P F q ( Ă F S q . By definition of S, T z 0 , T z 1 and T z 2 , we also have that v z 0 |S , v z 1 |S , v z 2 |S lie on the line l |S . Since S is an information set of C, we can linearly reencode</p><p>and we observe that v z 0 , v z 1 and v z 2 all lie on a same line. Thus, there are v 0 , v 1 P F D q such that this line is defined by tv 0 `zv 1 ; z P F q u Ă F D q . There are ε 2 -fraction of the z 0 P A such that v z 0 belongs to this line. Notice that for such z 0 , v z 0 " v 0 `z0 v 1 .</p><p>Let A 1 Ă A be the set of the z's such that v z (the word closest to u z ) can be written v z " v 0 `zv 1 . Then, we have |A 1 | ě ε 2 |A| ě 1 ε and for all z P A 1 , µ φ pu 0 `zu 1 , v 0 `zv 1 q ą 1 ´δ. Therefore,</p><p>Let us consider T :" tx P D | u 0 pxq " v 0 pxq and u 1 pxq " v 1 pxqu. Given x P DzT , there is at most one element z P F q such that u 0 pxq `zu 1 pxq " v 0 pxq `zv 1 pxq. Thus, we conclude that</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Ligero: Lightweight sublinear arguments without a trusted setup</title>
		<author>
			<persName><forename type="first">Scott</forename><surname>Ames</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carmit</forename><surname>Hazay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muthuramakrishnan</forename><surname>Venkitasubramaniam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS 2017</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bhavani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Thuraisingham</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tal</forename><surname>Evans</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dongyan</forename><surname>Malkin</surname></persName>
		</editor>
		<editor>
			<persName><surname>Xu</surname></persName>
		</editor>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS 2017<address><addrLine>Dallas, TX, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017-11-03">October 30 -November 03, 2017. 2017</date>
			<biblScope unit="page" from="2087" to="2104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title />
		<author>
			<persName><surname>Akk</surname></persName>
		</author>
		<imprint />
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Testing low-degree polynomials over GF(2)</title>
		<author>
			<persName><forename type="first">Tali</forename><surname>Noga Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Krivelevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dana</forename><surname>Litsyn</surname></persName>
		</author>
		<author>
			<persName><surname>Ron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximation, Randomization, and Combinatorial Optimization: Algorithms and Techniques</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Sanjeev</forename><surname>Arora</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Klaus</forename><surname>Jansen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>José</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Amit</forename><surname>Rolim</surname></persName>
		</editor>
		<editor>
			<persName><surname>Sahai</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2764</biblScope>
			<biblScope unit="page" from="188" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title />
		<author>
			<persName><surname>Akk</surname></persName>
		</author>
		<imprint />
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Testing reed-muller codes</title>
		<author>
			<persName><forename type="first">Tali</forename><surname>Noga Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Krivelevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dana</forename><surname>Litsyn</surname></persName>
		</author>
		<author>
			<persName><surname>Ron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="4032" to="4039" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Proof verification and the hardness of approximation problems</title>
		<author>
			<persName><forename type="first">Sanjeev</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Szegedy</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="501" to="555" />
		</imprint>
	</monogr>
	<note>extended version of FOCS'92</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Improved low-degree testing and its applications</title>
		<author>
			<persName><forename type="first">Sanjeev</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorica</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="365" to="426" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast reed-solomon interactive oracle proofs of proximity</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iddo</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yinon</forename><surname>Horesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Riabzev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">45th International Colloquium on Automata, Languages, and Programming, ICALP 2018</title>
		<meeting><address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">July 9-13, 2018. 2018</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scalable zero knowledge with no trusted setup</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iddo</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yinon</forename><surname>Horesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Riabzev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2019 -39th Annual International Cryptology Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Alexandra</forename><surname>Boldyreva</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Daniele</forename><surname>Micciancio</surname></persName>
		</editor>
		<meeting><address><addrLine>Santa Barbara, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019">August 18-22, 2019. 2019</date>
			<biblScope unit="volume">11694</biblScope>
			<biblScope unit="page" from="701" to="732" />
		</imprint>
	</monogr>
	<note>Proceedings, Part III</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title />
		<author>
			<persName><surname>Bcg</surname></persName>
		</author>
		<imprint />
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Interactive oracle proofs with constant rate and query complexity</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Gabizon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Riabzev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Spooner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">44th International Colloquium on Automata, Languages, and Programming, ICALP 2017</title>
		<meeting><address><addrLine>Warsaw, Poland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">July 10-14, 2017. 2017</date>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="1" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Linear-time arguments with sublinear verification from tensor codes</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bootle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Groth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography -18th International Conference, TCC 2020</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Rafael</forename><surname>Pass</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Krzysztof</forename><surname>Pietrzak</surname></persName>
		</editor>
		<meeting><address><addrLine>Durham, NC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020">November 16-19, 2020. 2020</date>
			<biblScope unit="volume">12551</biblScope>
			<biblScope unit="page" from="19" to="46" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the concrete efficiency of probabilistically-checkable proofs</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Forty-Fifth Annual ACM Symposium on Theory of Computing, STOC '13</title>
		<meeting>the Forty-Fifth Annual ACM Symposium on Theory of Computing, STOC '13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="585" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Proximity gaps for reed-solomon codes</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Carmon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swastik</forename><surname>Kopparty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shubhangi</forename><surname>Saraf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">61st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2020</title>
		<meeting><address><addrLine>Durham, NC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">November 16-19, 2020. 2020</date>
			<biblScope unit="page" from="900" to="909" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title />
		<author>
			<persName><surname>Bcr</surname></persName>
		</author>
		<imprint />
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Aurora: Transparent succinct arguments for R1CS</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Riabzev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Spooner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madars</forename><surname>Virza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">P</forename><surname>Ward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2019 -38th Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Vincent</forename><surname>Rijmen</surname></persName>
		</editor>
		<meeting><address><addrLine>Darmstadt, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019">May 19-23, 2019. 2019</date>
			<biblScope unit="volume">11476</biblScope>
			<biblScope unit="page" from="103" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interactive oracle proofs</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Spooner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography -14th International Conference, TCC 2016-B</title>
		<meeting><address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-11-03">October 31 -November 3, 2016. 2016</date>
			<biblScope unit="page" from="31" to="60" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Cube vs. cube low degree test</title>
		<author>
			<persName><forename type="first">Amey</forename><surname>Bhangale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irit</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Inbal</forename><surname>Livni Navon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th Innovations in Theoretical Computer Science Conference, ITCS 2017</title>
		<editor>
			<persName><forename type="first">Christos</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</editor>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2017">January 9-11, 2017. 2017</date>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="1" to="40" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Non-deterministic exponential time has two-prover interactive protocols</title>
		<author>
			<persName><forename type="first">László</forename><surname>Babai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lance</forename><surname>Fortnow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>St. Louis, Missouri, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1990">October 22-24, 1990. 1990</date>
			<biblScope unit="volume">I</biblScope>
			<biblScope unit="page" from="16" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Checking computations in polylogarithmic time</title>
		<author>
			<persName><forename type="first">László</forename><surname>Babai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lance</forename><surname>Fortnow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 23rd Annual ACM Symposium on Theory of Computing<address><addrLine>New Orleans, Louisiana, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991">May 5-8, 1991. 1991</date>
			<biblScope unit="page" from="21" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title />
		<author>
			<persName><surname>Bgh</surname></persName>
		</author>
		<imprint />
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Robust PCPs of proximity, shorter PCPs and applications to coding</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prahladh</forename><surname>Harsha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Salil</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">László</forename><surname>Babai</surname></persName>
		</editor>
		<meeting>the 36th Annual ACM Symposium on Theory of Computing<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">June 13-16, 2004. 2004</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">DEEP-FRI: sampling outside the box improves soundness</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lior</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swastik</forename><surname>Kopparty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shubhangi</forename><surname>Saraf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Innovations in Theoretical Computer Science Conference, ITCS 2020</title>
		<meeting><address><addrLine>Seattle, Washington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">January 12-14, 2020. 2020</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Worst-case to average case reductions for the distance to a code</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swastik</forename><surname>Kopparty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shubhangi</forename><surname>Saraf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">33rd Computational Complexity Conference, CCC 2018</title>
		<meeting><address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">June 22-24, 2018. 2018</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Interactive oracle proofs of proximity to algebraic geometry codes</title>
		<author>
			<persName><forename type="first">Sarah</forename><surname>Bordage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jade</forename><surname>Nardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electron. Colloquium Comput. Complex</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page">165</biblScope>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Robust locally testable codes and products of codes</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Random Struct. Algorithms</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="387" to="402" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Short PCPs with polylog query complexity</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="551" to="607" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Randomness-efficient low degree tests and short PCPs via epsilon-biased sets</title>
		<author>
			<persName><forename type="first">Eli</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Salil</forename><surname>Vadhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirty-Fifth Annual ACM Symposium on Theory of Computing, STOC '03</title>
		<meeting>the Thirty-Fifth Annual ACM Symposium on Theory of Computing, STOC '03<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="612" to="621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On axis-parallel tests for tensor product codes</title>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Manohar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><surname>Shinkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques, APPROX/RANDOM</title>
		<editor>
			<persName><forename type="first">Klaus</forename><surname>Jansen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>José</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Rolim</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Santosh</forename><forename type="middle">S</forename><surname>Williamson</surname></persName>
		</editor>
		<editor>
			<persName><surname>Vempala</surname></persName>
		</editor>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2017-08-16">2017. August 16-18, 2017. 2017</date>
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="page" from="1" to="39" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Assignment testers: Towards a combinatorial proof of the pcp-theorem</title>
		<author>
			<persName><forename type="first">Irit</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omer</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">45th Symposium on Foundations of Computer Science (FOCS 2004)</title>
		<meeting><address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004-10">October 2004. 2004</date>
			<biblScope unit="page" from="155" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title />
		<author>
			<persName><surname>Fgl</surname></persName>
		</author>
		<imprint />
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Interactive proofs and the hardness of approximating cliques</title>
		<author>
			<persName><forename type="first">Uriel</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">László</forename><surname>Lovász</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shmuel</forename><surname>Safra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="268" to="292" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Low-degree tests</title>
		<author>
			<persName><forename type="first">Katalin</forename><surname>Friedl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zsolt</forename><surname>Hátsági</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA '94</title>
		<meeting>the Fifth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA '94<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>Society for Industrial and Applied Mathematics</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="57" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title />
		<author>
			<persName><surname>Glr `</surname></persName>
		</author>
		<imprint />
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Self-testing/correcting for polynomials and for approximate functions</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Gemmell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronitt</forename><surname>Rubinfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">Cris</forename><surname>Koutsougeras</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Scott</forename><surname>Vitter</surname></persName>
		</editor>
		<meeting>the 23rd Annual ACM Symposium on Theory of Computing<address><addrLine>New Orleans, Louisiana, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1991">May 5-8, 1991. 1991</date>
			<biblScope unit="page" from="32" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On representations of algebraic-geometry codes</title>
		<author>
			<persName><forename type="first">Venkatesan</forename><surname>Guruswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1610" to="1613" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Locally testable codes and pcps of almost-linear length</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">43rd Symposium on Foundations of Computer Science (FOCS 2002)</title>
		<meeting><address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002-11">November 2002. 2002</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Testing lowdegree polynomials over prime fields</title>
		<author>
			<persName><forename type="first">S</forename><surname>Charanjit</surname></persName>
		</author>
		<author>
			<persName><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Anindya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atri</forename><surname>Patthak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Rudra</surname></persName>
		</author>
		<author>
			<persName><surname>Zuckerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">45th Symposium on Foundations of Computer Science (FOCS 2004)</title>
		<meeting><address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004-10">October 2004. 2004</date>
			<biblScope unit="page" from="423" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Redshift: Transparent snarks from list polynomial commitment iops</title>
		<author>
			<persName><forename type="first">Assimakis</forename><surname>Kattis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantin</forename><surname>Panarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Vlasov</surname></persName>
		</author>
		<idno>Report 2019/1400</idno>
		<ptr target="https://ia.cr/2019/1400" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Testing polynomials over general fields</title>
		<author>
			<persName><forename type="first">Tali</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dana</forename><surname>Ron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">45th Symposium on Foundations of Computer Science (FOCS 2004)</title>
		<meeting><address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004-10">October 2004. 2004</date>
			<biblScope unit="page" from="413" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Interactive PCP</title>
		<author>
			<persName><forename type="first">Yael</forename><surname>Tauman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kalai</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ran</forename><surname>Raz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, Part II -Track B: Logic, Semantics, and Theory of Programming &amp; Track C: Security and Cryptography Foundations</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Luca</forename><surname>Aceto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Leslie</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ann</forename><surname>Goldberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Magnús</forename><forename type="middle">M</forename><surname>Halldórsson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Anna</forename><surname>Ingólfsdóttir</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Igor</forename><surname>Walukiewicz</surname></persName>
		</editor>
		<meeting>Part II -Track B: Logic, Semantics, and Theory of Programming &amp; Track C: Security and Cryptography Foundations<address><addrLine>Reykjavik, Iceland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">July 7-11, 2008. 2008</date>
			<biblScope unit="volume">5126</biblScope>
			<biblScope unit="page" from="536" to="547" />
		</imprint>
	</monogr>
	<note>Automata, Languages and Programming, 35th International Colloquium, ICALP 2008</note>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Finite Fields</title>
		<author>
			<persName><forename type="first">Rudolf</forename><surname>Lidl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harald</forename><surname>Niederreiter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Short pcpps verifiable in polylogarithmic time with o(1) queries</title>
		<author>
			<persName><forename type="first">Thilo</forename><surname>Mie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="313" to="338" />
			<date type="published" when="2009-08">August 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Sub-constant error low degree test of almost-linear size</title>
		<author>
			<persName><forename type="first">Dana</forename><surname>Moshkovitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ran</forename><surname>Raz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="140" to="180" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Simple multivariate polynomial multiplication</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Victor</surname></persName>
		</author>
		<author>
			<persName><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symb. Comput</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="183" to="186" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Nearly-linear size holographic proofs</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Polishchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">A</forename><surname>Spielman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">Frank</forename><surname>Thomson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Leighton</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Michael</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</editor>
		<meeting>the Twenty-Sixth Annual ACM Symposium on Theory of Computing<address><addrLine>Montréal, Québec, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994-05-25">23-25 May 1994. 1994</date>
			<biblScope unit="page" from="194" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Local proofs approaching the witness length</title>
		<author>
			<persName><forename type="first">Noga</forename><surname>Ron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-Zewi</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ron</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">61st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2020</title>
		<meeting><address><addrLine>Durham, NC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">November 16-19, 2020. 2020</date>
			<biblScope unit="page" from="846" to="857" />
		</imprint>
	</monogr>
	<note>extended abstract</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Constant-round interactive proofs for delegating computation</title>
		<author>
			<persName><forename type="first">Omer</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">N</forename><surname>Rothblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ron</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2016</title>
		<editor>
			<persName><forename type="first">Daniel</forename><surname>Wichs</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yishay</forename><surname>Mansour</surname></persName>
		</editor>
		<meeting>the 48th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2016<address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">June 18-21, 2016. 2016</date>
			<biblScope unit="page" from="49" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Self-testing polynomial functions efficiently and over rational domains</title>
		<author>
			<persName><forename type="first">Ronitt</forename><surname>Rubinfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Annual ACM/SIGACT-SIAM Symposium on Discrete Algorithms</title>
		<editor>
			<persName><forename type="first">Greg</forename><forename type="middle">N</forename><surname>Frederickson</surname></persName>
		</editor>
		<meeting>the Third Annual ACM/SIGACT-SIAM Symposium on Discrete Algorithms<address><addrLine>Orlando, Florida, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM/SIAM</publisher>
			<date type="published" when="1992-01-29">27-29 January 1992. 1992</date>
			<biblScope unit="page" from="23" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Robust characterizations of polynomials with applications to program testing</title>
		<author>
			<persName><forename type="first">Ronitt</forename><surname>Rubinfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madhu</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="252" to="271" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A sub-constant error-probability low-degree test, and a subconstant error-probability PCP characterization of NP</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Raz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shmuel</forename><surname>Safra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Ninth Annual ACM Symposium on the Theory of Computing</title>
		<editor>
			<persName><forename type="first">Frank</forename><surname>Thomson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Leighton</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Peter</forename><forename type="middle">W</forename><surname>Shor</surname></persName>
		</editor>
		<meeting>the Twenty-Ninth Annual ACM Symposium on the Theory of Computing<address><addrLine>El Paso, Texas, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997">May 4-6, 1997. 1997</date>
			<biblScope unit="page" from="475" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Interactive proofs of proximity: delegating computation in sublinear time</title>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">N</forename><surname>Rothblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Salil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Vadhan</surname></persName>
		</author>
		<author>
			<persName><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Theory of Computing Conference, STOC'13</title>
		<editor>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tim</forename><surname>Roughgarden</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Joan</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Palo Alto, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">June 1-4, 2013. 2013</date>
			<biblScope unit="page" from="793" to="802" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Fast probabilistic algorithms for verification of polynomial identities</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName><surname>Schwartz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="701" to="717" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">ethstark documentation</title>
		<author>
			<persName><surname>Starkware</surname></persName>
		</author>
		<idno>Report 2021/582</idno>
		<ptr target="https://ia.cr/2021/582" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A combination of testability and decodability by tensor products</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Viderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Random Struct. Algorithms</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="572" to="598" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A hybrid architecture for interactive verifiable computation</title>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">V</forename><surname>Srinath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">J</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE Symposium on Security and Privacy, SP 2013</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2013">May 19-22, 2013. 2013</date>
			<biblScope unit="page" from="223" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Probabilistic algorithms for sparse polynomials</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Zippel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symbolic and Algebraic Computation, EUROSAM '79, An International Symposiumon Symbolic and Algebraic Computation</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Edward</forename><forename type="middle">W</forename><surname>Ng</surname></persName>
		</editor>
		<meeting><address><addrLine>Marseille, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1979-06">June 1979. 1979</date>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page" from="216" to="226" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>