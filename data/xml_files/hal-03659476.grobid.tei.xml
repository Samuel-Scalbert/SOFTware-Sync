<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient sampling in spectrahedra and volume approximation</title>
				<funder ref="#_jDwEAJf">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder>
					<orgName type="full">PGMO grant ALMA</orgName>
				</funder>
				<funder>
					<orgName type="full">PHC GRAPE</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Apostolos</forename><surname>Chalkis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">ATHENA Research Center</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Informatics &amp; Telecommunications National</orgName>
								<orgName type="institution">Kapodistrian University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ioannis</forename><forename type="middle">Z</forename><surname>Emiris</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">ATHENA Research Center</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Informatics &amp; Telecommunications National</orgName>
								<orgName type="institution">Kapodistrian University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vissarion</forename><surname>Fisikopoulos</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Informatics &amp; Telecommunications National</orgName>
								<orgName type="institution">Kapodistrian University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Panagiotis</forename><surname>Repouskos</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Informatics &amp; Telecommunications National</orgName>
								<orgName type="institution">Kapodistrian University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Elias</forename><surname>Tsigaridas</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">IMJ-PRG</orgName>
								<orgName type="institution">Inria Paris</orgName>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Sorbonne Université and Paris Université d GeomScale Org</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient sampling in spectrahedra and volume approximation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">687D99A60721610E0F42EBCEC7BA6490</idno>
					<note type="submission">Preprint submitted to ... May 9, 2022</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-03-07T09:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>spectahedron</term>
					<term>semidefinite-programming</term>
					<term>sampling</term>
					<term>random walk</term>
					<term>Monter Carlo</term>
					<term>polynomial eigenvalue problem</term>
					<term>volume approximation</term>
					<term>optimization</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present algorithmic, complexity, and implementation results on the problem of sampling points from a spectrahedron, that is, the feasible region of a semidefinite program.</p><p>Our main tool is geometric random walks. We analyze the arithmetic and bit complexity of certain primitive geometric operations that are based on the algebraic properties of spectrahedra and the polynomial eigenvalue problem. This study leads to the implementation of a broad collection of random walks for sampling from spectrahedra that experimentally show faster mixing times than methods currently employed either in theoretical studies or in applications, including the popular family of Hit-and-Run walks. The different random walks offer a variety of advantages, thus allowing us to efficiently sample from general probability distributions, for example the family of log-concave distributions which arise in numerous applications. We focus on two major applications of independent interest: (i) approximate the volume of a spectrahedron, and (ii) compute the expectation of functions coming from robust optimal control.</p><p>We exploit efficient linear algebra algorithms and implementations to address the aforementioned computations in very high dimension. In particular, we provide a C++ open source implementation of our methods that scales efficiently, for the first time, up to dimension 200. We illustrate its efficiency on various data sets.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Spectrahedra are probably the most well studied shapes after polyhedra. We can represent polyhedra as the intersection of the positive orthant with an affine subspace. Spectrahedra generalize polyhedra, in the sense that they are the intersection of the cone of positive semidefinite matrices -i.e., symmetric matrices with non-negative eigenvalues-with an affine space. In other words, a spectrahedron S ⊂ R n is the feasible set of a linear matrix inequality. That is, if</p><formula xml:id="formula_0">F(x) = A 0 + x 1 A 1 + • • • + x n A n ,<label>(1)</label></formula><p>where A i are symmetric matrices in R m×m , then S = {x ∈ R n | F(x) ⪰ 0}, where ⪰ denotes positive semidefiniteness. We assume throughout that S is bounded of dimension n. Spectrahedra Figure <ref type="figure" target="#fig_0">1</ref>: Left, the pillow: a spectrahedron bounded by an irreducible quartic surface (image from <ref type="bibr" target="#b5">[6,</ref><ref type="bibr">Chapter 5]</ref>). It is a 3D linear slice of a 4D (quartic) elliptope. The latter is a special case of spectrahedron defined as the set of all real, square symmetric matrices whose diagonal entries are all equal to one and whose eigenvalues are all non-negative. Right, a spectrahedron from <ref type="bibr" target="#b8">[9]</ref>; it is a cubic spectrahedron (elliptope).</p><p>are convex sets (Figure <ref type="figure" target="#fig_0">1</ref>) and every polytope is a spectrahedron, but not the opposite. They are the feasible regions of semidefinite programs <ref type="bibr" target="#b52">[53]</ref> in the way that polyhedra are feasible regions of linear programs.</p><p>Efficient methods for sampling points in spectrahedra are crucial for many applications, such as volume approximation <ref type="bibr" target="#b17">[18]</ref>, integration <ref type="bibr" target="#b42">[43]</ref>, semidefinite optimization <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b30">31]</ref>, and applications in robust control analysis <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b59">60]</ref>. To sample in the interior or on the boundary of S , we employ geometric random walks <ref type="bibr" target="#b62">[63]</ref>. A geometric random walk on S starts at some interior point and at each step moves to a "neighboring" point that we choose according to some distribution, depending only on the current point; thus it is a special category of Markov chains. For example, in the so-called ball walk, we move to a point p that we choose uniformly at random in a ball of fixed radius δ, if p ∈ S . The complexity of a random walk depends on its mixing time -the number of steps required to bound the distance between the current and the stationary distribution-and the complexity of the basic geometric operations performed at each step of the walk; we call the latter per-step complexity.</p><p>The majority of geometric random walks are applicable to general convex bodies and they depend on an oracle; usually the membership oracle. There are also a few walks, e.g., Vaidya walk <ref type="bibr" target="#b15">[16]</ref> and the sub-linear ball walk <ref type="bibr" target="#b45">[46]</ref>, that are specialized for polytopes. The majority of the results on the analysis of the walks focuses on convergence and mixing time, while they define abstractly the operations they perform at each step and they enclose them in the corresponding oracle. That is why the complexity bounds involve the number of oracle calls.</p><p>To specialize a random walk for a family or representation of convex bodies one has to come up with efficient algorithms for the basic geometric operations to realize the (various) oracles. These operations should exploit the underlying geometric and algebraic properties and are of independent interest. They depend on efficient (numerical) linear algebra computations. More importantly, they dominate the per-step complexity and are crucial both for the overall complexity to sample a point from the target distribution, as well as for an efficient implementation.</p><p>The study of basic geometric operations to sample from non-linear convex objects finds its roots in non-linear computational geometry. During the last two decades, there are combined efforts <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b24">25]</ref> to develop efficient algorithms for the basic operations (predicates) that are behind classical geometric algorithms, like convex hull, arrangements, Voronoi diagrams, to go beyond points and lines and handle curved objects. For this, one exploits efficiently the structure and the symmetry in the corresponding linear algebra computations and develops novel algebraic tools.</p><p>To our knowledge, only the Random Directions Hit and Run (W-HnR) random walk <ref type="bibr" target="#b55">[56]</ref> has been studied for spectrahedra <ref type="bibr" target="#b11">[12]</ref>. To exploit the various other walks, like Ball walk <ref type="bibr" target="#b62">[63]</ref>, Billiard walk (W-Billard) <ref type="bibr" target="#b25">[26]</ref>, and Hamiltonian Monte Carlo with boundary reflections (W-HMCr) <ref type="bibr" target="#b0">[1]</ref>, one needs to provide certain geometric operations. For example, we need to compute the reflection of a curve at the boundary and the intersection point of a curve with the boundary (of a spectrahedron).</p><p>We should mention that there is a gap <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b4">5]</ref> between the theoretical worst case bounds for the mixing times and the practical performance of the random walk algorithms. Furthermore, there are random walks without known theoretical mixing times, such as Coordinate Directions Hit and Run (W-CHnR), W-Billard and W-HMC-r. To study them experimentally, it is imperative to provide an efficient realization of the corresponding oracles.</p><p>Previous Work. Sampling convex sets via random walks has attracted a lot of interest in the last decades. Most of the works assume that the convex sets are polytopes; <ref type="bibr" target="#b45">[46]</ref> provides an overview of the state-of-the-art. Random walks on spectrahedra are studied in <ref type="bibr" target="#b51">[52,</ref><ref type="bibr" target="#b19">20]</ref>, where they exploit the W-HnR and the computation of the intersection of the walk with the boundary reduces to a generalized eigenvalue problem.</p><p>The W-Billard <ref type="bibr" target="#b25">[26]</ref> is a general way of sampling in convex or non-convex shapes from the uniform distribution. A mathematical billiard consists of a domain D and a point-mass that moves freely in D <ref type="bibr" target="#b57">[58]</ref>. When this point-mass hits the boundary, it performs a specular reflection, albeit without losing velocity. An application of billiards is the study of optical properties of conics <ref type="bibr" target="#b57">[58,</ref><ref type="bibr">Section 4]</ref>.</p><p>If the trajectory is not a line, but rather a parametric curve, then the intersection operation reduces to solving a polynomial eigenvalue problem (PEP); W-HMC-r requires this operation. PEP is a well-studied problem in computational mathematics, e.g., <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b27">28]</ref>, and it appears in many applications. There are important results both for the perturbation analysis of PEP <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b20">21]</ref>, as well as for the condition-based analysis of algorithms for the real and complex versions of PEP, if we assume random inputs <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>; see also <ref type="bibr" target="#b65">[66]</ref> for a numerical algorithm based on homotopy continuation.</p><p>For the closely related problem of volume computation, there is also an extensive bibliography <ref type="bibr" target="#b10">[11]</ref>. The bulk of the theoretical studies are either for general convex bodies <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b17">18]</ref> or polytopes <ref type="bibr" target="#b38">[39]</ref>. Practical algorithms and implementations exist only for polytopes <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b18">19]</ref>. Nevertheless, there are notable exceptions that consider algorithms for computing the volume of compact (basic) semi-algebraic sets. For example, in <ref type="bibr" target="#b34">[35]</ref> they exploit the periods of rational integrals. In the same setting, <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b58">59]</ref> introduce numerical approximation schemes for volume computations which rely on the moment-based algorithms and semi-definite programming.</p><p>Finally, sampling from a multivariate distribution is a central problem in numerous applications. For example, it is useful in robust control analysis <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b59">60]</ref> to overcome the worst case hardness as well as in integration <ref type="bibr" target="#b42">[43]</ref> and convex optimization <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b30">31]</ref>.</p><p>Our contribution. We present a framework of basic geometric operations for computations with spectrahedra. In particular, we analyze the arithmetic and bit complexity of the three fundamental operations, membership, intersection, and reflection, by reducing them to linear algebra computations. Based on this framework, we support a rich class of geometric random walks, which in turn we employ to build efficient methods for sampling points from spectahedra, under various probability distributions. We apply these tools to approximate the volume of spectrahedra, as well as to integrate over spectrahedral domains. This extends the limits of the state-of-the-art methods that sample from spectrahedra, which actually involve only the W-HnR <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b11">12]</ref>. We offer an efficient C++ implementation of our algorithms as a development branch of the package volesti <ref type="foot" target="#foot_0">1</ref> , an open source library for high dimensional sampling and volume computation. While the implementation is in C++, there is also an R interface for easier access to its functionality. Our implementation is based on state-of-the-art algorithms in numerical linear algebra to address computation in high dimension. Our software uses powerful C++ libraries, such as Eigen <ref type="bibr" target="#b26">[27]</ref> and Spectra <ref type="bibr" target="#b56">[57]</ref>, for various basic operations.</p><p>We demonstrate the efficiency of our approach and implementation on problems from robust control and optimization. First, as a special case of integration, we approximate the volume of spectrahedra up to dimension 100; this is, to the best of our knowledge, the first time (at least when the representation is dense) such computations for non-linear objects are performed in high dimensions. However, let us also mention the recent extension of the moment-SOS hierarchy approach <ref type="bibr" target="#b58">[59]</ref> that is able to approximate the volume of high-dimensional semialgebraic sets with a sparse description. Then, we approximate the expected value of a function f : R n → [0, 1], whose argument is a random variable having uniform distribution over a spectrahedron of dimension 200.</p><p>Finally, we sample from the Boltzmann distribution using W-HMC-r; this exploits a random walk in a spectrahedron that employs a polynomial trajectory of degree two. Sampling using W-HMC-r from truncated distributions is a classical problem in computational statistics <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b0">1]</ref>; alas, existing approaches handle either special distributions or special cases of constraints <ref type="bibr" target="#b47">[48,</ref><ref type="bibr" target="#b35">36]</ref>. We equip W-HMC-r with geometric operations to handle log-concave densities truncated by linear matrix inequalities (LMI) constraints. A combination of Boltzmann distribution with a simulated annealing technique <ref type="bibr" target="#b30">[31]</ref> can lead to a practically efficient solver for semidefinite programs (SDP).</p><p>A very short version of this paper has appeared as a poster in <ref type="bibr" target="#b14">[15]</ref>.</p><p>Paper organization. First, we introduce our notation. In Section 2 we introduce the basic geometric operations used to efficiently implement membership and boundary oracles. In Section 3, we develop the different types of random walks. Finally, Section 4 presents our implementation, our applications, and various experiments.</p><p>Notation. We denote by O, respectively O B , the arithmetic, respectively bit, complexity and we use O, respectively O B , to ignore (poly-)logarithmic factors. The bitsize of a univariate polynomial A ∈ Z[x] is the maximum bitsize of its coefficients. We use bold letters for matrices, A, and vectors, v; we denote by A i, j , respectively v i , their elements; A ⊤ is the transpose and A * the adjoint of A.</p><formula xml:id="formula_1">If x = (x 1 , . . . , x n ), then F(x) = A 0 + n i=1 x i A i , see<label>(1)</label></formula><p>. For two points x and y, we denote the line through them by ℓ(x, y) and their segment as [x, y]. For a spectrahedron S , let its interior be S • and its boundary ∂S . We represent a probability distribution π with a probability density function π(x). When π is truncated to S the support of π(x) is S . If π is log-concave, then π(x) ∝ e -α f (x) , where f : R d → R a convex function. Finally, let B n be the n-dimensional unit ball and denote by ∂B n its boundary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Basic geometric operations</head><p>Our toolbox for computations with spectrahedra and implementing random walks, consists of three basic geometric operations: membership, intersection, and reflection.</p><p>For a spectrahedron S , membership decides whether a point lies inside S , intersection computes the intersection of an algebraic curved trajectory C with the boundary ∂S , and reflection computes the reflection of an algebraic curved trajectory when it hits ∂S . We need the last two operations because random walks can move along non-linear trajectories inside convex bodies. We consider only trajectories that are parametric polynomial curves of various degrees; the extension to rational parametric curves is straightforward. Computation with these curves reduces to solving the polynomial eigenvalue problem (PEP).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Analysis of PEP</head><p>To estimate the Boolean complexity of intersection we need to bound the complexity of the Polynomial Eigenvalue Problem (PEP). It consists in computing λ ∈ C and x ∈ C m that satisfy the (matrix) equation</p><formula xml:id="formula_2">P(λ) x = 0 ⇔ (B d λ d + • • • + B 1 λ + B 0 )x = 0 ,<label>(2)</label></formula><p>where P(λ) is a univariate matrix polynomial whose coefficients are matrices B i ∈ R m×m . We further assume that B d and B 0 are invertible. In general, there are δ = m d values of λ. We refer the reader to <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b27">28]</ref> for a thorough exposition of PEP. In LMI, Eq. ( <ref type="formula" target="#formula_0">1</ref>), the matrices are symmetric and for intersection we are interested only for the smallest real eigenvalue of PEP. Unfortunately, the Boolean complexity analysis that we present cannot exploit neither the symmetry nor the fact that we need only the smallest positive real eigenvalue. For this we need to rely our analysis on geometric conditioning (and probably exploit different algorithms), see e.g., <ref type="bibr" target="#b9">[10]</ref>. In this case, the symmetry plays an essential role in the analysis, as it is also plays an essential role in the practical performance of the various dedicated algorithms. Such an analysis, even though important, is beyond the scope of our presentation. Thus, the bit (and the arithmetic) complexity bounds correspond to the worst case instances in the Turing model (or the real RAM model) and do not give an accurate view of the practical performance of the various algorithms. Moreover, they consider the general PEP problem and do not distinguish between the symmetric and the non-symmetric case. One approach for solving PEP is to linearalize the problem and to express the λ's as the eigenvalues of a larger matrix. For this, we transform Equation (2) into a linear pencil of dimension δ. Following <ref type="bibr" target="#b3">[4]</ref>, the Companion Linearization consists in solving the generalized eigenvalue problem C 0 -λC 1 , where</p><formula xml:id="formula_3">C 0 =                     B d 0 • • • 0 0 I m . . . . . . . . . . . . . . . 0 0 • • • 0 I m                     and C 1 =                  B d-1 B d-2 • • • B 0 -I m 0 • • • 0 . . . . . . . . . . . . 0 • • • -I m 0                 </formula><p>, and I m denotes the m × m identity matrix. The eigenvectors x and z are related as follows:</p><formula xml:id="formula_4">z = [1, λ, . . . , λ d-2 , λ d-1 ] ⊤ ⊗ x.</formula><p>To obtain an exact algorithm for PEP we exploit the assumption that B d is invertible so as to transform the problem to the following classical eigenvalue problem (λI d -C 2 )z = 0, where</p><formula xml:id="formula_5">C 2 =                  B d-1 B -1 d B d-2 B -1 d • • • B 0 B -1 d -I m 0 • • • 0 . . . . . . . . . . . . 0 • • • -I m 0                  .</formula><p>The eigenvectors are roots of the characteristic polynomial of C 2 . Now the problem is to compute the eigenvalues of C ∈ R δ×δ . There are various approaches to tackle PEP, e.g. <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b27">28]</ref> and references therein. There are also specialized algorithms for linearization that exploit the fact that the matrices might be symmetric, like in (1), <ref type="bibr" target="#b29">[30]</ref> and also algorithms that fully exploit the structure of the linearization pencils <ref type="bibr" target="#b61">[62]</ref>. These are the methods that are used, very successfully, in practice. However, from a (Boolean) complexity point of view, the best algorithm relies on computing the roots, real and complex, of the characteristic polynomial <ref type="bibr" target="#b54">[55]</ref>, which is the approach that we follow to derive Boolean complexity estimates for PEP.</p><p>Lemma 2.1. Consider a PEP of degree d, involving matrices of dimension m × m, with integer elements of bitsize at most τ, see Equation <ref type="bibr" target="#b1">(2)</ref>. There is a randomized algorithm for approximating the eigenvalues and the eigenvectors of PEP up to precision ϵ = 2 -L , in O B (δ ω+3 L), where δ = md, L = Ω(δ 3 τ), and ω is the exponent in the complexity of matrix multiplication. The arithmetic complexity of a deterministic algorithm is O(δ ω + δ lg(1/ϵ)).</p><p>Proof. We can compute the characteristic polynomial of an N × N matrix M in O B (N 2.697 lg∥M∥) using a randomized algorithm, see <ref type="bibr" target="#b31">[32]</ref> for the precise value of the exponent and related references . Here ∥M∥ denotes the largest entry in absolute value. In our case, the elements of C 2 have bitsize O(δτ) and its characteristic polynomial is of degree d and coefficient bitsize O B (δ 2 τ). We compute it in O B (δ 2.697 δτ) = O B (δ 3.697 τ) and isolate all its real roots in O B (δ 5 + δ 4 τ) <ref type="bibr" target="#b48">[49]</ref>; they correspond to the real eigenvalues of PEP. We can decrease the width of the isolating interval by a factor of ϵ = 2 -L for all the roots in O B (δ 3 τ + δL) <ref type="bibr" target="#b49">[50]</ref>. Thus, the overall complexity is O B (δ 5 + δ 3.697 τ + δL).</p><p>It remains to compute the corresponding eigenvectors. For each eigenvalue λ we may compute the corresponding eigenvector z by Gaussian elimination and back substitution to the (augmented) matrix [λI δ -C 2 | 0]. This requires O(δ ω ) arithmetic operations. However, as λ is a root of the characteristic polynomial, one has to operate on algebraic numbers, which is highly non-trivial, and one needs to bound the number of bits needed to compute the elements of z correctly and to recover x. Hence, we employ separation bounds for polynomial system adapted to eigenvector computation <ref type="bibr" target="#b23">[24]</ref>. One needs, as in the case of eigenvalues, O B (δ 4 + δ 3 τ) bits to isolate the coordinates of the eigenvectors. To decrease the width of the corresponding isolating intervals by a factor of ϵ = 2 -L , the number of bits becomes O B (δ 4 + δ 3 τ + L). Thus, we compute the eigenvectors in</p><formula xml:id="formula_6">O B (δ ω (δ 4 + δ 3 τ + L)) = O B (δ ω+4 + δ ω+3 τ + δ ω L).</formula><p>For the arithmetic complexity we proceed as follows: We compute the characteristic polynomial in O(δ ω ) <ref type="bibr" target="#b46">[47]</ref> with a deterministic algorithm and we approximate its roots up to ϵ in O(δ lg(1/ϵ)) <ref type="bibr" target="#b48">[49]</ref>. Finally, we compute the eigenvectors with O(δ ω ) arithmetic operations. So the overall cost is O(δ ω + δ lg(1/ϵ)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">membership</head><p>The operation membership(F, p) decides whether a point p lies in the interior of a spectrahedron</p><formula xml:id="formula_7">S = {x ∈ R n | F(x) ⪰ 0}. For this, first, we construct the matrix F( p). If it is positive definite, then p ∈ S • . If it is positive semidefinite, then p ∈ ∂S , otherwise p ∈ R n \ S . The pseudo-code appears in Algorithm 1.</formula><p>Lemma 2.2. Algorithm 1, membership(F, p), requires O(nm 2 + m ω ) arithmetic operations (deterministic), where ω is the exponent of matrix multiplication. If F and p have integer elements of bitsize at most τ, respectively σ, then the bit complexity is O B ((nm 2 +m 2.697 )(τ+σ)) (randomized).  Proof. We construct F( p) in O(nm 2 ). Then, with O(m ω ) operations we compute its characteristic polynomial <ref type="bibr" target="#b46">[47]</ref> and in O(m) we decide whether it has negative roots, for example by solving <ref type="bibr" target="#b48">[49]</ref> or using fast subresultant algorithms <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b39">40]</ref>. For the bit complexity, the construction costs O B (nm 2 (τ + σ)) and the computation of the characteristic polynomial costs O B (m 2.697 (τ + σ)), using a randomized algorithm <ref type="bibr" target="#b31">[32]</ref>. One may test for negative roots, and thus eigenvalues, in O B (m 2 n(τ + σ)) <ref type="bibr" target="#b39">[40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">intersection</head><p>Consider a parametric polynomial curve C such that it has a non-empty intersection with a spectrahedron S . Throughout, we consider only the real trace of C. Assume that the value of the parameter t = 0 corresponds to a point p 0 , that lies in C ∩ S • . Furthermore, assume that the segment of C on which p 0 lies, intersects the boundary of S transversally at two points, say p - and p + . The operation intersection computes the parameters, t -and t + , corresponding to these two points. Figure <ref type="figure" target="#fig_1">2</ref> illustrates this discussion and the pseudo-code of intersection appears in Algorithm 2.</p><p>To prove correctness and estimate the complexity we proceed as follows: As before (see also Equation <ref type="formula" target="#formula_0">1</ref>), S is the feasible region of linear matrix inequalities (LMI) F(x) ⪰ 0. Consider the real trace of a polynomial curve C, with parameterization</p><formula xml:id="formula_8">Φ : R → R n t → Φ(t) := (p 1 (t), . . . , p n (t)),<label>(3)</label></formula><p>where p i (t) = d i j=0 p i, j t j are univariate polynomials in t of degree</p><formula xml:id="formula_9">d i , for i ∈ [m]. Also let d = max i∈[m] {d i }.</formula><p>If the coefficients of the polynomials are integers, then we further assume that the maximum coefficient's bitsize is bounded by τ.</p><p>As t varies over the real line, there may be several disjoint intervals, for which the corresponding segment of C lies in S • . We aim to compute the endpoints, t -and t + , of a maximal such interval containing t = 0. Let p 0 = Φ(0); by assumption it holds F(Φ(0)) = F( p 0 ) ≻ 0.</p><p>The input of intersection (Algorithm 2) is F, the LMI representation of S , and Φ(t), the polynomial parameterization of C. Its crux is a routine, pep, that solves a polynomial eigenvalue problem. The following lemma exploits this relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2: intersection(F, Φ(t))</head><p>Input : An LMI F(x) ⪰ 0 for a spectrahedron S and a parameterization Φ(t) of a polynomial curve C. Require:</p><formula xml:id="formula_10">Φ(0) ∈ S • . Output : t -, t + s.t. Φ(t -), Φ(t + ) ∈ ∂S . 1 T := {t 1 ≤ t 2 ≤ • • • ≤ t ℓ } ← pep(F(Φ(t))); 2 t -← max{t ∈ T | t &lt; 0}; // max negative polynomial eigenvalue 3 t + ← min{t ∈ T | t &gt; 0}; // min positive polynomial eigenvalue 4 return t -, t + ; Lemma 2.3 (pep and S ∩ C). Consider the spectrahedron S = {x ∈ R n | F(x) ⪰ 0}. Let Φ : R → R n be a parameterization of a polynomial curve C, such that Φ(0) ∈ S • . Let [t -, t + ]</formula><p>be the maximal interval containing 0, such that the corresponding part of C lies in S . Then, t -, respectively t + , is the maximum negative, respectively minimum positive, polynomial eigenvalue of F(Φ(t))x = 0, where</p><formula xml:id="formula_11">F(Φ(t)) = B 0 + tB 1 + • • • + t d B d .</formula><p>Proof. The composition of F(x) and Φ(t) gives</p><formula xml:id="formula_12">F(Φ(t)) = A 0 + p 1 (t) A 1 + • • • + p n (t) A n .<label>(4)</label></formula><p>We rewrite (4) by grouping the coefficients for each t i , i ∈ [d], then</p><formula xml:id="formula_13">F(Φ(t)) = B 0 + tB 1 + • • • + t d B d ,<label>(5)</label></formula><p>where B k = n j=0 p j,k A j , for 0 ≤ k ≤ d. We use the convention that p j,k = 0, when k &gt; d j . For t = 0, it holds, by assumption, that F(Φ(0)) = B 0 ≻ 0: thus the point Φ(0) lies in the interior of S . Actually, for any x ∈ S • it holds F(x) ≻ 0. On the other hand, if x ∈ ∂S , then F(x) ⪰ 0. Our goal is to compute the maximal interval [t -, t + ] that contains 0 and for every t in it, we have F(Φ(t)) ⪰ 0.</p><p>Starting from point Φ(0), by varying t, we move on the trajectory that C defines (in both directions) until we hit the boundary of S . When we hit ∂S , the matrix F(Φ(t)) is not strictly definite anymore. Thus, its determinant vanishes.</p><p>Consider the function θ : R → R, where θ(t) = det F(Φ(t)) is a univariate polynomial in t. If a point Φ(t) is on the boundary of the spectrahedron, then θ(t) = 0. We opt to compute t -and t + , such that t -≤ 0 ≤ t + and θ(t -) = θ(t + ) = 0. At t = 0, θ(0) &gt; 0 and the graph of θ is above the t-axis. So C intersects the boundary when the graph of θ touches the t-axis for the first time at t 1 ≤ 0 ≤ t 2 . It follows that t -= t 1 and t + = t 2 are the maximum negative and minimum positive roots of θ, or equivalently the corresponding polynomial eigenvalues of F(Φ(t)).</p><p>Lemma 2.4. Algorithm 2, intersection(F, Φ(t)), uses O((md) ω + md lg L) arithmetic operations to compute the intersection, up to precision ϵ = 2 -L , of an LMI, F, consisting of n matrices of dimension m × m with a parametric curve, Φ(t), of degree d, where ω is the exponent in the complexity of matrix multiplication.</p><p>Proof. We have to construct PEP and solve it. Since Φ(t) has degree d, then</p><formula xml:id="formula_14">F(Φ(t)) = B 0 + tB 1 + • • • + t d B d is a PEP of degree d.</formula><p>This construction costs O(dnm 2 ) operations. The solving phase, using Lemma 2.1, requires O((md) ω + md lg L) arithmetic operations and dominates the complexity bound of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">reflection</head><p>Algorithm 3: reflection (F, Φ(t))</p><p>Input : An LMI F(x) ⪰ 0 for a spectrahedron S and a parameterization Φ(t) of a polynomial curve C. Require:</p><formula xml:id="formula_15">(i) Φ(0) ∈ S • .</formula><p>(ii) C intersects ∂S transversally at a smooth point. Output : t + such that Φ(t + ) ∈ ∂S and the direction of the reflection, s + , at this point.</p><formula xml:id="formula_16">1 t -, t + ← intersection (F, Φ(t)); 2 w ← ∇ det F(Φ(t + )); 3 w ← w ∥w∥ ; // Normalize w 4 s + ← dΦ dt (t + ) -2 ⟨∇ dΦ dt (t + ), w⟩ w; 5 return t + , s + ;</formula><p>The reflection operation (Algorithm 3) takes as input an LMI representation, F, of a spectrahedron S and a polynomial curve C, given by a parameterization Φ. Assume that t = 0 corresponds to a point Φ(0) ∈ S • ∩ C. Starting from t = 0, we increase t along the positive real semi-axis. As t changes, we move along the curve C through Φ(t), until we hit the boundary of S at the point p + := Φ(t + ) ∈ ∂S , for some t + &gt; 0. Then, a specular reflection occurs at this point with direction s + ; this is the reflected direction. We output t + and s + . Figure <ref type="figure" target="#fig_1">2</ref> depicts the procedure.</p><p>The boundary of S , ∂S , with respect to the Euclidean topology, is a subset of the real algebraic set {x ∈ R n | det(F(x)) = 0}. The latter is a real hypersurface defined by one (determinantal) equation. For any x ∈ ∂S we have rank(F(x)) ≤ m -1. We assume that p + = Φ(t + ) is such that rank(F( p + )) = m -1. The normal direction at a point p ∈ ∂S , is the gradient of det F( p).</p><p>We compute the reflected direction using the following formula</p><formula xml:id="formula_17">s + = u -2 |w| 2 ⟨u, w⟩ w, (<label>6</label></formula><formula xml:id="formula_18">)</formula><p>where w is the normalized gradient vector at the point Φ(t + ) and u = dΦ dt (t + ) is the direction of the trajectory at this point. We illustrate the various vectors in Figure <ref type="figure" target="#fig_1">2</ref>. </p><formula xml:id="formula_19">m matrix F(x) is m -1. Then ∇ det(F(x)) = c • (v ⊤ A 1 v, • • • , v ⊤ A n v),<label>(7)</label></formula><p>where c = µ(F(x)) |v| 2 , µ(F(x)) is the product of the nonzero eigenvalues of F(x), and v is a non-trivial vector in the kernel of F(x). If rank(F(x)) ≤ m -2, then the gradient is the zero.</p><p>Proof. Using the lemma in Appendix A.2:</p><formula xml:id="formula_20">∂ det F(x) ∂x k = Trace (F(x) * A k ) .<label>(8)</label></formula><p>If rank(F(x)) ≤ -2, then F(x) * is the zero matrix. If we assume that rank(F(x)) = m -1, then using the lemma in Appendix A.3:</p><formula xml:id="formula_21">Trace (F(x) * A k ) = Trace µ(F(x)) vu ⊤ u ⊤ v A k = µ(F(x)) u ⊤ v • Trace vu ⊤ A k = µ(F(x)) u ⊤ v • u ⊤ A k v.</formula><p>However, since F(x) is symmetric, we can choose v = u, so:</p><formula xml:id="formula_22">µ(F(x)) u ⊤ v • u ⊤ A k v = µ(F(x)) |v| 2 • v ⊤ A k v,</formula><p>which concludes the proof.</p><p>The algorithm reflection exploits Lemma 2.5. Nevertheless, it is not necessary to perform all the computations that the lemma indicates. For example, because we will normalize the resulting vector and we do not need its actual direction (internal or external), we can omit the computation of c. Moreover, the nonzero vector v, which satisfies F( p)v = 0, corresponds to the eigenvector w.r.t. the eigenvalue t + from the PEP (Lemma 2.3). This is true because p = Φ(t + ) ∈ ∂S and thus det F(Φ(t + )) = 0.</p><p>At this point we should note that we compute the eigenvalues of PEP up to some precision. Since the matrix-vector multiplication is backward stable, a small perturbation on v does not affect the computation of each coordinate of ∇ det(F(x)) <ref type="bibr">[61, p. 104</ref>]. We quantify the accuracy of the computed ∇ det(F(x)) using floating point arithmetic as follows:</p><p>Lemma 2.6. The relative error of each coordinate of the gradient given in Lemma 2.5 when we compute it using floating point arithmetic with machine epsilon</p><formula xml:id="formula_23">ϵ M is O( ϵ M σ max (A i ) ), for i ∈ [n]</formula><p>, where σ max is the largest singular value of A i .</p><p>Proof. Let A ∈ R m×m be a symmetric matrix and consider the map f : v → v T Av. The relative condition number of f as defined in <ref type="bibr">[61, p. 90]</ref> is</p><formula xml:id="formula_24">k(v) = ||J(v)|| || f (v)||/||v|| = 2 ||Av|| v T A i v = 2 σ max (A) σ 2 max (A) = 2 σ max (A)</formula><p>,</p><p>where J(•) is the Jacobian of f . According to Theorem 15.1 in [61, p. 111], since the matrixvector multiplication is backward stable, the relative error of each coordinate in the gradient computation of Lemma 2.5 is O( ϵ M σ max (A i ) ), for 1 ≤ i ≤ n. Lemma 2.7. Let S be a spectrahedron represented by an LMI, F(x), consisting of n matrices of dimension m × m. Also let C be a parametric curve with parameterization Φ(t), involving polynomials of degree at most d. Algorithm 3, reflection(F, Φ(t)), computes the intersection, up to precision ϵ = 2 -L , of S with C, and the reflection of C at ∂S , by performing O((md) ω + md lg L + dnm 2 ) arithmetic operations, where ω is the exponent in the complexity of matrix multiplication. Proof. By inspecting Algorithm 3 we notice that the complexity of the algorithm depends on the construction of ∇ det(F(x)) and the call to intersection.</p><p>To compute ∇ det(F(x)) we just need to compute (v</p><formula xml:id="formula_25">⊤ A 1 v, • • • , v ⊤ A n v).</formula><p>If we have already computed v, then this computation requires O(nm 2 ) operations. The computation of the derivative of Φ(t) is straightforward, as Φ is a univariate polynomial. Taking into account the complexity of intersection, the total complexity for reflection is O((md) ω + md lg L + dnm 2 + nm 2 ) = O((md) ω + md lg L + dnm 2 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">An example in 2D</head><p>Consider a spectrahedron S in the plane (Figure <ref type="figure" target="#fig_3">3</ref>), given by an LMI F(x) = A 0 +x 1 A 1 +x 2 A 2 . The matrices A i , 0 ≤ i ≤ 2, are in the appendix.</p><p>Starting from the point p 0 = (-1, 1) ⊤ , we walk along the line L with parameterization: Φ(t) = p 0 + tu, where u = (1.3, 0.8) ⊤ . Then, intersection finds the intersection of S with L, by solving the degree one PEP, (B 0 + tB 1 )x = 0, where B 0 = F( p 0 ) and B 1 = u 1 A 1 + u 2 A 2 . Acquiring t -= -0.8 and t + = 0.5, we obtain the intersection point p 1 , which corresponds to p 0 + t + u = (-0.3, 1.4) ⊤ .</p><p>To compute the direction of the trajectory, immediately after we reflect on the boundary of S at p 1 , reflection computes</p><formula xml:id="formula_26">w = ∇ det F(Φ(t + )) |∇ det F(Φ(t + ))| = (v ⊤ A 1 v, v ⊤ A 2 v) ⊤ = (-0.2, -1) ⊤ ,<label>(9)</label></formula><p>where v is the eigenvector of (B 0 + tB 1 )x = 0, with eigenvalue t + . The reflected direction is u ′ = u -2⟨u, w⟩ w = (0.8, -1.3) ⊤ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Random walks</head><p>Using the basic geometric operations of Section 2, we implement and analyze three random walks for spectrahedra: Hit and Run (W-HnR), its variant Coordinate Directions Hit and Run (W-CHnR), Billiard Walk (W-Billard), and Hamiltonian Monte Carlo with reflections (W-HMC-r).</p><p>In Table <ref type="table">1</ref> we present the per-step arithmetic complexity for each random walk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Random walk per-step Complexity</head><formula xml:id="formula_27">HR O(m ω + m log(1/ϵ) + dm 2 ) Coordinate HR O(m ω + m log(1/ϵ) + m 2 ) Billiard walk O(ρ(m ω + m log(1/ϵ) + dm 2 )) ReHMC (collocation) O(ρ((nm) ω + mn log(1/ϵ) + dnm 2 )) ReHMC (leapfrog) O(Lρ(m ω + m log(1/ϵ) + dm 2 ))</formula><p>Table <ref type="table">1</ref>: The per-step complexity of the random walks in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Hit and Run</head><p>W-HnR (Algorithm 4) is a random walk that samples from any probability distribution π truncated to a convex body K; in our case a spectrahedron S . We should mention that there exist bounds for its mixing time only when π is log-concave distribution, for example the uniform distribution; the bound is O(n 3 ).</p><p>At the i-th step, W-HnR chooses uniformly at random a (direction of a) line ℓ, passing from its current position p i . Let p 1 and p 2 be the intersection points of ℓ with S . Let π ℓ be the restriction of π on the segment [ p 2 , p 2 ]. Then, we choose p i+1 from [ p 1 , p 2 ] w.r.t. the distribution π ℓ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4: Hit-and-Run Walk (W-HnR)</head><p>Input : LMI F(x) ⪰ 0 for a spectrahedron S &amp; a point p i . Require: p i ∈ S Output : The point p i+1 of the (i + 1)-th step of the walk. 1 BO (F, interior point p i ) v ← R U(∂B n ); // choose direction 2 Φ(t) := p i + tv; // define trajectory 3 t -, t + ← intersection (F, Φ(t)); 4 p i+1 ← R [ p i + t -v, p i + t + v] w.r.t. π ℓ ; 5 return p i+1 ; Lemma 3.1. The per-step complexity of W-HnR is O(m ω + m lg 1/ϵ + nm 2 ), where ω is the exponent in the complexity of matrix multiplication algorithms and ϵ is the accuracy we want to approximate the intersection with the boundary.</p><p>Proof. The per-step complexity of W-HnR is dominated by the intersection, which requires O(nm 2 ) operations for the construction of the pep and O(m ω + m lg 1/ϵ) for solving it; in the case where we want to approximate the intersection point up to a factor or ϵ = 2 -L (Lemma 2.4).</p><p>There is also a variation of W-HnR, the coordinate directions Hit and Run (W-CHnR) <ref type="bibr" target="#b55">[56]</ref>. This walk chooses the direction vector uniformly at random among the basis vectors {e i } i∈ <ref type="bibr">[n]</ref> . In W-CHnR, for every step aside the first, the construction of the pep takes O(m 2 ) operations and the complexity does not depend on the dimension n. The reason for this improvement is that the constructin of pep we have F(p i + te j ) = F( p i ) + t A j and we can obtain the value of F( p i ) from F( p i ) = F(p i-1 ) + t A k , assuming that at the previous step we have chosen e k as direction. There is no theoretical mixing time for W-CHnR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Billiard walk</head><p>W-Billard <ref type="bibr" target="#b50">[51]</ref>, Algorithm 5, samples a convex body K under the uniform distribution; no theoretical results for its mixing time exist. At the i-th step, being at position p i , it chooses uniformly a direction vector v and a number ℓ, where ℓ = -τ ln η, η ∼ U(0, 1), and τ is a chosen constant. Then, it moves at the direction of v for distance ℓ. If during the movement it hits the boundary without having covered the required distance ℓ, then it continues on a reflected trajectory. If the number of reflections exceeds a bound ρ, it stays at p i . In <ref type="bibr" target="#b50">[51]</ref> they experimentally conclude that W-Billard mixes faster when τ ≈ diam(K), where diam(K) is the diameter of K.</p><p>Algorithm 5: Billiard Walk (W-Billard)</p><p>Input : An LMI F(x) ⪰ 0 for a spectrahedron S , a point p i , the diameter τ of S and a bound ρ on the number of reflections. Require: p i ∈ S Output : The point p i+1 of the (i + 1)-th step of the walk.</p><formula xml:id="formula_28">1 ℓ ← -τ ln η ; η ← R U((0, 1)); // choose length 2 v ← R U(∂B n ); // choose direction 3 p ← p i ; 4 do 5 Φ(t) := p + tv; // define trajectory 6 t + , s + ← reflection (F, Φ(t)); 7 t ← min{t + , ℓ} ; p ← Φ( t) ; 8 if t &lt; ℓ then v ← s + ; 9 ℓ ← ℓ -t ;</formula><p>10 while ℓ &gt; 0; 11 if #{reflections} &gt; ρ then return p i+1 = p i ; 12 return p i+1 = p Lemma 3.2. The per-step complexity of W-Billard is O(ρ(m ω + m lg 1/ϵ + nm 2 )), where ρ is the number of reflections, ω is the exponent in the complexity of matrix multiplication, and ϵ is the accuracy we want to approximate the intersection with the boundary.</p><p>Proof. The per-step complexity of W-Billard is dominated by the reflection, which requires O(m ω + m lg 1/ϵ + nm 2 ) arithmetic operations (Lemma 2.7), when we want to approximate the intersection point up to a factor of ϵ = 2 -L . Since we allow at most ρ reflections per step, the total complexity becomes O(ρ(m ω + m lg 1/ϵ + nm 2 )).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Hamiltonian Monte Carlo with Reflections</head><p>Hamiltonian Monte Carlo (HMC) is an important algorithm for sampling from any probability distribution π. Once more, our focus lies on log-concave distributions, that are of the form π(x) ∝ e -f (x) , where f (x) is a convex function. We exploit the approach presented in <ref type="bibr" target="#b37">[38]</ref> where they approximate the Hamiltonian trajectory with a polynomial curve. In this setting, if we assume that f is a strongly convex function, then the mixing time of HMC is O(k 1.5 log(n/ϵ)), where κ is the condition number of ∇ 2 f <ref type="bibr" target="#b37">[38]</ref>. If we truncate π by considering its restriction in a convex body, then we can use boundary reflections (W-HMC-r), as in Algorithm 6, to ensure Algorithm 6: HMC w reflection (W-HMC-r)</p><p>Input : An LMI F(x) ⪰ 0 representing a spectrahedron S , a point p i , the diameter τ of S and a bound ρ to the number of reflections. Require: p i ∈ S Output : The point p i+1 of the (i + 1)-th step of the walk.</p><formula xml:id="formula_29">1 ℓ ← τη; η ← R U((0, 1)); // choose length 2 v ← R N(0, I n ); // choose direction 3 do 4</formula><p>Compute trajectory Φ(t) from ODE (10);</p><formula xml:id="formula_30">5 t + , s + ← reflection (F, Φ(t)); 6 t ← min{t + , ℓ} ; p ← Φ( t) ; v ← s ; ℓ ← ℓ -t ; 7 while ℓ &gt; 0; 8 if # {reflections} &gt; ρ then return p i+1 = p i ; 9 return p i+1 = p ;</formula><p>that the random walk converges to the target distribution <ref type="bibr" target="#b16">[17]</ref>; however, in this case the mixing time is unclear.</p><p>HMC introduces an auxiliary random variable v, called momentum, and generates samples from the joint density,</p><formula xml:id="formula_31">π( p, v) = π(v| p)π( p),</formula><p>which ensures that if we marginalize out the momentum we immediately recover the target distribution. We consider the case where the auxiliary density is a multivariate normal that does not depend on the position p, v ∼ N(0, I n ), where I n is the n × n identity matrix; this is the most common case in applications. It turns out <ref type="bibr" target="#b4">[5]</ref> that the probability density function π( p, v) = e -H(p,v) defines a Hamiltonian,</p><formula xml:id="formula_32">H( p, v) = -log π( p, v) = U( p) + K(v) = f ( p) + 1 2 |v| 2 ,</formula><p>where the term U(p) is called potential energy and the term K(v) is called Kinetic energy. In this way, HMC simulates an imaginary particle moving in a conservative field determined by a negative log-probability function f (x) and its gradient ∇ f (x). HMC, starting from a position p, generates a new state in two stages. First, it draws a value for the momentum independently of the current position, v ∼ N(0, I n ). Next, the joint state (p, v) is given by the Hamilton's system of Ordinary Differential Equations (ODE):</p><formula xml:id="formula_33">d p dt = ∂H( p, v) ∂v dv dt = - ∂H( p, v) ∂p ⇒            d p(t) dt = v(t) dv(t) dt = -∇ f (p) .<label>(10)</label></formula><p>Thus, in each step of HMC one has to solve the ODE in <ref type="bibr" target="#b9">(10)</ref>. If π(x) is a log-concave density, then we can approximate the solution of the ODE with a low degree polynomial trajectory <ref type="bibr" target="#b37">[38]</ref>, using the collocation method. A degree d = O(1/ log(ϵ)) suffices to obtain a polynomial trajectory with error O(ϵ), for a fixed time interval, while we perform just O(1) evaluations of ∇ f (x).</p><p>Finally, Algorithm 6 (W-HMC-r) at the i-th step uniformly samples a step ℓ from a proper interval to move on the trajectory implied by ODE <ref type="bibr" target="#b9">(10)</ref>, choses v randomly from N(0, I n ), and updates p using the ODE in <ref type="bibr" target="#b9">(10)</ref>, for t ∈ [0, ℓ]. When π is truncated in a convex body, then W-HMC-r fixes an upper bound ρ on the number of reflections and reflects a polynomial trajectory as we describe in Section 2.4.</p><p>Each step of W-HMC-r, when π(x) is a log-concave density truncated by S , costs O(ρ((dm) ω + md lg L + dnm 2 )), if we approximate the intersection points up to a factor ϵ = 2 -L , where d is the degree of the polynomial that approximates the solution of the ODE <ref type="bibr" target="#b9">(10)</ref>.</p><p>Lemma 3.3. The per-step complexity of W-HMC-r is O(ρ((dm) ω + md lg 1/ϵ + dnm 2 )), where ρ is the number of reflections, ω is the exponent in the complexity of matrix multiplication. and ϵ is the accuracy we want to approximate the intersection with the boundary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Applications and experiments</head><p>This section demonstrates and compares the algorithms of Section 3 and the efficiency of our software on three applications that rely on sampling from spectrahedra.</p><p>We call walk length the number of the intermediate points that a random walk visits before producing a single sample. The longer the walk length of a random walk is, the smaller the distance of the current distribution to the stationary (target) distribution becomes. Typically we choose a sufficiently large length for the first sample, this procedure is often called "burning".</p><p>Our code is parameterized by the floating point precision of the computations. We use Eigen <ref type="bibr" target="#b26">[27]</ref> for basic linear algebra operations, such as Cholesky decomposition and matrix multiplication. For eigenvalue computations, we employ Spectra <ref type="bibr" target="#b56">[57]</ref>, which is based on Eigen and offers crucial optimizations. First, it solves generalized eigenvalue problems of special structure; that is (B 0 -λB 1 )v = 0, when B 0 is positive semidefinite and B 1 symmetric. This operation is encountered when W-Billard or W-HnR call intersection. Second, it offers directly the computation of the largest eigenvalue which corresponds to t + after a simple transformation. Finally, Spectra provides approximately × 20 speedup over the default eigenvalue computation by Eigen. To the best of our knowledge, our software is the first that can sample efficiently from spectrahedra and estimates volumes up to a few hundred dimensions. It is accessible on github. <ref type="foot" target="#foot_1">2</ref>For our experiments, we generate random spectrahedra following <ref type="bibr" target="#b19">[20]</ref>. In particular, to construct the LMI of Equation ( <ref type="formula" target="#formula_0">1</ref>) we set A 0 to be positive semidefinite, i.e., A 0 = Z Z T + I m , where we pick the elements of Z ∈ R m×m uniformly at random from [0, 1]. Then, for A i , i = 1, . . . , n we set,</p><formula xml:id="formula_34">A i = Q 0 0 -Q , Q = Q + Q T ,</formula><p>where we pick the elements of Q ∈ R (m/2)×(m/2) uniformly at random from [-1, 1]. We performed all the experiments on PC with Intel Core i7-6700 3.40GHz × 8 CPU and 32GB RAM.</p><p>Interior point. A crucial pre-processing step for the applications we consider is to find an interior point of a spectrahedron so that we could use it as (or compute) a starting point for a random walk. Let a spectrahedron S given by the LMI, <ref type="bibr" target="#b0">(1)</ref>. One can introduce an auxiliary variable λ ∈ R to transform the LMI representation to the following Semidefinite Program (SDP), min λ, subject to</p><formula xml:id="formula_35">S = {x ∈ R n | A 0 + n i=1 x i A i ⪰ 0} as in</formula><formula xml:id="formula_36">F(x) = A 0 + n i=1 x i A i + λI m , F(x) ⪰ 0,<label>(11)</label></formula><p>where I m is the m × m identity matrix. If the SDP in <ref type="bibr" target="#b10">(11)</ref> has a feasible solution ( x, λ) with a non-positive objective function then, x lies in the interior of spectrahedron S . Moreover, it is straightforward to compute a λ + &gt; 0 such that (0, λ + ) is a feasible solution of <ref type="bibr" target="#b10">(11)</ref>. Then, we can use an algorithm that solves SDPs to compute an interior point of S . When, in particular, the algorithm is iterative one could stop as soon as it computes a non-negative feasible solution.</p><p>Finally, sampling from spectrahedra with random walks could be used to compute an interior point in S , as we could use the randomized iterative algorithm of Section 4.3 to solve the SDP in <ref type="bibr" target="#b10">(11)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Volume computation</head><p>We use the geometric operations (Section 2) and the random walks (Section 3) to compute the volume vol(S ) of spectrahedron S . Our implementation approximates vol(S ) within relative error 0.1 with high probability in a few minutes, for dimension n = 100.</p><p>A typical randomized algorithm for volume approximation exploits a Multiphase Monte Carlo (MMC) technique, which reduces volume approximation of convex body S to computing a telescoping product of ratios of integrals over S . In particular, for any sequence of functions { f 0 , . . . , f k }, where f i : R n → R, we have:</p><formula xml:id="formula_37">vol(S ) = S 1dx = S f k (x)dx S f k-1 (x)dx S f k (x)dx • • • S 1dx S f 0 (x)dx . (<label>12</label></formula><formula xml:id="formula_38">)</formula><p>Notice that P f i-1 (x)dx</p><formula xml:id="formula_39">P f i (x)dx = P f i-1 (x) f i (x) f i (x) P f i (x)dx dx.</formula><p>To estimate each ratio of integrals, we sample N points from a distribution proportional to f i and, we use the unbiased estimator 1 and n the ambient dimension. The spectrahedra marked with "*" are elliptopes, µ stands for the average volume and s for the standard deviation. We give a confidence interval with level of confidence α = 0.05, while t α,ν-1 is the critical value of student's distribution with ν -1 degrees of freedom. Points denotes the average number of points generated and T ime the average runtime in seconds. Finally, error stands for the relative error of the estimation and ?? means that the exact volume is unknown. For all the experiments we set the error parameter to e = 0.1.</p><formula xml:id="formula_40">N N j=1 f i-1 (x j ) f i (x j ) . To S -n-m µ ± t α,</formula><p>exploit Equation <ref type="bibr" target="#b11">(12)</ref> we have to (i) fix the sequence such that k is as small as possible, (ii) select f i 's such that we can compute efficiently each integral ratio, and (iii) compute P f k (x)dx. The best theoretical result of <ref type="bibr" target="#b17">[18]</ref> fixes a sequence of spherical Gaussians { f 0 , . . . , f k } with the mode being in S , parameterized by the variance. The overall complexity is O(n 3 ) membership calls. The implementation in <ref type="bibr" target="#b18">[19]</ref> is based on this algorithm but handles only convex polytopes in Hrepresentation as it requires the facets of the polytope and an inscribed ball to fix the sequence of Gaussians. Both the radius of the inscribed ball and the number of facets strongly influence the performance of the algorithm. So, it cannot handle efficiently the case of convex bodies without a facet description, e.g., zonotopes <ref type="bibr" target="#b18">[19]</ref>, as it results a big sequence of ratios that spoil practical efficiency.</p><p>Our approach is to consider the f i 's as a sequence of indicator functions of concentric balls centered in S , as in <ref type="bibr" target="#b22">[23]</ref>. In particular, let f k and f 0 be the indicator functions of rB n and RB n respectively, while rB n ⊆ S ⊆ RB n and S i = (2 (k-i)/n rB n ) ∩ S for i = 0, . . . , k. Thus, it suffices to compute vol(rB n ) and apply the following:</p><formula xml:id="formula_41">vol(S ) = vol(S k ) vol(S k-1 ) vol(S k ) • • • vol(S 0 ) vol(S 1 ) , k = ⌈n lg(R/r)⌉.<label>(13)</label></formula><p>Furthermore, we employ the annealing schedule from <ref type="bibr" target="#b13">[14]</ref> to minimize k, without computing neither an enclosed ball rB n nor an enclosing ball RB n of S . We do so by probabilistically bounding each ratio of Equation ( <ref type="formula" target="#formula_41">13</ref>) in an interval [r, r + δ], which is given as input. To approximate each ratio of volumes, we sample uniformly distributed points from S i and count points in S i-1 . We follow the experimental results of Section 4.2 and use W-Billard which mixes faster than W-HnR. Table <ref type="table" target="#tab_0">2</ref> reports the average volume, runtime, number of points generated for each S -n-m over 10 trials. We also compute a 95% confidence interval for the volume. For elliptopes since we know the exact volume <ref type="bibr" target="#b63">[64]</ref> we report also the relative error of the estimation. Notice that for all cases the extreme values of each interval imply an error ≤ 0.1, which was the requested error. For n = 40 just a few seconds suffice to approximate the volume and for n = 100 our implementation takes a few minutes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Expected value of a function</head><p>Randomized algorithms are commonly used for problems in robust control analysis to overcome the (worst case) hardness, especially in probabilistic robustness <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b12">13]</ref>. A central problem is to approximate the integral of a function over a spectrahedron, e.g. <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b53">54]</ref> and thus uniform sampling is of particular interest. To put our experiments into perspective, we present experiment up to n = 200, while in <ref type="bibr" target="#b11">[12]</ref> and <ref type="bibr" target="#b12">[13]</ref> they use only W-HnR for experiments in n ≤ 10.</p><p>Our goal is to compute the expected value of a function f : R n → [0, 1], with respect to the measure given by the uniform distribution π over S , i.e., I = S f (x)π(x)dx. A standard approach is the Monte Carlo method, which suggests to sample N independent samples from π. Then,</p><formula xml:id="formula_42">ÊN [ f ] = 1 N N i=1 f (x i )</formula><p>is an unbiased estimator for I. We employ the random walks of Section 3 to sample uniformly distributed points from S (i.e., W-HnR, W-CHnR, and W-Billard) and we experimentally compare their efficiency. It turns out that W-Billard mixes much faster and results to better accuracy (see Figures <ref type="figure" target="#fig_5">5</ref> &amp;<ref type="figure">6</ref>). This observation agrees with the experiments on the rate of convergence for W-HnR and W-Billard in <ref type="bibr" target="#b50">[51]</ref>. To come to a decisive conclusion we need to perform a more detailed practical study on the mixing time of these random walks; we leave this study as future work.</p><p>The variance of an estimator is a crucial as it bounds the approximation error. Using Chebyshev's inequality and <ref type="bibr" target="#b40">[41]</ref>, we have</p><formula xml:id="formula_43">Prob[| ÊN [ f ] -E[ f ]| ≤ ϵ] ≤ var( ÊN [ f ]) ϵ 2 ≤ 4M ϵ Nϵ 2 ,<label>(14)</label></formula><p>where M ϵ is the mixing time of the random walk one uses to sample "ϵ close" to the uniform distribution from S . Thus, for fixed N and ϵ, the smaller the mixing time of the random walk is, We estimate two functions f 1 , f 2 with E[ f 1 ] = 0.0993 and E[ f 2 ] = 0.5880 in dimension n = 50 and for various walk lengths. For each walk length we sample N = 200 points and we repeat M = 20 times. Then, for each N-set we compute 1 N N i=1 f (x i ) and we take the average and the standard deviation (st.d.) over M. Figures <ref type="figure" target="#fig_5">5,</ref> &amp;<ref type="figure"></ref> 6 illustrates these values, while the walk length increases. Notice that the st.d. is much smaller and the approximation more stable when W-Billard is used compared to both W-HnR and W-CHnR. As W-Billard mixes faster, we report in Table <ref type="table">3</ref> the average time our software needs to sample N = 200 points for various walk lengths for W-Billard in n = 100, 200. The average time to generate a point is ≈ 0.3 and ≈ 7.2 milliseconds respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Sampling from non-uniform distributions</head><p>The random walks of Section 3 open a promising avenue for approximating the optimal solution of a semidefinite program, that is min⟨c, x⟩, subject to x ∈ S .</p><p>(15) We parameterize the optimization algorithm in <ref type="bibr" target="#b30">[31]</ref> with the choice of random walk and demonstrate that its efficiency relies heavily on the sampling method. We perform experiments with W-HMC-r and W-HnR, as both can sample from the distribution the algorithm requires. Deterministic approximations to the optimal solutions of these tests, were acquired via the SDPA library <ref type="bibr" target="#b64">[65]</ref>.</p><p>The strategy to approximate the optimal solution x * of Equation ( <ref type="formula">15</ref>), is based on sampling from the Boltzmann distribution, i.e., π(x) ∝ e -cx/T , truncated to S . The scalar T , is called temperature. As the temperature T diminishes, the mass of π tends to concentrate around its mode, which is x * . Thus, one could obtain a uniform point using the algorithm in <ref type="bibr" target="#b41">[42]</ref>, and then use it as a starting point to sample from π 0 ∝ e -cx/T 0 , where T 0 = R and S ⊆ RB n . Then, the cooling schedule T i+1 = T i (1 -1/ √ n) guarantees that a sample from π i yields a good starting point for π i+1 . After O( √ n) steps the temperature will be low enough, to sample a point within distance ϵ from x * with high probability. In <ref type="bibr" target="#b30">[31]</ref>, they use only W-HnR. We also employ W-HMC-r. To sample from Boltzmann distributions with W-HMC-r, at each step, starting from p i and with momenta v i , the ODE of Equation ( <ref type="formula" target="#formula_33">10</ref>) becomes</p><formula xml:id="formula_44">d 2 dt 2 p(t) = - c T , d dt p(0) = v i , p(0) = p i . (<label>16</label></formula><formula xml:id="formula_45">)</formula><p>The solution of the ODE is the polynomial p(t) = -c 2T t 2 + v i t + p i , which is a parametric representation of a polynomial curve, see Equation <ref type="bibr" target="#b2">(3)</ref>.</p><p>In Table <ref type="table" target="#tab_1">4</ref> we follow the cooling schedule described, after setting T 0 ≈ R and sampling the first uniform point with W-Billard. We give the optimal solution as input and we stop dropping T when an error ϵ ≤ 0.05 is achieved. Even in the case when the walk length is set equal to one, W-HMC-r still converges to the optimal solution. To the best of our knowledge, this is the first 20 The average #iteration / runtime / failures over 10 generated S -n-m, to achieve relative error ϵ ≤ 0.05. The walk length is one for W-HMC-r and W 1 = 4 √ n and W 2 = 4n for W-HnR. With "failures" we count the number of times the method fails to converge. Also m is the dimension of the matrix in LMI and n is the dimension that S -n-m lies.</p><p>time that a randomized algorithm, which is based on random walks, is functional even when the walk length is set to one. On the other hand, we set the walk length of W-HnR O( √ n) or O(n) in our experiments. Notice that for the smaller walk length, its runtime decreases, but the method becomes unstable, as it sometimes fails to converge. For both cases its runtime is worse than that of W-HMC-r.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusion</head><p>We have presented a framework to analyze and implement the various primitive geometric operations need to perform random walks, and hence sample, from spectrahedra. These leads to algorithms for computing the volume, integrate, and solve semidefinite programs. We also introduce an efficient open-source implementation of our algorithms and we demonstrate its efficiency on various data sets.</p><formula xml:id="formula_46">Lemma Appendix A.2. Let F(x) = A 0 + x 1 A 1 + • • • + x n A n . Then ∂ det F(x) ∂x k = Trace (F(x) * A k )) .</formula><p>Proof. The function det F(x) is the composition of det A and A = F(x), so from the lemma in Appendix A.1 and the chain rule:</p><formula xml:id="formula_47">∂ det F(x) ∂x k = m i=1 m j=1 ∂ det F ∂F i j • ∂F i j ∂x k = m i=1 m j=1 c i j A k i j = Trace (F(x) * A k ) ,</formula><p>where A k i j the i j-th element of matrix A k . Lemma Appendix A.3 (Adjoint Matrix of A). Let A be a m × m matrix of rank r(A) = m -1. Then</p><formula xml:id="formula_48">A * = µ( A) vu ⊤ u ⊤ v ,</formula><p>where µ( A) is the product of the m -1 non-zero eigenvalues of A, and x and y satisfy = A ⊤ u = 0 (see chapter 3.2 in <ref type="bibr" target="#b44">[45]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Matrices of the Example</head><p>The spectrahedron was randomly generated as in <ref type="bibr" target="#b19">[20]</ref>. Due to space considerations, the entries of the matrices are rounded to the first decimal.   </p><formula xml:id="formula_49">A 0 =                       </formula><formula xml:id="formula_50">                         (B.1) A 1 =                          0.5 -0.</formula><formula xml:id="formula_51">                         (B.2) A 2 =                         <label>2</label></formula><formula xml:id="formula_52">                         (B.3)</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Algorithm 1 :</head><label>1</label><figDesc>membership(F, p) Input : An LMI F(x) ⪰ 0 representing a spectrahedron S and a point p ∈ R n . Output: true if p ∈ S , false otherwise. 1 λ min ← smallest eigenvalue of F( p); 2 if λ min ≥ 0 then return true ; 3 return false ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A spectrahedron S described by F(x) and a parameterized curve Φ. The point p 0 = Φ(0) lies in the interior of S , and the points p + = Φ(t + ) and p -= Φ(t -) on the boundary. Vector w is the surface normal of ∂S at p + and u is the direction of Φ at time t = t + .</figDesc><graphic coords="7,205.20,241.73,184.87,127.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Lemma 2 . 5 (</head><label>25</label><figDesc>Gradient of det(F(x))). Assume that x ∈ ∂S and the rank of the m ×</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The i-th step of the W-Billard [Algorithm 5] (left) and of the W-HMC-r [Algorithm 6] (right) random walks.</figDesc><graphic coords="11,137.70,140.99,152.15,113.39" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Samples from the uniform distribution with W-Billard (left) and from the Boltzmann distribution π(x) ∝ e -cx/T , where T = 1, c = [-0.09, 1] T , with W-HMC-r (right). The volume of this spectrahedron is 10.23.</figDesc><graphic coords="15,108.68,141.00,183.63,123.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The standard deviation of ÊN [ f ] over M = 20 trials, estimating 2 functions with E[ f 1 ] = 0.0993 and E[ f 2 ] = 0.588. For each walk length we sample N = 200 points and we repeat M = 20 times.</figDesc><graphic coords="18,125.49,140.99,344.30,191.13" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :Table 3 :</head><label>63</label><figDesc>Figure 6: The mean value of the estimator ÊN [ f ] over M = 20 trials, estimating two functions with E[ f 1 ] = 0.0993 and E[ f 2 ] = 0.588. For each walk length we sample N = 200 points and we repeat M = 20 times.</figDesc><graphic coords="19,125.49,140.99,344.30,191.13" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Sample a point from π(x) ∝ e -cx/T i and update the objective current best in each iteration, with T 0 ≈ diam(S ) and T i = T i-1 (1 -1/ √ n), i = 1, . . . 70. The walk length equals to one for W-HMC-r and 500 + 4n 2 = 10 500 for W-HnR.</figDesc><graphic coords="20,106.36,141.00,382.57,218.95" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 2 :</head><label>2</label><figDesc>(Volume of spectrahedra) For each S -n-m we run ν = 10 experiments, where m is the matrix dimension in LMI</figDesc><table><row><cell></cell><cell>ν-1</cell><cell>s √ ν</cell><cell>Points</cell><cell cols="2">T ime (sec) error</cell></row><row><cell>S -40-40</cell><cell cols="2">(1.34 ± 0.12)e-06</cell><cell>9975.2</cell><cell>6.7</cell><cell>??</cell></row><row><cell>S -60-60</cell><cell cols="2">(1.23 ± 0.11)e-20</cell><cell>20370.9</cell><cell>28.5</cell><cell>??</cell></row><row><cell>S -80-80</cell><cell cols="2">(4.24 ± 0.26)e-33</cell><cell>31539.1</cell><cell>124.4</cell><cell>??</cell></row><row><cell cols="3">S -100-100 (1.21 ± 0.10)e-51</cell><cell>52962.7</cell><cell>362.3</cell><cell>??</cell></row><row><cell>*S -28-8</cell><cell cols="2">14.31 ± 0.64</cell><cell>4547.4</cell><cell>10.2</cell><cell>0.05</cell></row><row><cell>*S -45-10</cell><cell cols="2">0.6334 ± 0.03</cell><cell>19558.1</cell><cell>56.2</cell><cell>0.07</cell></row><row><cell cols="4">*S -66-12 (1.73 ± 0.034)e-03 1.01e+05</cell><cell>324.2</cell><cell>0.07</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 4 :</head><label>4</label><figDesc>/ 9.9 / 2 61.9 / 17.1 / 0 S -50-50 29.2 / 12.7 / 0 251.2 / 22.3 / 3 72.3 / 44.6 / 0 S -60-60 32.8 / 24.32 / 0 272.7 / 41.1 / 3 81.5 / 98.9 / 0</figDesc><table><row><cell>S -n-m</cell><cell>W-HMC-r</cell><cell>W-HnR W 1</cell><cell>W-HnR W 2</cell></row><row><cell>S -30-30</cell><cell>20.1 / 2.9/ 0</cell><cell>184.3 / 3.4 / 1</cell><cell>52.1 / 5.2 / 0</cell></row><row><cell>S -40-40</cell><cell>24.6 / 7.9 / 0</cell><cell>223.3</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://github.com/GeomScale/volume_approximation/tree/v1.1.0-3</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://github.com/GeomScale/volume_approximation/tree/v1.1.0-3</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>The authors thank the anonymous reviewers for their various comments and suggestions. ET is partially supported by <rs type="funder">ANR</rs> <rs type="projectName">JCJC GALOP</rs> (<rs type="grantNumber">ANR-17-CE40-0009</rs>), the <rs type="funder">PGMO grant ALMA</rs>, and the <rs type="funder">PHC GRAPE</rs>. AC and IZE are members of the team <rs type="institution">AROMATH</rs> joint between <rs type="institution">INRIA Sophia-Antipolis</rs> and <rs type="institution">NKUA</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_jDwEAJf">
					<idno type="grant-number">ANR-17-CE40-0009</idno>
					<orgName type="project" subtype="full">JCJC GALOP</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Additional proofs</head><p>To prove lemma 2.5 we will need the following lemmas.</p><p>where c i j the cofactor of A i j .</p><p>Proof. From the Laplace expansion we have det A = m j=1 A i j c i j . Then, we notice that c 1 j , • • • , c m j are independent of A i j , and it holds ∂ det A ∂A i j = c i j .</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Reflection, Refraction, and Hamiltonian Monte Carlo</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Afshar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Domke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th NeurIPS</title>
		<meeting>28th NeurIPS<address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3007" to="3015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The polynomial eigenvalue problem is well conditioned for random inputs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Armentano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Beltrán</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIMAX</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="175" to="193" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The real polynomial eigenvalue problem is well conditioned on the average</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beltrán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kozhasov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Foundations of Computational Math</title>
		<imprint>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The polynomial eigenvalue problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Berhanu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>University of Manchester</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A conceptual introduction to Hamiltonian Monte Carlo</title>
		<author>
			<persName><forename type="first">M</forename><surname>Betancourt</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1701.02434</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Semidefinite optimization and convex algebraic geometry</title>
		<author>
			<persName><forename type="first">G</forename><surname>Blekherman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Parrilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MOS-SIAM series on optimization</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Mathematical Programming Society</publisher>
			<pubPlace>Philadelphia</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A survey of computational complexity results in systems and control</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Blondel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Tsitsiklis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automatica</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1249" to="1274" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Effective computational geometry for curves and surfaces</title>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Boissonnat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Teillaud</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Random spectrahedra</title>
		<author>
			<persName><forename type="first">P</forename><surname>Breiding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kozhasov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lerario</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Optimization</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="2608" to="2624" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Condition: the geometry of numerical algorithms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bürgisser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cucker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exact Volume Computation for Polytopes: A Practical Study</title>
		<author>
			<persName><forename type="first">B</forename><surname>Büeler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Enge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fukuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Polytopes -Combinatorics and Computation, DMV Seminar</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Kalai</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Ziegler</surname></persName>
		</editor>
		<meeting><address><addrLine>Basel</addrLine></address></meeting>
		<imprint>
			<publisher>Birkhäuser</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="131" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Random walks for probabilistic robustness</title>
		<author>
			<persName><forename type="first">G</forename><surname>Calafiore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CDC</title>
		<meeting>CDC</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="5316" to="5321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Robust convex programs: Randomized solutions and applications in control</title>
		<author>
			<persName><forename type="first">G</forename><surname>Calafiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Campi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CDC</title>
		<meeting>CDC</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="2423" to="2428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Chalkis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">Z</forename><surname>Emiris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Fisikopoulos</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1905.05494</idno>
		<title level="m">Practical volume estimation by a new annealing schedule for cooling convex bodies</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Sampling the feasible sets of SDPs and volume approximation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chalkis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Fisikopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Repouskos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tsigaridas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Communications in Computer Algebra</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note>poster version in ISSAC 2020</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A sampling algorithm based on the volumetric barrier</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dwivedi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Wainwright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><surname>Vaidya Walk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 55th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting><address><addrLine>Allerton)</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-10">Oct 2017</date>
			<biblScope unit="page" from="1220" to="1227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Hamiltonian Monte Carlo with boundary reflections, and application to polytope volume calculations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chevallier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cazals</surname></persName>
		</author>
		<idno>RR-9222</idno>
		<imprint>
			<date type="published" when="2018-11">Nov. 2018</date>
			<pubPlace>Sophia-Antipolis, France</pubPlace>
		</imprint>
		<respStmt>
			<orgName>INRIA</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Bypassing KLS: Gaussian cooling and an O * (n 3 ) volume algorithm</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cousins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vempala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symposium Theory of computation (STOC)</title>
		<meeting>ACM Symposium Theory of computation (STOC)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="539" to="548" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A practical volume algorithm</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cousins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vempala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Programming Computation</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<date type="published" when="2016-06">June 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A randomized cutting plane method with probabilistic geometric convergence</title>
		<author>
			<persName><forename type="first">F</forename><surname>Dabbene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shcherbakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">T</forename><surname>Polyak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Optimization</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="3185" to="3207" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Perturbation theory for homogeneous polynomial eigenvalue problems</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Dedieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tisseur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Linear algebra &amp; Appl</title>
		<imprint>
			<biblScope unit="volume">358</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="71" to="94" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A random polynomial-time algorithm for approximating the volume of convex bodies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Frieze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kannan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Practical polytope volume approximation</title>
		<author>
			<persName><forename type="first">I</forename><surname>Emiris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Fisikopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SoCG</title>
		<meeting>SoCG</meeting>
		<imprint>
			<date type="published" when="2014">2018. 2014</date>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="1" to="38" />
		</imprint>
	</monogr>
	<note>Prelim. version</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Separation bounds for polynomial systems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Emiris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mourrain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tsigaridas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="page" from="128" to="151" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Nonlinear computational geometry</title>
		<author>
			<persName><forename type="first">I</forename><surname>Emiris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sottile</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Theobald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Math &amp; its Applications</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">A</forename></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-10">Oct. 2010</date>
			<biblScope unit="volume">151</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Random sampling: Billiard walk algorithm</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gryazina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Polyak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European J. Operational Research</title>
		<imprint>
			<biblScope unit="volume">238</biblScope>
			<biblScope unit="page" from="11" to="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">G</forename><surname>Guennebaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jacob</surname></persName>
		</author>
		<ptr target="http://eigen.tuxfamily.org" />
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The nonlinear eigenvalue problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Güttel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tisseur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Numerica</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1" to="94" />
			<date type="published" when="2017-05">May 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Approximate volume and integration for basic semialgebraic sets</title>
		<author>
			<persName><forename type="first">D</forename><surname>Henrion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Lasserre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Savorgnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM review</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="722" to="743" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Symmetric linearizations for matrix polynomials</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J</forename><surname>Higham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Mackey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mackey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tisseur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Matrix Analysis and Applications</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="143" to="159" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Simulated annealing for convex optimization</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vempala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="253" to="266" />
			<date type="published" when="2006-02">Feb. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On the complexity of computing determinants</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kaltofen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Villard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational complexity</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="91" to="130" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Randomized algorithms for robust control analysis and synthesis have polynomial complexity</title>
		<author>
			<persName><forename type="first">P</forename><surname>Khargonekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tikku</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 35th IEEE Conference on Decision and Control</title>
		<meeting>35th IEEE Conference on Decision and Control</meeting>
		<imprint>
			<date type="published" when="1996-12">Dec 1996</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="3470" to="3475" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Convergence rates of moment-sum-of-squares hierarchies for volume approximation of semialgebraic sets</title>
		<author>
			<persName><forename type="first">M</forename><surname>Korda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Henrion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optimization Letters</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="435" to="442" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Computing the volume of compact semi-algebraic sets</title>
		<author>
			<persName><forename type="first">P</forename><surname>Lairez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mezzarobba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Safey El Din</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISSAC</title>
		<meeting>ISSAC</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Spherical Hamiltonian Monte Carlo for Constrained Target Distributions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shahbaba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JMLR workshop and Conf procs</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="629" to="637" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">On the complexity of the Lickteig-Roy subresultant algorithm</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lecerf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="page" from="243" to="268" />
			<date type="published" when="2019-05">May 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Algorithmic theory of odes and sampling from well-conditioned logconcave densities</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Vempala</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Convergence Rate of Riemannian Hamiltonian Monte Carlo and Faster Polytope Volume Computation</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vempala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. Theory of Computation (STOC)</title>
		<meeting>ACM Symp. Theory of Computation (STOC)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Sylvester-Habicht Sequences and Fast Cauchy Index Computation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lickteig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-F</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="315" to="341" />
			<date type="published" when="2001-03">Mar. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Random walks and an O * (n 5 ) volume algorithm for convex bodies</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lovász</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Simonovits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Random Structures &amp; Algorithms</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1" to="50" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Simulated annealing in convex bodies and an O * (n 4 ) volume algorithm</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lovász</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vempala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Foundation of Comp. Science (FOCS)</title>
		<meeting>IEEE Symp. Foundation of Comp. Science (FOCS)</meeting>
		<imprint>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="page" from="650" to="659" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Fast algorithms for logconcave functions: Sampling, rounding, integration and optimization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lovasz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vempala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Foundation of Comp. Science (FOCS)</title>
		<meeting>IEEE Symp. Foundation of Comp. Science (FOCS)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="57" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Vector spaces of linearizations for matrix polynomials</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Mackey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mackey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mehl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mehrmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Matrix Analysis and Applications</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="971" to="1004" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Matrix Differential Calculus with Applications in Statistics and Econometrics (Revised Edition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Magnus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Neudecker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>John Wiley &amp; Sons Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Faster polytope rounding, sampling, and volume computation via a sub-linear ball walk</title>
		<author>
			<persName><forename type="first">O</forename><surname>Mangoubi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Vishnoi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Foundation of Comp. Science (FOCS)</title>
		<meeting>IEEE Symp. Foundation of Comp. Science (FOCS)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1338" to="1357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Deterministic computation of the characteristic polynomial in the time of matrix multiplication</title>
		<author>
			<persName><forename type="first">V</forename><surname>Neiger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pernet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Complexity</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Exact Hamiltonian Monte Carlo for Truncated Multivariate Gaussians</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pakman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Paninski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Computational &amp; Graphical Statistics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="518" to="542" />
			<date type="published" when="2014-04">Apr. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Univariate polynomials: nearly optimal algorithms for numerical factorization and root-finding</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">Y</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="701" to="733" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Nearly optimal refinement of real roots of a univariate polynomial</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">Y</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">P</forename><surname>Tsigaridas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="page" from="181" to="204" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Billiard walk -a new sampling algorithm for control and optimization</title>
		<author>
			<persName><forename type="first">B</forename><surname>Polyak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gryazina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IFAC Proceedings Volumes</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="6123" to="6128" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The D-decomposition technique for linear matrix inequalities</title>
		<author>
			<persName><forename type="first">B</forename><surname>Polyak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shcherbakov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automation and Remote Control</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="1847" to="1861" />
			<date type="published" when="2006">11 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Some geometric results in semidefinite programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ramana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goldman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Global Optimization</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A monte carlo approach to the analysis of control system robustness</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Stengel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automatica</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="229" to="236" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">The fundamental theorem of algebra in terms of computational complexity</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schönhage</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<pubPlace>Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. of Tübingen</orgName>
		</respStmt>
	</monogr>
	<note>Manuscript.</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Efficient Monte Carlo procedures for generating points uniformly distributed over bounded regions</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1296" to="1308" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">A header-only C++ library for large scale eigenvalue problems</title>
		<author>
			<persName><surname>Spectra</surname></persName>
		</author>
		<ptr target="https://spectralib.org,2020.v0.9." />
		<imprint>
			<date>0</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Geometry and billiards. Student mathematical library</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tabachnikov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>American Mathematical Society</publisher>
			<pubPlace>Providence, RI</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Exploiting Sparsity for Semi-Algebraic Set Volume Computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tacchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Weisser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-B</forename><surname>Lasserre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Henrion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations of Computational Mathematics</title>
		<imprint>
			<date type="published" when="2021-03">Mar. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Randomized algorithms for analysis and control of uncertain systems: with applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tempo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Calafiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dabbene</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title level="m" type="main">Numerical linear algebra</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Trefethen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bau</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>SIAM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Compact rational Krylov methods for nonlinear eigenvalue problems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Beeumen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Meerbergen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Michiels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Matrix Analysis and Applications</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="820" to="838" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Geometric random walks: A survey</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vempala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorial &amp; Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Efficient estimation of covariance selection models</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kohn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biometrika</title>
		<imprint>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="809" to="830" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Implementation and evaluation of sdpa 6.0</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yamashita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fujisawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kojima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optimization Methods &amp; Software</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="491" to="505" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">Accurate solutions of polynomial eigenvalue problems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">I</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-H</forename><surname>Lim</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.01301</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
