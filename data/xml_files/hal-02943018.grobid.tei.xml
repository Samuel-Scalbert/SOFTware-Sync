<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Survey on the Fine-grained Complexity of Constraint Satisfaction Problems Based on Partial Polymorphisms Dedicated to the memory of</title>
				<funder ref="#_dAsfNrn">
					<orgName type="full">Swedish Research Council (VR)</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Professor</roleName><forename type="first">Ivo</forename><surname>Rosenberg</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Miguel</forename><surname>Couceiro</surname></persName>
							<email>miguel.couceiro@loria@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université de Lorraine</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria Nancy G.E</orgName>
								<orgName type="institution" key="instit4">LORIA</orgName>
								<address>
									<postCode>F-54000</postCode>
									<settlement>Nancy</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lucien</forename><surname>Haddad</surname></persName>
							<email>haddad-l@rmc.ca</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Mathematics &amp; Computer Science</orgName>
								<orgName type="institution">Royal Military College of Canada</orgName>
								<address>
									<settlement>Kingston</settlement>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Victor</forename><surname>Lagerkvist</surname></persName>
							<email>victor.lagerkvist@liu.se</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">Linköping University</orgName>
								<address>
									<settlement>Linköping</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Survey on the Fine-grained Complexity of Constraint Satisfaction Problems Based on Partial Polymorphisms Dedicated to the memory of</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D31255772BB64FA270314DE81839620E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-03-07T09:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Constraint satisfaction problems (CSPs) are combinatorial problems with strong ties to universal algebra and clone theory. The recently proved CSP dichotomy theorem states that each finitedomain CSP is either solvable in polynomial time, or that it is NP-complete. However, among the intractable CSPs there is a seemingly large variance in how fast they can be solved by exponential-time algorithms, which cannot be explained by the classical algebraic approach based on polymorphisms. In this contribution we will survey an alternative approach based on partial polymorphisms, which is useful for studying the fine-grained complexity of NP-complete CSPs. Moreover, we will state and discuss some challenging open problems in this research field.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Partial Operations</head><p>Let k ≥ 2 be an integer and let k denote a k-element set. Without loss of generality we assume that k := {0, . . . , k -1}. For a positive integer n, an n-ary partial operation on k is a map f : dom(f ) → k where dom(f ) is a subset of k n , called the domain of f . Let Par (n) (k) denote the set of all n-ary partial operations on k and let</p><formula xml:id="formula_0">Par(k) := n≥1 Par (n) (k).</formula><p>An n-ary partial operation g is said to be a total operation if dom(g) = k n , and we let Op (n) (k) be the set of all n-ary total operations on k and Op(k) := n≥1 Op (n) (k). For every positive integer n and each 1 ≤ i ≤ n, let e n i denote the n-ary i-th projection defined by e n i (a 1 , . . . , a n ) = a i for all (a 1 , . . . , a n ) ∈ k n . Furthermore, let J k := {e n i | 1 ≤ i ≤ n, n ∈ N \ {0}} be the set of all (total) projections. Partial operations on k are composed in a natural way. For additional details we refer the reader to Lau <ref type="bibr" target="#b48">[49]</ref>. Definition 1. A clone is a composition closed subset of Op(k) containing J k , and a partial clone on k is a composition closed subset of Par(k) containing J k . A partial clone is said to be strong if it is closed under taking suboperations .</p><p>It is well known that a partial clone C is strong if and only if Str(J k ) ⊆ C (see, e.g., <ref type="bibr">Lemma 2.11</ref> in Haddad and Börner <ref type="bibr" target="#b10">[11]</ref>). The set of (partial) clones on k forms a lattice L Op(k) (L Par(k) ) under inclusion, in which the infimum is the set-theoretical intersection. It is then known that the cardinality of L Op(k) (L Par(k) ) equals the continuum for k ≥ 3 (k ≥ 2), but that L Str(Op(2)) , Post's lattice, is countably infinite <ref type="bibr" target="#b51">[52]</ref>. Similarly, the set of strong partial clones on k also forms a lattice L Str(Par(k)) , which is a sublattice of L Par(k) whose cardinality also equals the continuum for each k ≥ 2. By definition, J k and Str(J k ) are the least elements of L Par(k) and L Str(Par(k)) , respectively. For further background see, e.g., <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23]</ref>. For F ⊆ Par(k), let [F ] s denote the intersection of all strong partial clones on k containing F . Similarly, for F ⊆ Op(k), let [F ] be the intersection of all clones on k containing F , and in both cases we write [f ] or [f ] s when F = {f } is singleton. Say that a strong partial clone C over k is finitely generated if there exists a finite set F ⊆ Par(k) such that [F ] s = C, and is said to be infinitely generated otherwise.</p><p>For f, g ∈ Par(k), g is a suboperation of f , g ≤ f , if g = f | dom(g) . We denote the closure of F ⊆ Par(k) under taking suboperations by Str(F ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Relations</head><p>An h-ary relation R over k is a subset of k h , and we write ar(R) = h to denote its arity, and Rel k for the set of all relations over k. It is well known that strong partial clones are exactly those partial clones that are determined by relations in the following way. Let h, n ≥ 1 be integers, and let R be an h-ary relation on k. An n-ary partial operation f on k is said to preserve R if for every h × n matrix M = [M ij ] whose columns M * j ∈ R, and whose rows M i * ∈ dom(f ), the h-tuple (f (M 1 * ), . . . , f (M h * )) ∈ R. Note that if there is no h × n matrix M = [M ij ] whose columns M * j ∈ R and whose rows M i * ∈ dom(f ), then f preserves R. It is not difficult to see that pPol(R) := {f ∈ Par(k) | f preserves R} is a strong partial clone, called the partial clone determined by the relation R. Similarly, if Γ is a set of relations over k we write pPol(Γ) for the set R∈Γ pPol(R). In the total case we similarly write Pol(R) for the set of total polymorphisms of R and Pol(Γ) if Γ is a set of relations.</p><p>The fact that (strong partial) clones can be defined exclusively via relations suggests a deeper relationship between operations and relations. In fact, for each clone Pol(Γ) (respectively, strong partial clone pPol(Γ)) there exists a corresponding set of relations that can be defined through Γ by a suitable closure operator. First, say that an n-ary relation R has a primitive positive definition (pp-definition) over Γ ⊆ Rel k if R is the set of models of a firstorder formula (with equality) ϕ(x 1 , . . . , x n ) consisting only of existential quantification and conjunction over positive atoms from Γ. In symbols we denote such a definition by</p><formula xml:id="formula_1">R(x 1 , . . . , x n ) ≡ ϕ(x 1 , . . . , x n ), where ϕ(x 1 , . . . , x n ) is of the form ∃x n+1 , . . . , x n+n : R 1 (x 1 ) ∧ . . . ∧ R m (x m )</formula><p>and where each x i is a tuple of variables over x 1 , . . . , x n+n , and each R i ∈ Γ ∪ {(x, x) | x ∈ k}. In addition, we say that R has a quantifier-free primitive positive definition (qfpp-definition) over Γ if R has a pp-definition over Γ where n = 0, i.e., a pp-definition without any existentially quantified variables. These two definitions naturally induce two closure operators over relations, in the following sense.</p><formula xml:id="formula_2">Definition 2. A set Γ ⊆ Rel k is said to be a relational clone, or a co-clone, if 1) R ∈ Γ for each R pp-definable over Γ, and 2) ∅ ∈ Γ.</formula><p>Similarly, a set Γ ⊆ Rel k is called a weak co-clone, or a weak system, if 1) R ∈ Γ for each R qfpp-definable over Γ, and 2) ∅ ∈ Γ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Galois Connections</head><p>Clones and strong partial clones are related to co-clones and weak systems, respectively, in following way. The first important observation is that the set Inv(F ) of all relations preserved by each (partial) operation in F ⊆ Par(k) is (1) a co-clone if each operation in F is total, and (2) a weak system otherwise. Moreover, it is well known that Inv(Pol(Γ)), (respectively Inv(pPol(Γ))) is the smallest co-clone (respectively weak system) over k containing Γ. Thus, the operators Inv(•) and Pol(•) constitute a Galois connection between clones and co-clones, whereas Inv(•) and pPol(•) constitute a Galois connection between strong partial clones and weak systems. One practical consequence of Theorem 3 is that properties of clones can be translated into properties of co-clones, and vice versa. Moreover, due to the antitone nature of Galois connections, one of these viewpoints may be substantially simpler than the other one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">CONSTRAINT SATISFACTION PROBLEMS</head><p>In a constraint satisfaction problem (CSP) the objective is to assign values to variables subjected to a set of constraints deciding admissible assignments. Typically, a CSP is formulated as the decision problem of determining whether there exists an assignment respecting all constraints. For the sake of selfcontainment, we follow the predominant definition of CSPs in computer science literature <ref type="bibr" target="#b54">[55]</ref>. Definition 4. A constraint satisfaction problem (CSP) over a set k is defined as a decision problem of the following form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INSTANCE:</head><p>A tuple (V, C) where V is a finite set, and C a finite set of the form (R i , t i ), i ∈ I, where R i ∈ Rel k and t i ∈ V ar (Ri) . QUESTION: Is there a function f :</p><formula xml:id="formula_3">V → k such that (f (x 1 i ), . . . , f (x ar(Ri) i )) ∈ R i for each (R i , (x 1 i , . . . , x ar(Ri) i</formula><p>)) ∈ C? The set k is called the domain of the CSP (not to be confused with the domain of a partial operation). If k = 2, then k is said to be Boolean. The members of V are referred to as variables and are usually denoted by x, v, or, if necessary, by using suitable subscripts. A tuple (R i , t i ) ∈ C is called a constraint, and we typically write R(t i ) instead of (R i , t i ). The function f , if it exists, is called a solution, a model, or a satisfying assignment.</p><p>CSPs can be further specified by fixing a set of relations Γ, called a constraint language. This class of problems is then denoted by CSP(Γ) and it is restricted to instances (V, C) where R i ∈ Γ for each constraint (R i , t i ) ∈ C. If Γ contains only Boolean relations (and thus k = 2), then CSP(Γ) can be viewed as a class of satisfiability problems, and it is usually denoted by SAT(Γ). Note that we have not yet specified how instances of CSP(Γ) are represented. If Γ is finite then the particular representation is not important, but if Γ is infinite the precise representation may become relevant. Here, we take a simple approach and assume that each relation is represented by a list of tuples. This is certainly not the only possible choice, and there exist languages where this representation scheme can be exponentially larger than a simpler encoding. For example, the relation corresponding to a clause (x 1 ∨ . . . ∨ x n ) of length n ≥ 1 can naively be represented as a list of 2 n -1 tuples, but can succinctly be represented by a single tuple encoding the forbidden truth assignment.</p><p>Observe that if we associate a constraint language Γ over a domain D to a relational signature τ , then Γ can be thought of as a relational structure Γ τ . In this way, an instance ({v 1 , . . . , v n }, C) of CSP(Γ) can be viewed as an existentially quantified τ -formula ∃v 1 , . . . , v n :</p><formula xml:id="formula_4">(Ri,ti)∈C R i (t i ),</formula><p>and the question is then whether this τ -formula has a model.</p><p>It is also possible to reformulate CSP(Γ) as a homomorphism problem since an instance I of CSP(Γ) can be seen as a τ -structure I, and where the question is then to decide whether there exists a homomorphism between I and Γ τ .</p><p>Example 1. Let R 1/3 = {(0, 0, 1), (0, 1, 0), (1, 0, 0)}. Then SAT({R 1/3 }) can be seen as an alternative formulation of the monotone 1-in-3-SAT problem which is well-known to be NP-complete. By choosing a suitable Boolean Γ, a large range of satisfiability problems can be represented as a CSP(Γ) problem. For example, for each k ≥ 1 let Γ k SAT be the set of relations of the form {0, 1} k \ {t} for a single k-ary Boolean tuple t. Then SAT(Γ k SAT ) can be verified to be an alternative formulation of k-SAT which is NP-complete for k ≥ 3. It may also be interesting to note that if we let Γ SAT = k≥1 Γ k SAT then the only difference between SAT(Γ SAT ) and the satisfiability problem in conjunctive normal form, CNF-SAT, is the preferred representation scheme, since a clause in the latter problem is traditionally represented by a single falsifying truth assignment, rather than by the list of all satisfying truth assignments.</p><p>Example 2. Let us also consider a few non-Boolean examples. One of the prototypical examples of a CSP is the k-COLOURING problem: given an undirected graph (V, E), can (V, E) be coloured using at most k colours? To formulate this problem as a CSP we take the relation</p><formula xml:id="formula_5">R = k = {(x, y) ∈ k 2 | x = y} and for each (x, y) ∈ E introduce a constraint R = k (x, y).</formula><p>It is also easy to find examples of tractable CSPs, i.e., CSPs solvable in polynomial time. One such example is systems of linear equations x 1 + . . . + x n = 0 (mod k) which can be solved in polynomial time using Gaussian elimination. As we will see in Section 3 this discrepancy in complexity between tractable and NP-complete CSPs can be explained using algebraic methods.</p><p>Although this survey mainly focuses on finite-domain CSPs, a substantial amount of research is dedicated towards infinite-domain CSPs. This is especially true in artificial intelligence where many classical problems are intrinsically linked to constraints over infinite domains. Some examples include spatial and temporal reasoning problems such as ALLEN'S INTERVAL ALGEBRA, THE REGION CONNECTION CALCULUS, and the RECTANGLE ALGEBRA (cf. the surveys <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b31">32]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">POLYMORPHISMS AND THE COMPLEXITY OF CSPS</head><p>Feder &amp; Vardi conjectured that CSP(Γ) is either tractable or NP-complete <ref type="bibr" target="#b32">[33]</ref>. This conjecture is usually referred to as the CSP dichotomy conjecture. It was then realized that several classical algorithms that run in polynomial time, e.g., Gaussian elimination and k-consistency, in a uniform manner could be explained by the presence of certain polymorphisms of Γ <ref type="bibr" target="#b37">[38]</ref>. More generally, Jeavons proved the following reducibility result, usually interpreted as "the polymorphisms of Γ determine the complexity of CSP(Γ) up to polynomial time reductions".</p><p>Theorem 5 <ref type="bibr">([37]</ref>). Let Γ and ∆ be two finite constraint languages over k. If Pol(Γ) ⊆ Pol(∆), then CSP(∆) is polynomial-time many-one reducible to CSP(Γ).</p><p>Proof. From Theorem 3 the condition Pol(Γ) ⊆ Pol(∆) is equivalent to the condition that ∆ ⊆ Inv(Pol(Γ)). Hence, each relation in ∆ is pp-definable over Γ. The reduction from CSP(∆) to CSP(Γ) then follows as a classical "gadget reduction" where each constraint in an instance (V, C) of CSP(∆) is replaced by the set of constraints corresponding to a pp-definition over Γ, and any two variables occuring in an equality constraint are identified. This can be accomplished in polynomial time with respect to |C| and |V | since 1) each pp-definition of R ∈ ∆ can be precomputed and stored in a table whose size depends only on the two finite sets Γ and ∆,</p><p>2) the identification of variables is a special case of ST-CONNECTIVITY which is solvable using only logarithmic space <ref type="bibr" target="#b52">[53]</ref>, and</p><formula xml:id="formula_6">3) ∆ is finite and thus |C| is polynomially bounded in |V |.</formula><p>The proof can then be completed by observing that the resulting instance of CSP(Γ) may contain up to |C| • m fresh variables, for a constant m depending on Γ and ∆, since existentially quantified variables in pp-definitions correspond to the introduction of fresh variables. Now, to obtain a dichotomy for CSP(Γ) over k one would, in principle, need to consider all operations over k and to determine which combinations of operations that result in tractable CSPs. However, such a process turns out to be unecessary, since the classical complexity of CSP(Γ) only depends on the identities or the strong Maltsev conditions, satisfied by the polymorphisms of Γ <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b1">2]</ref>. In technical terms, this means that the complexity of CSP(Γ) depends only on the variety to which Pol(Γ) belongs to. For example, if Pol(Γ) contains a Maltsev operation satisfying the identities m(x, x, y) ≈ y, m(x, y, y) ≈ x, then CSP(Γ) is tractable since it can be solved by the simple algorithm for Maltsev constraints <ref type="bibr" target="#b16">[17]</ref>. The main advantage of this observation is that it suffices to describe all identities resulting in tractable CSPs rather than all concrete operations. This approach recently culminated in the following dichotomy theorem.</p><p>Theorem 6 ( <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b62">63]</ref>). Let Γ be a constraint language over k. Then CSP(Γ) is either tractable or NP-complete.</p><p>Although simple to state, Theorem 6 is the result of decades of intense research, and was known to hold for several important, special cases <ref type="bibr" target="#b55">[56,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14]</ref> before the main result could be proven. For additional details concerning the classification project of CSP and the algebraic approach based on strong Maltsev conditions, see e.g. the survey by Barto <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PARTIAL POLYMORPHISMS AND THE FINE-GRAINED COM-PLEXITY OF CSPS</head><p>We begin this section by outlining how partial polymorphisms can be useful for (classical) complexity classifications where the standard algebraic approach based on polymorphisms falls short. We then discuss the rather vague term "fine-grained complexity" in relationship to CSPs in Section 4.2, and in Section 4.3 describe how the algebraic approach based on partial polymorphisms can be used to study this question in greater detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Weak Bases and Classical Complexity</head><p>Before we describe how partial polymorphisms can be used to study the fine-grained complexity of CSPs, we take a slight detour in order to outline a related application, which preceded fine-grained complexity in time. To understand this motivation it is important to realise that many CSP-related problems have been classified during the last decades as well, and in almost all cases using a very similar algebraic toolbox. Some promiment examples are counting CSPs <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b26">27]</ref>, min-ones <ref type="bibr" target="#b40">[41]</ref>, and propositional abduction <ref type="bibr" target="#b29">[30]</ref>.</p><p>For further details and additional examples, see e.g. the survey by Creignou &amp; Vollmer <ref type="bibr" target="#b28">[29]</ref>.</p><p>In short, such complexity dichotomies are usually proved by first establishing a counter part to Theorem 5, and for a set of operations F either <ref type="bibr" target="#b0">(1)</ref> prove that Inv(F ) results in a tractable problem, or <ref type="bibr" target="#b1">(2)</ref> show that there exists Γ ⊆ Inv(F ) resulting in an intractable problem (typically NP-hard or co-NPhard). Hence, instead of considering arbitrary constraint languages we for each clone only have to consider a fixed constraint language. Informally, this strategy works for all problems parameterised by constraint languages where the introduction of fresh variables (stemming from existentially quantified variables in pp-definitions) does not affect the existence of a solution. However, what if this is not the case? This question motivated Schnoor &amp; Schnoor <ref type="bibr" target="#b57">[58]</ref> to investigate a connection between partial polymorphisms and the complexity of CSP-related problems which had been difficult to classify by existing tools.</p><p>Example 3. CSP(Γ) is sometimes said to be a priori compatible with polymorphisms due to Theorem 5. In contrast, there exist problems proven to be a posteriori compatible with polymorphisms, in the sense that Pol(Γ) determines whether the problem is tractable or intractable, but where an analogue of Theorem 5 cannot be proven. One such example is the problem of finding a surjective model of a SAT(Γ) instance (SUR-SAT(Γ)), which is NP-complete if Pol(Γ) is essentially unary † and tractable otherwise <ref type="bibr" target="#b27">[28]</ref>. Curiously, almost all CSP-like problems studied in the literature turn out to be either a priori or a posteriori compatible with polymorphisms, and only a handful of concrete counter examples exist, e.g., enumerating models of CSP(Γ) with polynomial delay <ref type="bibr" target="#b56">[57]</ref>, the inverse satisfiability problem over infinite constraint languages <ref type="bibr" target="#b43">[44]</ref>, and the maximum satisfiability problem <ref type="bibr" target="#b25">[26]</ref>.</p><p>Problems that are not a priori compatible with polymorphisms may instead be compatible with partial polymorphisms. It is, for example, straightforward to prove that if pPol(Γ) ⊆ pPol(∆) then SUR-SAT(∆) is polynomial-time many-one reducible to SUR-SAT(Γ). Unfortunately, the usefulness of this observation remains limited because the lattice of Boolean strong partial clones L Str(Op(2)) is still not fully known. However, Schnoor &amp; Schnoor <ref type="bibr" target="#b57">[58]</ref> realized that for many classification purposes, there is typically no need to consider the whole lattice L Str(Op(2)) , but only a small fragment corresponding to weak bases. Definition 7. <ref type="bibr" target="#b57">[58]</ref> Let C = Pol(Γ) be a clone over k where Γ is finite. A set of relations Γ w ⊆ Rel k is said to be a weak base of Inv(C) if ( <ref type="formula">1</ref>)</p><formula xml:id="formula_7">Pol(Γ w ) = C and (2) pPol(∆) ⊆ pPol(Γ w ) for each set ∆ ⊆ Rel k such that Pol(∆) = C.</formula><p>Example 4. Let us again consider SUR-SAT(Γ) and assume that we are given a weak base Γ w of a co-clone Inv(C). If we can prove that SUR-SAT(Γ w ) is NP-complete, then NP-completeness also carries over to every Γ such that Pol(Γ) = C. Hence, equipped with a weak base of each Boolean co-clone, we in practice only need to consider Post's lattice <ref type="bibr" target="#b51">[52]</ref> rather than L Str(Op(2)) .</p><p>Schnoor &amp; Schnoor <ref type="bibr" target="#b57">[58]</ref> also described a procedure for constructing weak bases for co-clones satisfying the preconditions in Definition 7, which was leveraged by Lagerkvist to provide a list of weak bases for all Boolean coclones <ref type="bibr" target="#b41">[42]</ref>, whose inclusion structure was later completely determined <ref type="bibr" target="#b44">[45]</ref>. We will not describe the method for constructing weak bases in detail, but remark that it is based on the observation that the algebra whose universe consists of all n-ary operations in C can be viewed as a relation R, with the property that any partial operation not preserving R can be extended to a total operation. This construction has been referred to as the n-generated free algebra <ref type="bibr" target="#b0">[1]</ref>, or the n-th graphic <ref type="bibr" target="#b50">[51]</ref>. Using a similar strategy to that used in Example 4, weak bases have been used to obtain complexity dichotomies for several classes of Boolean CSP-like problems incompatible with polymorphisms <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b58">59</ref>].</p><p>Example 5. Behrisch et al. <ref type="bibr" target="#b4">[5]</ref> considered several problems, e.g., nearest solution (NSOL), nearest other solution (NOSOL), and minimum solution distance (MSD), all parameterised by Boolean constraint languages. The optimisation variants of these problems may be defined as follows.</p><p>1) NSOL(Γ): given a SAT(Γ) instance I and a function f : V → 2, compute a satisfying assignment to I with minimal Hamming distance from f .</p><p>2) NOSOL(Γ): given a SAT(Γ) instance I and a satisfying assignment to I, compute a satisfying assignment to I with minimal Hamming distance from f .</p><p>3) MSD(Γ): given a SAT(Γ) instance I, compute two satisfying assignments to I with minimal Hamming distance.</p><p>Among these problems only NSOL is a priori compatible with polymorphisms in the sense discussed in Example 3, but with a non-trivial reduction, while NOSOL and MSD can be studied with partial polymorphisms via the weak bases approach. For instance, if Pol(Γ) = [{f ¬ }], where f ¬ (x) = 1 -x, then it is sufficient to show that NOSOL({R}) does not admit a polynomial-time approximation scheme (unless P = NP) for the weak base R of Inv({f ¬ }) provided by Lagerkvist <ref type="bibr" target="#b41">[42]</ref>, instead of having to prove this for every possible choice of Γ ⊆ Rel 2 where Pol(Γ) = [{f ¬ }].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Fine-Grained Complexity</head><p>Recall from Section 3 that polymorphisms are useful for studying the classical complexity of CSPs up to polynomial-time reductions. However, there are reasons to believe that, in practice, even NP-complete problems can exhibit a striking difference in complexity, and that it may be disadvantageous to group them together under the guise of polynomial-time reductions. For example, SAT({R 1/3 }) from Example 1, is known to be solvable in O(1.0984 n ) time, where n denotes the number of variables <ref type="bibr" target="#b61">[62]</ref>, whereas it is not known whether CNF-SAT is solvable in O(c n ) time for c &lt; 2. This phenomena is not restricted to CSPs: for example, van Rooij et al. <ref type="bibr" target="#b7">[8]</ref> proved that the PARTITION INTO TRIANGLES problem restricted to graphs of maximum degree 4 can be solved in O(1.0222 n ) time despite being NP-complete.</p><p>Our main concern in this survey paper is thus to study the complexity of NP-complete CSPs with regards to O(c n ) time complexity. To make this question more precise we begin with the following definition.</p><formula xml:id="formula_8">Definition 8. Let k ≥ 2. For Γ ⊆ Rel k , set T(Γ) = inf{c | CSP(Γ) is solvable in time 2 cn },</formula><p>where n is the number of variables in an instance of CSP(Γ).</p><p>Note that CSP(Γ) may be solvable in O(2 (c+ε)n ) time for every ε &gt; 0 despite not being solvable in O(2 cn ) time, thus showing that the use of infimum in Definition 8 is necessary. If T(Γ) = 0, then CSP(Γ) is said to be solvable in subexponential time. It is important to observe that no concrete value of T(Γ) is known when CSP(Γ) is NP-complete, but that a large number of upper bounds of the form T(Γ) ≤ c are known for concrete constraint languages Γ. For example, as already mentioned, T({R 1/3 }) ≤ log 2 (1.0984) since SAT({R 1/3 }) is solvable in O(1.0984 n ) time, and if we take the relation R = k from Example 2 then T({R =2 } = 0 (since 2-COLOURING is in P), and for each k ≥ 3 it is known that T({R = k }) ≤ 1 <ref type="bibr" target="#b5">[6]</ref>.</p><p>To study the function T and its connection to partial polymorphisms, we will make use the following conjecture, which is of central importance in current research on fine-grained complexity and lower bounds. Definition 9. The exponential-time hypothesis (ETH) <ref type="bibr" target="#b34">[35]</ref> conjectures that T(Γ 3 SAT ) &gt; 0.</p><p>In other words, the ETH states that there exists a c &gt; 0 such that 3-SAT is not solvable in O(2 cn ) time, i.e., not in subexponential time. Although not immediate from Definition 9, the ETH is also known to imply that the sequence T(Γ 3 SAT ), T(Γ 4 SAT ), . . . , increases infinitely often, i.e., that for every k there exists k &gt; k such that T(Γ k SAT ) &lt; T(Γ k SAT ) <ref type="bibr" target="#b34">[35]</ref>. It is tempting to also conjecture that the limit of the sequence T(Γ 3 SAT ), T(Γ 4 SAT ), . . . equals 1. This conjecture is known as the strong exponential-time hypothesis (SETH) <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b34">35]</ref>. Under this conjecture, the unrestricted SAT problem cannot be solved in O(2 cn ) time for any c &lt; 1.</p><p>The ETH and the SETH are important conjectures also when studying fine-grained complexity from an algebraic point of view, since they represent the best possible bounds that one should realistically aim for. This is similar to how one should not hope to achieve a polynomial-time algorithm for an NP-hard problems if P = NP. Indeed, it is then known that we cannot achieve subexponential-time algorithms for NP-complete finite-domain CSPs without violating the ETH. Subexponentiality can also be ruled out for certain classes of structurally restricted CSPs <ref type="bibr" target="#b30">[31]</ref>, but we refrain from formally stating these results since the current focus is on constraint language restrictions. Let us also remark that CSP(Γ) for Γ ⊆ Rel k is always solvable in O(k n ) time by simply enumerating all possible assignments over k. Hence,</p><formula xml:id="formula_9">T(Γ) ≤ log 2 (k) for every Γ ⊆ Rel k . It is also known that if Γ ⊂ Rel k is finite then CSP(Γ) is solvable in O(c n ) time for some c &lt; k [61], implying that T(Γ) &lt; log 2 (k).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">An Algebraic Approach Based on Partial Polymorphisms</head><p>We are now ready to present the link between partial polymorphisms and the function T, which allows us to study the fine-grained complexity of CSPs using partial polymorphisms.</p><p>Theorem 11 <ref type="bibr">([39]</ref>). Let Γ and ∆ be two finite sets of relations over k. If pPol(Γ) ⊆ pPol(∆), then T(∆) ≤ T(Γ).</p><p>Proof. By Theorem 3, this result can be proved rather explicitly: given an instance (V, C) of CSP(∆) each constraint in C can be rewritten as a set of constraints over Γ ∪ {{(x, x) | x ∈ k}} without introducing any fresh variables, and the same techniques that were used in the proof of Theorem 5 can then be employed to complete the reduction in polynomial time. Hence, Theorem 11 can be restated in a slightly stronger version without making use of the function T, but for our purposes the above statement is sufficient. Also note that Theorem 11 is valid even if CSP(Γ) and CSP(∆) are both solvable in polynomial time since in this case we have that T(Γ) = T(∆) = 0. Now, let C be a clone such that Pol(Γ) = C, and suppose that CSP(Γ) is NP-complete. Theorem 11 then offers an algebraic method to analyse T(Γ) by studying the properties of I Str (C) := {pPol(Γ) | Pol(Γ) = C}. For example, if I Str (C) is finite, then the fine-grained complexity of CSP(Γ) would fall into a finite number of cases. Hence, as a rough approximation, we would like to know the cardinality of I Str (Pol(Γ)) when CSP(Γ) is NP-complete. A dichotomy has been proved for Boolean clones, with the surprising implication that these sets are always either finite or equal to the continuum.</p><p>Theorem 12 <ref type="bibr">([25, 60]</ref>). Let C be a Boolean clone. Then I Str (C) is finite if</p><formula xml:id="formula_10">C ⊇ Pol({{(0, 1), (1, 0)}, {(0, 1)}}) or C ⊇ Pol({{(0, 0), (0, 1), (1, 1)}, {(0, 1)}}),</formula><p>and is of continuum cardinality otherwise.</p><p>By inspecting Post's lattice of Boolean clones <ref type="bibr" target="#b51">[52]</ref> one can then verify that the finite cases of Theorem 12 only hold for 10 clones. Also, it is known that SAT(Γ) is NP-complete if and only if</p><formula xml:id="formula_11">Pol(Γ) = [f ¬ ] or Pol(Γ) = J {0,1} , where f ¬ (x) = 1 -x [56], implying that I Str (Pol(Γ)) is of continuum cardinality, whenever SAT(Γ) is NP-complete.</formula><p>However, the fact that I Str (Pol(Γ)) is of continuum cardinality in these cases says very little of their actual complexity, and it suggests that one needs a different technique that does not rely on a classification akin to Post's lattice. For certain classes of clones C we may immediately observe yet another striking difference between I Str (C) and Post's lattice. <ref type="bibr">Theorem 13 ([46]</ref>). Let Γ ⊆ Rel k be a finite set of relations such that Pol(Γ) is essentially unary. Then pPol(Γ) is infinitely generated.</p><p>In particular, Theorem 13 holds when SAT(Γ) is NP-complete, which suggests that a full description of pPol(Γ) (that correlates to fine-grained complexity via Theorem 11) is a complicated task for finite constraint languages. To illustrate, let us for the moment concentrate on Boolean constraint languages Γ such that Pol(Γ) = J {0,1} , which subsume the examples 1-IN-3-SAT and k-SAT from Example 1. Even though the full description of I Str (J {0,1} ) does not seem realistic by Theorem 12 and Theorem 13, there are plenty of questions relevant to the study of the fine-grained complexity of SAT(Γ). To illustrate, we list two below.</p><p>• Does I Str (J {0,1} ) admit a greatest element, and if this is the case, is it then possible to describe the maximal elements?</p><p>• Is it possible to describe the minimal strong partial clones of I Str (J {0,1} ) -provided they exist (note that a unique least element trivially exists, namely Str(J {0,1} )) ‡ .</p><p>These questions are pertaining to the study of fine-grained complexity since, by Theorem 11, "small" members of I Str (J {0,1} ) correspond to SAT problems with high time complexity, and "large" members of I Str (J {0,1} ) correspond to SAT problems of low time complexity. It is worth observing that one of these questions can be answered immediately, by making use of the concept of a weak base R of a co-clone Inv(C) recalled from Section 4.1. Indeed, pPol(R) ⊇ pPol(Γ) for each pPol(Γ) ∈ I Str (J {0,1} ) implies that pPol(R) is the greatest element. Furthermore, Inv(J {0,1} ) is known to admit a particularly simple weak base</p><formula xml:id="formula_12">R = = =01 1/3</formula><p>= {(0, 0, 1, 1, 1, 0, 0, 1), (0, 1, 0, 1, 0, 1, 0, 1), (1, 0, 0, 0, 1, 1, 0, 1)} <ref type="bibr" target="#b41">[42]</ref>. This observation was then leveraged by Jonsson et al. <ref type="bibr" target="#b38">[39]</ref> to show that SAT({R = = =01 1/3 }) constitutes the "easiest NP-complete SAT problem", in the following sense.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 14 ([39]). SAT({R</head><formula xml:id="formula_13">= = =01 1/3 }) is NP-complete and T({R = = =01 1/3 }) ≤ T(Γ) for any Boolean constraint language Γ such that SAT(Γ) is NP-complete.</formula><p>Proof. We give a short sketch of the most important ideas. If SAT(Γ) is NPcomplete then by Schaefer's dichotomy theorem <ref type="bibr" target="#b55">[56]</ref> either Pol(Γ) = [f ¬ ] or Pol(Γ) = J {0,1} . It is also known <ref type="bibr" target="#b41">[42]</ref> that the relation</p><formula xml:id="formula_14">R = R = = =01 1/3 ∪ {(f ¬ (t) | t ∈ R = = =01 1/3</formula><p>)} is a weak base of Inv({f ¬ }), and from Theorem 11 it then follows that T({R}) ≤ T(Γ) or T(</p><formula xml:id="formula_15">{R = = =01 1/3 }) ≤ T(Γ), since pPol(Γ) ⊆ pPol(R) or pPol(Γ) ⊆ pPol(R = = =01 1/3</formula><p>). Hence, it is sufficient to prove that T({R = = =01 1/3 }) ≤ T({R}), which can be accomplished by a polynomial-time many-one reduction only introducing a constant number of fresh variables (see Lemma 19 in Jonsson el al. <ref type="bibr" target="#b38">[39]</ref>).</p><p>Jonsson et al. <ref type="bibr" target="#b38">[39]</ref> also conjectured that the strong partial clones between pPol(R 1/3 ) and pPol(R = = =01 1/3</p><p>) had a simple structure consisting of only three elements pPol(R</p><formula xml:id="formula_16">01 1/3 ), pPol(R =01 1/3 ), pPol(R = =01 1/3 ), such that pPol(R 1/3 ) ⊂ pPol(R 01 1/3 ) ⊂ pPol(R =01 1/3 ) ⊂ pPol(R = =01 1/3 ) ⊂ pPol(R = = =01 1/3</formula><p>).</p><p>However, this conjecture turned out to be incorrect: Lagerkvist &amp; Roy showed the existence of (countably) infinitely many strong partial clones between pPol(R 01 1/3 ) and pPol(R =01 1/3 ), pPol(R =01 1/3 ) and pPol(R = =01 1/3 ), and pPol(R = =01 1/3 ) and pPol(R = = =01 1/3</p><p>) <ref type="bibr" target="#b42">[43]</ref>. This was later refined by Couceiro et al. <ref type="bibr" target="#b21">[22]</ref> that constructed families of strong partial clones of continuum size between each of these pairs of partial clones.</p><p>It is also noteworthy to remark that Theorem 14 was extended to a broad class of finite-domain CSPs, the so-called ultraconservative CSPs, which can be defined as CSP(Γ) problems where Γ contains all unary relations over the domain. Here, the term ultraconservative is used instead of the more familiar "conservative" since it is actually required that the unary relations are included in the constraint language, and not only that they are primitive positive definable. Proof. Assume that CSP(Γ) is NP-complete for an ultraconservative Γ ⊆ Rel k . In this case almost nothing is known concerning the precise structure of Pol(Γ), making it difficult to construct a weak base of InvPol(Γ)). However, it is known that Theorem 6 in this case implies that Pol(Γ) does not contain an operation satisfying a strong Maltsev condition, which in turn is known to imply that Γ primitively positively interprets (pp-interprets) Γ 3 SAT . We refrain from defining pp-interpretations formally but remark that they may be viewed as a relational counterpart to varieties, and may be used to compare the expressive strength of constraint languages which are incomparable with respect to pp-definitions. From this assumption one can then prove that Γ can pp-define a relation R with only three tuples, and this pp-definition can be transformed into a qfpp-definition of a similar relation R Γ , also of cardinality three. Among all these relations it is then possible to isolate a unique relation R k with the property that T({R k }) ≤ T({R Γ }) for each ultraconservative Γ where CSP(Γ) is NP-complete. Hence, this proof strategy does not explicitly use weak bases, due to the largely unexplored clone lattice over k, but it completely relies on qfpp-definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">The Non-Existence of Minimal Strong Partial Clones</head><p>We now turn to the question of minimal strong partial clones in I Str (J {0,1} ), i.e., partial clones pPol(Γ) ∈ I Str (J {0,1} ) such that pPol(Γ) ⊃ Str(J {0,1} ) but for which there is no pPol(∆) ∈ I Str (J {0,1} ) such that pPol(Γ) ⊃ pPol(∆) ⊃ Str(J {0,1} ). The existence of a minimal element pPol(Γ) would have interesting consequences in the light of the SETH, in particular, if T(Γ) &lt; 1, since SAT(Γ) would then belong to the class of "hardest" NPcomplete SAT problems that are still easier than the unrestricted SAT problem.</p><p>However, this question has a surprisingly straightforward resolution: as proven by Couceiro et al. <ref type="bibr" target="#b23">[24]</ref>, there are no minimal strong partial clones. More specifically, for each k (k &gt; 1) it was proved that if f ∈ Str(J k ), then the strong partial clone [f ] s contains a family of strong partial subclones of continuum cardinality. Two slightly different constructions were given to prove this result, depending on whether f is constant (i.e., there exists x ∈ k such that f (α i ) = x for all α i ∈ dom(f )) or not. Here, we provide a sketch of the latter construction.</p><p>Let f be an n-ary partial operation not in Str(J k ) and not constant. In the sequel we assume that the partial operation f is n-ary and with domain dom(f ) = {α 1 , . . . , α m } ⊆ k n , where α i := (a i 1 , . . . , a i n ). Let A be the m× n matrix whose rows are α 1 , . . . , α m , and consider the following construction.</p><p>Let Col(A) be the set of columns of A, and</p><formula xml:id="formula_17">v f = f (A) ∈ k m . For x := (x 1 , . . . , x h ) ∈ k h and ≥ 1, let x × ∈ k h be x × = (x 1 , . . . , x 1 times , x 2 , . . . , x 2 times , . . . , x h , . . . , x h times ),</formula><p>and let [x] = {x 1 , . . . , x h }. For a set X ⊆ k with</p><formula xml:id="formula_18">X = {x 1 &lt; • • • &lt; x |X| }</formula><p>and a ∈ X, let next X (a) ∈ X be defined by next X (a) :=</p><p>x i+1 if a = x i and i &lt; |X|,</p><formula xml:id="formula_19">x 1 if a = x |X| . Furthermore, for x = (x 1 , . . . , x h ) ∈ [v f ] h and 1 ≤ i ≤ h, let c i (x) be the tuple c i (x) := (x 1 , . . . , x i-1 , next [v f ] (x i ), x i+1 , . . . , x h ).</formula><p>Since the partial operation f is non-constant, the set [v f ] contains at least two different elements, and so c i (x) = x for all x ∈ [v f ] h and all i = 1, . . . , h. Let t ≥ 0 be the number of columns u ∼ in the matrix A that satisfy</p><formula xml:id="formula_20">[u ∼ ] = [v f ].</formula><p>Without loss of generality, assume that all those t columns (if any) are the first columns to the left of A.</p><p>For each ≥ 1, define the relation ρ of arity d f by</p><formula xml:id="formula_21">ρ := {c i (v × f ) | 1 ≤ i ≤ d f } ∪ {u ∼ × | u ∼ ∈ Col(A)}. Notice that |ρ | = d f + n.</formula><p>Let M be the matrix with d f rows, whose ( d f + n) columns are the tuples of ρ in the following order:</p><formula xml:id="formula_22">c 1 (v × f ), . . . , c d f (v × f ), u ∼ 1 × , . . . , u ∼ n × ,</formula><p>where u ∼ 1 , . . . , u ∼ n are the columns of A written in the same order as they appear in A.</p><p>Now let f × be the ( d f + n)-ary partial operation whose domain is the set of all rows of M and defined by</p><formula xml:id="formula_23">f × (M ) = v × f . Notice that x 1 , . . . , x d f +t ∈ [v f ] whenever x = (x 1 , . . . , x d f +n ) ∈ dom(f × ). Example 6. Let k = {0, 1, 2}, = 3 and f   0 0 0 1 0 1 0 0 2   =   0 0 1   .</formula><p>Then v f = (0, 0, 1), v ×3 f = (0, 0, 0, 0, 0, 0, 1, 1, 1),</p><formula xml:id="formula_24">A =   0 0 0 1 0 1 0 0 2   ,</formula><p>Col(A) = {(0, 1, 0) T , (0, 0, 0) T , (0, 1, 2) T }, and</p><formula xml:id="formula_25">f ×3 (M 3 ) = f ×3               </formula><p>1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 0 1</p><formula xml:id="formula_26">1 1 1 1 1 1 0 1 1 0 0 2 1 1 1 1 1 1 1 0 1 0 0 2 1 1 1 1 1 1 1 1 0 0 0 2                =                0 0 0 0 0 0 1 1 1                .</formula><p>It is not difficult to verify that this construction yields the following result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 16 ([24]</head><p>). For every ≥ 1,</p><formula xml:id="formula_27">f × ∈ [f ] s . Moreover, for ≥ 1, f × ∈ pPol(ρ ) iff = .</formula><p>As an immediate consequence, we thus have the desired corollary.</p><p>Corollary 17. Let C be a strong partial clone on k and suppose that C contains a partial operation f ∈ Str(J k ) that is not a constant operation. Then the set of strong partial clones contained in C is of continuum cardinality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">OPEN QUESTIONS AND RELATED WORK</head><p>The study of fine-grained complexity is still in its infancy and we have only concentrated a handful of results pertaining to partial polymorphisms. We now present a few concrete questions arising from the results presented thus far, and discuss related research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>On the non-existence of minimal strong partial clones</head><p>We provided a sketch of one of the constructions in <ref type="bibr" target="#b23">[24]</ref>, which shows that for any non-constant f / ∈ Str(J {0,1} ) there exists g / ∈ Str(J {0,1} ) such that [g] s ⊂ [f ] s . Assuming that T(Inv({f })) &lt; 1, can we use a similar construction to find a g such that T(Inv({f })) &lt; T(Inv({g}))?</p><p>Maximal elements of I Str (J k ) We have seen that I Str (J {0,1} ) has a largest element pPol(R = = =01 1/3</p><p>), that constitutes the "easiest NP-complete SAT problem" SAT({R = = =01 1/3 }). Given the non-existence of minimal strong partial clones one may be sceptical about the existence of maximal elements of I Str (J {0,1} ). However, such elements do in fact exist. For instance, one can prove that pPol({R = = =01 1/3 , {(0)}}) and pPol({R = = =01 1/3 , {(1)}}) are both maximal elements. The caveat here is that</p><formula xml:id="formula_28">T ({R = = =01 1/3 }) = T({R = = =01 1/3 , {(0)}) = T({R = = =01 1/3</formula><p>, {(1)}), implying that these elements are not interesting from a complexity theoretical point of view. This raises the question of whether there exists a maximal element pPol(Γ) of I Str (J {0,1} ) such that T({R = = =01 1/3 }) &lt; T(Γ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Strong Maltsev conditions and partial polymorphisms</head><p>Lagerkvist &amp; Wahlström <ref type="bibr" target="#b46">[47]</ref> propose a usage of partial polymorphisms which is similar to how strong Maltsev conditions are used to characterize the classical complexity of CSPs. For example, given a k and the identities defining a Maltsev operation m(x, x, y) ≈ y, m(x, y, y) ≈ x, we can define a partial operation f such that dom(f ) = {(x, x, y), (x, y, y) | x, y ∈ k} and such that f (x, x, y) = y and f (x, y, y) = x. Such a partial operation f is then called a partial Maltsev operation. Now given an operation thus constructed, the goal is then to devise an algorithm for CSP(Inv(f )) with a running time better than O(k n ). Surprisingly, this is indeed possible for the partial Maltsev operation, where one obtains the upper bound O(k n 2 ). An interesting continuation to this line of research is to consider the identities defining near unanimity operations and edge operations, and investigate if similar improved bounds can be obtained for the corresponding partial operations.</p><p>A related application of partial polymorphisms in the realm of exponentialtime algorithms was recently demonstrated by Brakensiek &amp; Guruswami <ref type="bibr" target="#b11">[12]</ref>. They prove that if Γ is preserved by an infinite family of partial threshold polymorphisms then SAT(Γ) can be solved by a fast exponential-time algorithm based on linear programming. For example, this holds for R 1/3 and for Γ k SAT for k ≥ 3. While these two problems are known to admit even faster specialised algorithms <ref type="bibr" target="#b49">[50,</ref><ref type="bibr" target="#b61">62]</ref>, the linear programming framework of Brakensiek &amp; Guruswami also provides a clear explanation of why these problems admit an exponentially improved algorithm, which demonstrates a distinct advantage of studying fine-grained complexity of such problems in a more abstract, algebraic setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sparsification via partial polymorphisms</head><p>There exists many computational properties with a similar flavour as finegrained complexity. One example from parameterized complexity is sparsification: given an instance of a computational problem, associated with a parameter k ≥ 0, is it possible to compute (in polynomial time) an equivalent instance whose size is bounded by a fixed function in k? For example, in the case of CSP(Γ) we could be interested in reducing the number of constraints with respect to the number of variables in the instance, and ask whether it is possible to reduce the number of constraints in an instance (V, C) to O(|V |) or O(|V | 2 ).</p><p>Sparsification of SAT problems were studied by Jansen &amp; Pieterse <ref type="bibr" target="#b35">[36]</ref> who observed that in many interesting cases this question could be translated into properties of (low-degree) polynomials. This same idea was generalised by Lagerkvist &amp; Wahlström <ref type="bibr" target="#b47">[48]</ref> who studied this question by embedding CSPs into CSPs preserved by a Maltsev operation and, more generally, by embedding an NP-complete CSP problem into a tractable CSP over a larger domain. The property of admitting "embeddings" of this form could then be witnessed by partial operations closely linked to strong Maltsev conditions. However, the question of whether this algebraic framework could give a complete dichotomy for CSPs admitting linear sparsifications was left open. Similar conditions with closely matching results were later also obtained by Chen et al. <ref type="bibr" target="#b19">[20]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 3 .</head><label>3</label><figDesc><ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b53">54]</ref> Let Γ, ∆ ⊆ Rel k be two sets of relations. Then (1) Γ ⊆ Inv(Pol(∆)) if and only if Pol(∆) ⊆ Pol(Γ), and (2) Γ ⊆ Inv(pPol(Γ)) if and only if pPol(∆) ⊆ pPol(Γ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 10 .</head><label>10</label><figDesc>([40]) Let Γ ⊆ Rel k such that CSP(Γ) is NP-complete. Then T(Γ) &gt; 0 unless the ETH fails.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 15 (</head><label>15</label><figDesc><ref type="bibr" target="#b39">[40]</ref>). For each k there exists a relation R k ∈ Rel k such that (1) CSP({R k }) is NP-complete, and (2) T({R k }) ≤ T(Γ) for any ultraconservative Γ ⊆ Rel k such that CSP(Γ) is NP-complete.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>† A clone C is essentially unary if C = [F ]for a set of unary operations F .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>‡  We follow the standard terminology where minimal/maximal clones are those directly above/below the greatest/least element in the clone lattice.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGEMENTS</head><p>We thank the anonymous reviewer for several helpful comments. The third author is partially supported by the <rs type="funder">Swedish Research Council (VR)</rs> under grant <rs type="grantNumber">2019-03690</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_dAsfNrn">
					<idno type="grant-number">2019-03690</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Polymorphisms, and how to use them</title>
		<author>
			<persName><forename type="first">L</forename><surname>Barto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Krokhin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ross</forename><surname>Willard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Constraint Satisfaction Problem: Complexity and Approximability, volume 7 of Dagstuhl Follow-Ups</title>
		<editor>
			<persName><forename type="first">Andrei</forename><forename type="middle">A</forename><surname>Krokhin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stanislav</forename><surname>Zivný</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="44" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The wonderland of reflections</title>
		<author>
			<persName><forename type="first">L</forename><surname>Barto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Oprvsal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pinsker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Israel Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">223</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="363" to="398" />
			<date type="published" when="2018-02">Feb 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Give me another one!</title>
		<author>
			<persName><forename type="first">M</forename><surname>Behrisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mengel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Salzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Symposium on Algorithms and Computation (ISAAC-2015)</title>
		<meeting>the 26th International Symposium on Algorithms and Computation (ISAAC-2015)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="664" to="676" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">As close as it gets</title>
		<author>
			<persName><forename type="first">M</forename><surname>Behrisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mengel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Salzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Workshop on Algorithms and Computation</title>
		<meeting>the 10th International Workshop on Algorithms and Computation</meeting>
		<imprint>
			<publisher>WALCOM</publisher>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="page" from="222" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Minimal distance of propositional models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Behrisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mengel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Salzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1131" to="1184" />
			<date type="published" when="2019-08">Aug 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Set partitioning via inclusionexclusion</title>
		<author>
			<persName><forename type="first">A</forename><surname>Björklund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Husfeldt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koivisto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="546" to="563" />
			<date type="published" when="2009-07">July 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A model-theoretic view on qualitative constraint reasoning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bodirsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jonsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="339" to="385" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Partition into triangles on bounded degree graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bodlaender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Rooij</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Kooten Niekerk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="687" to="718" />
			<date type="published" when="2013-05">May 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Galois theory for Post algebras</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">G</forename><surname>Bodnarchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Kaluzhnin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Kotov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Romov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">I. Cybernetics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="243" to="252" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Galois theory for Post algebras</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">G</forename><surname>Bodnarchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Kaluzhnin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Kotov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Romov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">II. Cybernetics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="531" to="539" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Maximal partial clones with no finite basis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Börner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Haddad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algebra Universalis</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="453" to="476" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Bridging between 0/1 and linear programming via random walks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Brakensiek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Guruswami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing (STOC-2019)</title>
		<meeting>the 51st Annual ACM SIGACT Symposium on Theory of Computing (STOC-2019)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="568" to="577" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A dichotomy theorem for constraint satisfaction problems on a 3-element set</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bulatov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="66" to="120" />
			<date type="published" when="2006-01">January 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Complexity of conservative constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bulatov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2011-07">July 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The complexity of the counting constraint satisfaction problem</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bulatov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="34" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A dichotomy theorem for nonuniform CSPs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bulatov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 58th Annual Symposium on Foundations of Computer Science (FOCS-2017)</title>
		<meeting>the 58th Annual Symposium on Foundations of Computer Science (FOCS-2017)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A simple algorithm for Mal&apos;tsev constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bulatov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Dalmau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal On Computing</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="16" to="27" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Classifying the complexity of constraints using finite algebras</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bulatov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jeavons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krokhin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="720" to="742" />
			<date type="published" when="2005-03">March 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The complexity of satisfiability of small depth circuits</title>
		<author>
			<persName><forename type="first">C</forename><surname>Calabro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paturi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parameterized and Exact Computation</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">V</forename><surname>Fomin</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5917</biblScope>
			<biblScope unit="page" from="75" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Best-case and worst-case sparsifiability of boolean CSPs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M P</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieterse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Symposium on Parameterized and Exact Computation (IPEC-2018)</title>
		<meeting>the 13th International Symposium on Parameterized and Exact Computation (IPEC-2018)</meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum fuer Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Intersections of finitely generated maximal partial clones</title>
		<author>
			<persName><forename type="first">M</forename><surname>Couceiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Haddad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multiple-Valued Logic and Soft Computing</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="85" to="94" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the interval of Boolean strong partial clones containing only projections as total operations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Couceiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th International Symposium on Multiple-Valued Logic (ISMVL-2017)</title>
		<meeting>the 47th International Symposium on Multiple-Valued Logic (ISMVL-2017)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="88" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Partial clones containing all boolean monotone self-dual partial functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Couceiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">G</forename><surname>Rosenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multiple-Valued Logic and Soft Computing</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="183" to="192" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">On the lower part of the lattice of partial clones</title>
		<author>
			<persName><forename type="first">M</forename><surname>Couceiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Schölzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multiple-Valued Logic and Soft Computing</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="177" to="196" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A solution to a problem of D. Lau: Complete classification of intervals in the lattice of partial boolean clones</title>
		<author>
			<persName><forename type="first">M</forename><surname>Couceiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Schölzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Waldhauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multiple-Valued Logic and Soft Computing</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="58" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A dichotomy theorem for maximum generalized satisfiability problems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Creignou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="511" to="522" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Complexity of generalized satisfiability counting problems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Creignou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">125</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Complexity classifications of Boolean constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Creignou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Monographs on Discrete Mathematics and Applications</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Boolean constraint satisfaction problems: When does Post&apos;s lattice help</title>
		<author>
			<persName><forename type="first">N</forename><surname>Creignou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Vollmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Complexity of Constraints</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Creignou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Vollmer</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5250</biblScope>
			<biblScope unit="page" from="3" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A complete classification of the complexity of propositional abduction</title>
		<author>
			<persName><forename type="first">N</forename><surname>Creignou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zanuttini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="207" to="229" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the subexponential-time complexity of CSP</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Haan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">A</forename><surname>Kanj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Szeider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research (JAIR)</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="203" to="234" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A survey of qualitative spatial and temporal calculi: Algebraic and computational properties</title>
		<author>
			<persName><forename type="first">F</forename><surname>Dylla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mossakowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Van Delden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Ven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2017-04">April 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The computational structure of monotone monadic SNP and constraint satisfaction: A study through datalog and group theory</title>
		<author>
			<persName><forename type="first">T</forename><surname>Feder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="104" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Closed systems of functions and predicates</title>
		<author>
			<persName><forename type="first">D</forename><surname>Geiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pacific Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="95" to="100" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On the complexity of k-SAT</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paturi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="367" to="375" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Optimal sparsification for some binary CSPs using low-degree polynomials</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M P</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieterse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st International Symposium on Mathematical Foundations of Computer Science (MFCS-2016)</title>
		<meeting>the 41st International Symposium on Mathematical Foundations of Computer Science (MFCS-2016)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="1" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">On the algebraic structure of combinatorial problems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Jeavons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">200</biblScope>
			<biblScope unit="page" from="185" to="204" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Closure properties of constraints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Jeavons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gyssens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="527" to="548" />
			<date type="published" when="1997-07">July 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Strong partial clones and the time complexity of SAT problems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Jonsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nordh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zanuttini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="52" to="78" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Time complexity of constraint satisfaction via universal algebra</title>
		<author>
			<persName><forename type="first">P</forename><surname>Jonsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd International Symposium on Mathematical Foundations of Computer Science (MFCS-2017)</title>
		<meeting>the 42nd International Symposium on Mathematical Foundations of Computer Science (MFCS-2017)</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The approximability of constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Trevisan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Williamson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1863" to="1920" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Weak bases of Boolean co-clones</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">114</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="462" to="468" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A Preliminary Investigation of Satisfiability Problems Not Harder than 1-in-3-SAT</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st International Symposium on Mathematical Foundations of Computer Science (MFCS-2016)</title>
		<meeting>the 41st International Symposium on Mathematical Foundations of Computer Science (MFCS-2016)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="1" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A dichotomy theorem for the inverse satisfiability problem</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS-2017)</title>
		<meeting>the 37th IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS-2017)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="39" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The inclusion structure of Boolean weak bases</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th IEEEInternational Symposium on Multiple-Valued Logic (ISMVL-2019)</title>
		<meeting>the 49th IEEEInternational Symposium on Multiple-Valued Logic (ISMVL-2019)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="31" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">The power of primitive positive definitions with polynomially many variables</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wahlström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1465" to="1488" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Which NP-hard SAT and CSP problems admit exponentially improved algorithms?</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wahlström</surname></persName>
		</author>
		<idno>CoRR, abs/1801.09488</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Sparsification of SAT and CSP problems via tractable extensions</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagerkvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wahlström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Compututation Theory</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Function Algebras on Finite Sets: Basic Course on Many-Valued Logic and Clone Theory</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Springer Monographs in Mathematics</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Springer-Verlag New York, Inc</publisher>
			<pubPlace>Secaucus, NJ, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">An improved exponential-time algorithm for k-sat</title>
		<author>
			<persName><forename type="first">R</forename><surname>Paturi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pudlák</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Saks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="337" to="364" />
			<date type="published" when="2005-05">May 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Funktionen-und Relationenalgebren</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pöschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kaluznin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>DVW</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The two-valued iterative systems of mathematical logic</title>
		<author>
			<persName><forename type="first">E</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematical Studies</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="122" />
			<date type="published" when="1941">1941</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Undirected connectivity in log-space</title>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2008-09">September 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">The algebras of partial functions and their invariants</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Romov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cybernetics and Systems Analysis</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="157" to="167" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Handbook of Constraint Programming</title>
	</analytic>
	<monogr>
		<title level="j">Foundations of Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Rossi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Van Beek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="2006">2006</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">The complexity of satisfiability problems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Schaefer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Annual ACM Symposium on Theory Of Computing (STOC-78)</title>
		<meeting>the 10th Annual ACM Symposium on Theory Of Computing (STOC-78)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="216" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Enumerating all solutions for constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Schnoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Schnoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Annual Symposium on Theoretical Aspects of Computer Science (STACS-2007)</title>
		<meeting>the 24th Annual Symposium on Theoretical Aspects of Computer Science (STACS-2007)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4393</biblScope>
			<biblScope unit="page" from="694" to="705" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Partial polymorphisms and constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Schnoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Schnoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Complexity of Constraints</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Creignou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Vollmer</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5250</biblScope>
			<biblScope unit="page" from="229" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">The weak base method for constraint satisfaction</title>
		<author>
			<persName><forename type="first">I</forename><surname>Schnoor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Hannover, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Gottfried Wilhelm Leibniz Universität</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Dichotomy on intervals of strong partial Boolean clones</title>
		<author>
			<persName><forename type="first">K</forename><surname>Schölzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algebra Universalis</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="347" to="368" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A probabilistic algorithm for k-sat and constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">U</forename><surname>Schöning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual Symposium on Foundations of Computer Science (FOCS-1999)</title>
		<meeting>the 40th Annual Symposium on Foundations of Computer Science (FOCS-1999)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page">410</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">Algorithms, measures and upper bounds for satisfiability and related problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wahlström</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Linköping University, Theoretical Computer Science Laboratory, The Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">The proof of CSP dichotomy conjecture</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhuk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 58th Annual Symposium on Foundations of Computer Science (FOCS-2017)</title>
		<meeting>the 58th Annual Symposium on Foundations of Computer Science (FOCS-2017)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
