<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">From Enhanced Coinduction towards Enhanced Induction</title>
				<funder ref="#_9TY89bm">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
				<date type="published" when="2022-01">January 2022.</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Bologna</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">INRIA</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science (DISI)</orgName>
								<orgName type="institution">University of Bologna</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">Inria Sophia MÃ©diterranÃ©e</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">From Enhanced Coinduction towards Enhanced Induction</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2022-01">January 2022.</date>
						</imprint>
					</monogr>
					<idno type="MD5">413CAE029E7113B9C9A96D5911D32E66</idno>
					<idno type="DOI">10.1145/3498679</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-03-07T09:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CCS Concepts:</term>
					<term>Theory of computation â†’ Operational semantics</term>
					<term>Process calculi</term>
					<term>â€¢ Software and its engineering â†’ Software verification coinduction, behavioural relations, process calculi, proof techniques</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>There exist a rich and well-developed theory of enhancements of the coinduction proof method, widely used on behavioural relations such as bisimilarity. We study how to develop an analogous theory for inductive behaviour relations, i.e., relations defined from inductive observables. Similarly to the coinductive setting, our theory makes use of (semi)-progressions of the form R âŸ©â‡€F (R), where R is a relation on processes and F is a function on relations, meaning that there is an appropriate match on the transitions that the processes in R can perform in which the process derivatives are in F (R). For a given preorder, an enhancement corresponds to a sound function, i.e., one for which R âŸ©â‡€F (R) implies that R is contained in the preorder; and similarly for equivalences. We introduce weights on the observables of an inductive relation, and a weight-preserving condition on functions that guarantees soundness. We show that the class of weight-preserving functions contains non-trivial functions and enjoys closure properties with respect to desirable function constructors, so to be able to derive sophisticated sound functions (and hence sophisticated proof techniques) from simpler ones. We consider both strong semantics (in which all actions are treated equally) and weak semantics (in which one abstracts from internal transitions). We test our enhancements on a few non-trivial examples.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>One of the most basic elements for reasoning on programs or systems is the meaning of behavioural equality. Intuitively, two terms are equal if no difference between them can be observed by interacting with them. The two terms may be thought of as the specification and the implementation of a certain system, or as two different implementations. Sometimes one prefers a preorder to an equivalence. In this case two terms are related when all relevant observations about a term can also be made about the other one. For instance the specification of a system may leave freedom about a number of details, and a correct implementation could have a more constrained behaviour.</p><p>The meaning of equality on processes has produced a rich and profound debate, particularly in Concurrency <ref type="bibr">Theory, very active in the 1970s and</ref><ref type="bibr">1980s</ref> and not yet exhausted. A number of proposals for behavioural preorders and equalities have been made; see, e.g, van Glabbeek's spectrum <ref type="bibr" target="#b19">[Glabbeek 1993</ref><ref type="bibr" target="#b20">[Glabbeek , 2001</ref>]. Among the notions so formulated, bisimilarity has emerged as one of the most studied and used <ref type="bibr" target="#b31">[Milner 1989;</ref><ref type="bibr" target="#b33">Park 1981]</ref>. While introduced in Concurrency Theory, bisimilarity has spread to other areas of Computer Science, as well as to other domains such as Mathematics and Cognitive Science.</p><p>the identity function and the constant function mapping every relation onto bisimilarity itself <ref type="bibr" target="#b48">[Sangiorgi 1998</ref>].</p><p>In this paper we maintain progressions as the basic schema for studying enhancements. We actually employ one-way progressions, called semi-progressions and written R âŸ©â‡€S, as we aim to capture also preorders (besides equivalences). We change however the meaning of soundness, and the conditions on functions to guarantee soundness. Moreover, everything is parametrised on a preorder, say â‰¾, as we wish the theory to be applicable to different preorders. In our enhancements, a function F is sound for â‰¾ if R âŸ©â‡€F (R) implies that R is included in the given preorder â‰¾ ; and similarly for equivalences. The crux of the theory of inductive enhancements is the condition for functional soundness that should permit composition of enhancements. For this we exploit the inductive definition of the observables. We associate a weight to each observable, intuitively related to the depth of the nesting of actions in the behaviour of a process that may have be looked at when checking that observable. We thus obtain a stratification of the preorder â‰¾; at stage ğ‘› of the preorder, â‰¾ ğ‘› , only the observables of weight less than or equal to ğ‘› are taken into account. The condition for functional soundness, weight-preservation, requires that if R complies with â‰¾ ğ‘› , i.e., R âŠ† â‰¾ ğ‘› , then also F (R) should comply, i.e., F (R) âŠ† â‰¾ ğ‘› . In the case of equivalences, rather than preorders, one adds analogous converse requirements on pairs of related processes.</p><p>We consider common basic functions and constructors in the literature about bisimulation enhancements. We show that they are weight-preserving, and may therefore be used also in inductive enhancements. Examples of basic functions and constructors are function composition, union, chaining (that gives us relational composition), and the context-closure function; in the paper we examine the last one in a CCS-like language. Examples of derived functions are the transitive-closure function, the closure under context and â‰¾ (the analogous of the 'up-to context and bisimilarity' enhancement for bisimilarity).</p><p>As behavioural relations we consider the most popular inductive preorders and equivalences in the literature, following <ref type="bibr" target="#b19">[Glabbeek 1993</ref><ref type="bibr" target="#b20">[Glabbeek , 2001]]</ref>. They include the trace, failure, failure trace, ready, and ready trace preorders (other preorders, like may and must testing and refusal, coincide with some of these, under mild conditions on the transitions performed by the processes), and their induced equivalences. In all cases, the soundness of the above functions and constructors is usually straightforward, the only exception being the context-closure function.</p><p>We work on ordinary Labeled Transition Systems (LTSs), and call processes the states of an LTS. We develop the theory under a strong semantics, where all actions are equally visible. We then study weak semantics, in which a special action denoting internal activity may be partly or completely ignored. It is well-known that theories of weak coinductive enhancements tend to be rather more involved than the 'strong' theories. For instance, a useful constructor, chaining, is sound only in the strong theories. Similar issues show up in the inductive enhancements. In addition, some of the weak behavioural relations make use of state predicates such as stability, which do not appear in the strong case. Some of the technical solutions that we adopt for the inductive setting are inspired from those used in the coinductive setting, others are specific to the weight-based conditions of the inductive setting. We consider different forms of weight (for instance distinguishing the contribution of internal and visible actions), and examine their relative advantages and disadvantages.</p><p>The usefulness of our proof techniques is examined on 3 non-trivial examples. The first example is about a key property of many languages, namely substitutivity for recursive definitions. The example also shows how the inductive enhancements may yield proofs that are parametric on the preorder (or equivalence) and the language adopted. The second example is about concrete systems for which bisimilarity may be argued to be too fine, or in which bisimilarity suffers from the lack of an associated preorder. The systems to be related are two servers. They differ in the order in which certain interactions with some auxiliary servers occur. We consider two instances of the systems, the second instance only suitable for preorders. In both cases the servers may be related by any of the inductive relations considered in the paper (in the second case only the preorders). The enhancements allow us to carry out the proofs using singletons relations. In none of the instances the servers are bisimilar. The third example is about the soundness of a proof system. Proof systems underpin algebraic reasoning, widely used in verification tools. The proof system we consider has been proposed by Hennessy <ref type="bibr" target="#b23">[Hennessy 2017]</ref> for the trace preorder. The system is non-standard; for instance, in contrast with earlier proof systems by Salomaa <ref type="bibr" target="#b47">[Salomaa 1966</ref>], Kozen <ref type="bibr" target="#b27">[Kozen 1994</ref>], and Rabinovich <ref type="bibr" target="#b43">[Rabinovich 1993]</ref> for trace equivalence, it does not rely on forms of unique fixed-point induction. This however makes the soundness proof delicate. We show that soundness can be explained via the inductive enhancements. Another reason for choosing the example is that it combines a number of enhancement functions. We first analyse all the examples under strong semantics; then we examine the weak versions of the examples, and variants of them, under weak semantics. All examples are described in CCS; however any language capable of expressing interaction would do.</p><p>Structure of the paper. In Section 2, we formalise the meaning of inductive observables, using operators from modal logics, In Section 3 we relate such observables to common inductive preorders and equivalences from the literature. In Section 4 we introduce weights and weighted stratification of the behavioural preorders and equivalences. In Section 5 we develop the theory of semi-progressions, sound functions, and weight-preserving functions. In Section 6 we derive the weight-preserving property for a number of functions; the context-closure function requires one to fix a language, and for this use a CCS-like language. In Section 7 we transport the work for preorders in earlier sections to equivalences. In Sections 8-10 we discuss the three examples of use of enhancements mentioned above. In Sections 11 to 13 we study the theory weak semantics, and in Section 14 we revisit the previous examples, and variants of them, under the weak semantics. Finally, in Sections 15 and 16, we discuss further related work and directions for future work.</p><p>For space reasons, some auxiliary definitions and results and all proofs are moved to an appendix available online in the ACM digital library as supplemental material for this paper.</p><p>Preliminaries. We work on ordinary Labeled Transition Systems (LTSs), i.e., triples (Pr, Ağ‘ğ‘¡, -â†’) with domain Pr, set of actions (or labels) Ağ‘ğ‘¡, and transition relation -â†’ âŠ† Pr Ã— Ağ‘ğ‘¡ Ã— Pr. We use ğ‘ƒ, ğ‘„ and ğ‘… to range over Pr and call them processes; ğœ‡ ranges over the actions. As usual ğ‘ƒ ğœ‡ -â†’ ğ‘„ stands for (ğ‘ƒ, ğœ‡, ğ‘„) âˆˆ -â†’, to be interpreted as "ğ‘ƒ may become ğ‘„ by performing an action ğœ‡". We write</p><formula xml:id="formula_0">ğ‘ƒ ğœ‡ -â†’ if there is ğ‘ƒ â€² with ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² , and ğ‘ƒ Ì¸ ğœ‡ -â†’ if there is no ğ‘ƒ â€² such that ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² .</formula><p>Sometimes in examples we use basic CCS operators such as sum and prefix.</p></div>
<div><head n="2">INDUCTIVE OBSERVABLES AND PREORDERS</head><p>We begin with ordinary LTSs and strong semantics, where all actions are equally treated.</p><p>To define our inductive enhancements, we adopt a presentation of behavioural preorders and equivalences in which the observables employed are described by means of modal formulas. The operators include the 'diamond' âŸ¨ ğœ‡ âŸ©. ğœƒ , to detect the possibility of performing the action ğœ‡, a (possibly infinitary) 'and', to permit multiple observations, and a set of atomic observables. Without the atomic observables, this is the positive fragment of <ref type="bibr">Hennessy-Milner logic [Hennessy and Milner 1985]</ref>, whose satisfaction problem is straightforward -with or without atomic formulas <ref type="bibr" target="#b53">[Stirling 2001</ref>].</p><p>Definition 2.1. Let Ağ‘ğ‘¡ and A be (countable) sets of actions and of atomic observables. A family of observables (over Ağ‘ğ‘¡ and A) is a subset O of the formulas inductively generated by the following grammar:</p><formula xml:id="formula_1">ğœƒ := âŸ¨ ğœ‡ âŸ©. ğœƒ | ğ‘— âˆˆğ½ ğœƒ ğ‘— | a</formula><p>where ğœ‡ âˆˆ Ağ‘ğ‘¡, a âˆˆ A, ğ½ is a countable set, and:</p><p>â€¢ (downward-closure) if âŸ¨ ğœ‡ âŸ©. ğœƒ âˆˆ O then also ğœƒ âˆˆ O, and similarly if ğ‘— âˆˆğ½ ğœƒ ğ‘— âˆˆ O then also ğœƒ ğ‘— âˆˆ O for each ğ‘—. We write true for the formula corresponding to the empty conjunction, and ğœƒ 1 âˆ§ ğœƒ 2 for a binary conjunction. We let O range over families of observables, and ğœƒ, ğœ over observables.</p><p>The downward-closure property requires that a family of observables is syntactically saturated, in that it contains all subterms of any observable in the family. The property is needed in some of our main theorems (e.g., <ref type="bibr">Theorem 5.6)</ref>.</p><p>The observables of a family O are meant to be interpreted as predicates over the processes of an LTS over the same set of actions, and accordingly we write ğ‘ƒ âŠ¨ ğœƒ when the observable ğœƒ holds on the process ğ‘ƒ. The interpretation is defined structurally over the observables, writing <ref type="bibr">[[a]</ref>] for the set of processes on which the atomic observable a holds:</p><formula xml:id="formula_2">at ğ‘ƒ âˆˆ [[a]] ğ‘ƒ âŠ¨ a act ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² ğ‘ƒ â€² âŠ¨ ğœƒ ğ‘ƒ âŠ¨ âŸ¨ ğœ‡ âŸ©. ğœƒ conj ğ‘ƒ âŠ¨ ğœƒ ğ‘— for all ğ‘— âˆˆ ğ½ ğ‘ƒ âŠ¨ ğ‘— âˆˆğ½ ğœƒ ğ‘—</formula><p>The observable true is satisfied by all processes.</p><p>In Section 3 we discuss the characterisation of common inductive preorders and equivalences in the literature. The only kind of atomic observable that will be needed is the refusal ref ğœ‡ , which holds of a process ğ‘ƒ and an action ğœ‡ if ğ‘ƒ Ì¸ ğœ‡ -â†’. However, for generality, in the theory we allow arbitrary atomic observables. Such observables should however be local: they can be checked by looking only at the immediate outgoing transitions emanating from a process. That is, for each such observable, say a, there are sets of actions ğ´ and ğµ such that for all process ğ‘ƒ, we have ğ‘ƒ âˆˆ <ref type="bibr">[[a]</ref>] iff ( ğ‘ƒ ğœ‡ -â†’ for all ğœ‡ âˆˆ ğ´, and ğ‘ƒ Ì¸ ğœ‡ -â†’ for all ğœ‡ âˆˆ ğµ). For instance, for the refusal ref ğœ‡ , we have ğ´ = âˆ… and ğµ = {ğœ‡}.</p><p>Example 2.2.</p><p>â€¢ The observable âŸ¨ ğ‘ âŸ©. âŸ¨ ğ‘ âŸ©. true is satisfied by any process that can perform an action ğ‘ followed by an action ğ‘, i.e., the trace ğ‘; ğ‘. </p></div>
<div><head n="3">PREORDER INSTANCES</head><p>The operators in the grammar for observables allow us to capture all inductive preorders and equivalences in van Glabbeek's spectrum <ref type="bibr" target="#b20">[Glabbeek 2001</ref>] (collecting the main such relations in the literature) with the exception of possible-future semantics, namely: trace, failure, failure trace, ready, ready trace preorders and equivalences <ref type="bibr" target="#b0">[Baeten et al. 1987;</ref><ref type="bibr">Brookes et al. 1984;</ref><ref type="bibr">Brookes and Roscoe 1984;</ref><ref type="bibr" target="#b32">Olderog and Hoare 1986;</ref><ref type="bibr" target="#b36">Pnueli 1985;</ref><ref type="bibr" target="#b37">Pomello 1985]</ref>. (Assuming image-finiteness of the LTSs, meaning that for all ğ‘ƒ and ğœ‡, the set {ğ‘ƒ â€² | ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² } is finite, the set of such preorders also include the may, must, and testing preorders <ref type="bibr" target="#b16">[De Nicola and Hennessy 1984;</ref><ref type="bibr" target="#b22">Hennessy 1988]</ref>, and the refusal preorder <ref type="bibr" target="#b35">[Phillips 1987</ref>].) Below we only informally and briefly recall the meaning of such relations and the grammar for observables needed, referring to the Appendix for more details, and to <ref type="bibr" target="#b20">[Glabbeek 2001</ref>] for a comprehensive treatment (including comparisons among the preorders and equivalences, modal logic characterisations and axiomatisations). The notations and terminology here and in the Appendix follow <ref type="bibr" target="#b20">[Glabbeek 2001</ref>]. For historical reasons, we maintain however references to the papers in which the behavioural relations were first proposed, even if the papers referred to adopt a 'weak' semantics (i.e, they abstract from internal transitions of the processes, as in Section 11).</p><p>In the trace preorder (which coincides with the may-testing preorder <ref type="bibr" target="#b16">[De Nicola and Hennessy 1984;</ref><ref type="bibr" target="#b22">Hennessy 1988]</ref>) two processes ğ‘ƒ and ğ‘„ are related if all traces, i.e., finite sequences of actions, that ğ‘ƒ can produce can also be produced by ğ‘„. The preorder is captured using the following grammar of observables:</p><formula xml:id="formula_3">ğœƒ := âŸ¨ ğœ‡ âŸ©. ğœƒ | true</formula><p>Thus, there is an observable âŸ¨ ğœ‡ 1 âŸ©. . . . . âŸ¨ ğœ‡ ğ‘› âŸ©. true for each trace ğœ‡ 1 ; . . . ; ğœ‡ ğ‘› . No atomic observable is required -in contrast we need the refusals ref ğœ‡ in all the remaining preorders.</p><p>A failure is a pair (ğœ, ğ´), where ğœ is a trace and ğ´, called a refusal set, is a set of actions. The failure (ğœ, ğ´) belongs to process ğ‘ƒ if the process can produce the trace ğœ and, by doing so, becomes a process ğ‘ƒ â€² that may not accept any action in ğ´ (i.e., ğ‘ƒ â€² Ì¸ ğœ‡ -â†’ for all ğœ‡ âˆˆ ğ´). In the failure preorder <ref type="bibr">[Brookes et al. 1984;</ref><ref type="bibr">Brookes and Roscoe 1984</ref>] (which coincides with the inverse of the must-testing preorder <ref type="bibr" target="#b16">[De Nicola and Hennessy 1984;</ref><ref type="bibr" target="#b22">Hennessy 1988]</ref>) ğ‘ƒ and ğ‘„ are related if all failures of ğ‘ƒ are also failures of ğ‘„. The preorder is captured by the observables of the following grammar</p><formula xml:id="formula_4">ğœƒ := âŸ¨ ğœ‡ âŸ©. ğœƒ | ğœ‡ âˆˆğ´ ref ğœ‡</formula><p>(with the convention that, if ğ´ is a singleton {ğœ‡}, then âˆ§ ğœ‡ âˆˆğ´ ref ğœ‡ is the same as ref ğœ‡ ). Set ğ´ may be empty, and then âˆ§ ğœ‡ âˆˆğ´ ref ğœ‡ is true.</p><p>In the failure trace preorder [Glabbeek 2001] (which coincides with the refusal preorder <ref type="bibr" target="#b35">[Phillips 1987]</ref>), refusal sets may be observed at any point along a trace of actions. The grammar for observables is</p><formula xml:id="formula_5">ğœƒ := âŸ¨ ğœ‡ âŸ©. ğœƒ | ğœ‡ âˆˆğ´ ref ğœ‡ | ( ğœ‡ âˆˆğ´ ref ğœ‡ ) âˆ§ ğœƒ</formula><p>In the ready preorder <ref type="bibr" target="#b32">[Olderog and Hoare 1986]</ref>, one observes, after a trace, the ready set of the final process, that is, the set of all actions that the process can perform. A ready set ğ´ is captured by the observable âˆ§ ğœ‡ âˆˆğ´ âŸ¨ ğœ‡ âŸ©. true âˆ§ âˆ§ ğœ‡âˆ‰ğ´ ref ğœ‡ . In the ready trace preorder <ref type="bibr" target="#b0">[Baeten et al. 1987;</ref><ref type="bibr" target="#b36">Pnueli 1985;</ref><ref type="bibr" target="#b37">Pomello 1985]</ref>, the ready sets of all the processes encountered along a trace are taken into account. We refer to the Appendix for details on the ready and ready trace preorders (definitions of the preorders, and grammars for observables).</p><p>The operators for observables in Definition 2.1 are known to be able to capture also coinductive relations such as simulation, or refinements of it such as ready simulation. Precisely, referring to van Glabbeek's spectrum <ref type="bibr" target="#b20">[Glabbeek 2001</ref>], the operators can capture all refinements of simulation up to ready simulation <ref type="bibr" target="#b5">[Bloom et al. 1995]</ref> (that coincides with its failure analogue, failure simulation). To go further, however, e.g., capturing Groote and Vaandrager's 2-nested simulation <ref type="bibr" target="#b21">[Groote and Vaandrager 1992</ref>] or Milner's bisimilarity <ref type="bibr" target="#b31">[Milner 1989</ref>], one needs extra operators (e.g., negation). In this paper we do not discuss simulation-like relations for which the natural forms of enhancementthe main goal of this paper -are the coinductive ones.</p></div>
<div><head n="4">WEIGHTS</head><p>We are interested in observables that can be measured, that is, whenever ğ‘ƒ âŠ¨ ğœƒ holds then a weight can be assigned to a proof of ğ‘ƒ âŠ¨ ğœƒ . Intuitively, a weight ğ‘› in ğ‘ƒ âŠ¨ ğ‘› ğœƒ means that ğ‘ƒ âŠ¨ ğœƒ can be proved by exploring the transition tree emanating from ğ‘ƒ up to a depth not greater than ğ‘›.</p><p>We thus refine the rules for satisfaction of observables in Section 2 by adding weights and weight constraints. To distinguish the rules with weights we add a '+' to their names:</p><formula xml:id="formula_6">at+ ğ‘ƒ âˆˆ [[a]] ğ‘› â‰¥ 1 ğ‘ƒ âŠ¨ ğ‘› ğœƒ act+ ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² ğ‘ƒ â€² âŠ¨ ğ‘š ğœƒ ğ‘š + 1 â‰¤ ğ‘› ğ‘ƒ âŠ¨ ğ‘› âŸ¨ ğœ‡ âŸ©. ğœƒ conj+ ğ‘ƒ âŠ¨ ğ‘š ğ‘— ğœƒ ğ‘— ğ‘š ğ‘— â‰¤ ğ‘› for each ğ‘— ğ‘ƒ âŠ¨ ğ‘›</formula><p>ğ‘— âˆˆğ½ ğœƒ ğ‘— Thus given an LTS L and a family O of observables over the same set of actions, a process ğ‘ƒ of L, and an observable ğœƒ âˆˆ O, an assertion ğ‘ƒ âŠ¨ ğ‘› ğœƒ holds if derivable from the weighted rules above.</p><p>The condition in rule conj+ ensures us that the trees of transitions emanating from ğ‘ƒ that are explored in the proofs of ğ‘ƒ âŠ¨ ğ‘š ğ‘— ğœƒ ğ‘— , for ğ‘— âˆˆ ğ½ , have a bound in their depth. (In principle, the observables in Definition 2.1 need not be measurable, because they may contain infinite conjunctions. For instance, an observable requiring a process to perform ğ‘› consecutive ğ‘ actions, for each ğ‘›, would not be measurable.) In rule at+, the weight is at least 1 because the atomic observables are local. The only observable for which ğ‘› can be 0 is true, i.e., conj+ with ğ½ empty (or conjunctions of true).</p><p>Remark 4.1. The weights in statements ğ‘ƒ âŠ¨ ğ‘› ğœƒ in this section could be set syntactically, by looking at the depth of nesting of diamond operators in ğœƒ . This however will not hold in the weak semantics of Section 11.</p><p>Example 4.2. Suppose ğ‘ƒ is a process with</p><formula xml:id="formula_7">ğ‘ƒ ğ‘ -â†’ ğ‘ƒ â€² ğ‘ -â†’ ğ‘ƒ â€²â€² . A proof of ğ‘ƒ âŠ¨ 2 âŸ¨ ğ‘ âŸ©. âŸ¨ ğ‘ âŸ©. true is ğ‘ƒ ğ‘ -â†’ ğ‘ƒ â€² ğ‘ƒ â€² ğ‘ -â†’ ğ‘ƒ â€²â€² ğ‘ƒ â€²â€² âŠ¨ 0 true 0 + 1 â‰¤ 1 ğ‘ƒ â€² âŠ¨ 1 âŸ¨ ğ‘ âŸ©. true 1 + 1 â‰¤ 2 ğ‘ƒ âŠ¨ 2 âŸ¨ ğ‘ âŸ©. âŸ¨ ğ‘ âŸ©. true</formula><p>Similarly ğ‘ƒ âŠ¨ ğ‘› âŸ¨ ğ‘ âŸ©. âŸ¨ ğ‘ âŸ©. true, for any ğ‘› â‰¥ 2. However, ğ‘ƒ âŠ¨ 1 âŸ¨ ğ‘ âŸ©. âŸ¨ ğ‘ âŸ©. true does not hold.</p><p>If there is a proof ğ‘ƒ âŠ¨ ğ‘› ğœƒ , then there is also a proof for ğ‘ƒ âŠ¨ ğ‘›+ğ‘– ğœƒ , for any ğ‘–; it suffices to increase by ğ‘– all the weight of the conclusion of the last rule: Lemma 4.3. If ğ‘ƒ âŠ¨ ğ‘› ğœƒ and ğ‘› â‰¤ ğ‘š then also ğ‘ƒ âŠ¨ ğ‘š ğœƒ . Definition 4.4. A family of observables O and the corresponding preorder â‰¾ O are measurable if, for any LTS (over the same set of actions) and process ğ‘ƒ of the LTS, and for any observable ğœƒ âˆˆ O, whenever ğ‘ƒ âŠ¨ ğœƒ then also ğ‘ƒ âŠ¨ ğ‘› ğœƒ holds, for some ğ‘› â‰¥ 0.</p><p>The introduction of weights allows us to define approximations of the behavioural preorders. In Definition 4.5 ğ‘„ âŠ¨ ğœƒ could be replaced by ğ‘„ âŠ¨ ğ‘› ğœƒ . We use ğ‘„ âŠ¨ ğœƒ for uniformity with the weak semantics of Section 11 (c.f., Remark 4.1). Lemma 4.6. Relations â‰¾ O ğ‘› are preorders.</p><formula xml:id="formula_8">Lemma 4.7. If O is measurable, then â‰¾ O = âˆ© ğ‘› â‰¾ O ğ‘› .</formula><p>All preorders discussed in Section 3 are measurable.</p></div>
<div><head n="5">FUNCTIONS FOR INDUCTIVE ENHANCEMENTS</head><p>We recall that, unless otherwise stated, a relation is meant to be a relation on processes. We let R and S range over binary relations, i.e., if â„˜ denotes the powerset construct and Pr the set of all processes, then R and S are elements of â„˜(Pr Ã— Pr). The union of relations R and S is R âˆª S, and their composition is RS (i.e., (ğ‘ƒ, ğ‘ƒ â€² ) âˆˆ RS holds if for some ğ‘ƒ â€²â€² , both (ğ‘ƒ, ğ‘ƒ â€²â€² ) âˆˆ R and (ğ‘ƒ â€²â€² , ğ‘ƒ â€² ) âˆˆ S hold). We often use the infix notation for relations; hence ğ‘ƒ R ğ‘„ means (ğ‘ƒ, ğ‘„) âˆˆ R. We use letters ğ¼ and ğ½ for countable indexing sets in unions, conjunctions, and similar.</p><p>The definition below of semi-progression is essentially the "one-way" version of the progressions in the theory of enhanced coinduction <ref type="bibr" target="#b48">[Sangiorgi 1998</ref>]. The converse clause is missing because we deal with preorders, rather than equivalences as in enhanced coinduction.</p><p>Definition 5.1 (semi-progression). Given two relations R and S, we say that R semi-progresses to S, written R âŸ©â‡€ S, if ğ‘ƒ R ğ‘„ implies:</p><formula xml:id="formula_9">â€¢ whenever ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² , there exists ğ‘„ â€² such that ğ‘„ ğœ‡ -â†’ ğ‘„ â€² and ğ‘ƒ â€² S ğ‘„ â€² .</formula><p>We consider semi-progressions of the form R âŸ©â‡€F (R) where F is a function on relations, i.e. a function from â„˜(Pr Ã— Pr) to â„˜(Pr Ã— Pr). We call these first-order functions, briefly functions. Below, F and G range over such functions.</p><p>In the inductive setting, the definitions of certain behavioural relations make use of atomic observables such as refusals, which do not appear in the definition of bisimulation. To handle them in the theory of inductive enhancements we use the following compliance requirement. <ref type="bibr">Definition 5.2 (compliance)</ref>.</p><formula xml:id="formula_10">A relation R is compliant with O (or simply compliant, if O is clear) if,</formula><p>for all atomic observables a in O and for all ğ‘ƒ R ğ‘„, ğ‘ƒ âŠ¨ a implies ğ‘„ âŠ¨ a.</p><p>Remark 5.3. Separating compliance and (semi-)progression allows us to maintain the standard notion of progression in the literature, which only refers to action transitions. Moreover, in this way progressions and semi-progressions are defined without reference to any family of observables. <ref type="bibr">Definition 5.4 (soundness)</ref>.</p><formula xml:id="formula_11">A function F is sound for â‰¾ O if R âŸ©â‡€F (R) implies R âŠ† â‰¾ O , for any compliant R.</formula><p>Not all functions are sound. An example is the function that maps every relation onto the universal relation (the set of all pairs of processes). We wish to isolate a class of sound functions for which membership is easy to check, which includes interesting functions, and which satisfies interesting properties. For this we propose the notion of weight-preserving function. The usability of this notion will be examined in Section 6.</p><p>Definition 5.5 (weight-preserving function). A function F preserves weights on â‰¾ O when, for all ğ‘› and for all</p><formula xml:id="formula_12">R, if R âŠ† â‰¾ O ğ‘› , then also F (R) âŠ† â‰¾ O ğ‘› . Function F preserves weights if it preserves weights on â‰¾ O , for any â‰¾ O .</formula><p>We first show that indeed any weight-preserving function is sound. Theorem 5.6 (soundness of weight-preserving functions for preorders). If O is measurable and F preserves weights on â‰¾ O , then F is sound for â‰¾ O .</p><p>Proof. Suppose R âŸ©â‡€F (R) with R compliant. We have to show R âŠ† â‰¾ O . Appealing to Lemma 4.7, we show that R âŠ† â‰¾ O ğ‘› , for all ğ‘›, by induction on ğ‘›. Details may be found in the Appendix.</p><p>Remark 5.7. In the proof of Theorem 5.6 it may be puzzling that compliance for R is ensured by hypothesis, but no analogous hypothesis is made on F (R). However F preserves weights, which, given the hypothesis of the theorem, entails compliance for F (R).</p><p>Remark 5.8. If in Definition 5.5 we had taken 'preserving weights for â‰¾ O ' to mean</p><formula xml:id="formula_13">'whenever R âŠ† â‰¾ O then also F (R) âŠ† â‰¾ O ', ( * )</formula><p>the theorem above would not hold. As a counterexample, consider processes that are purely sequential and deterministic, i.e., mere sequences of actions such as ğ‘ 1 . . . . ğ‘ ğ‘› , and a function F that removes the first action of the processes; for instance, yielding Technically, in the proof of Theorem 5.6 we do not know whether R âŠ† â‰¾ O holds, hence we cannot use property ( * ) in the proof (the current proof goes by induction, hence at step ğ‘› + 1 we can exploit the weight property for â‰¾ O ğ‘› ).</p><formula xml:id="formula_14">F ({(ğ‘ 1 . . . . ğ‘ ğ‘› , ğ‘ 1 . . . . ğ‘ ğ‘š )})= {(ğ‘ 2 . . . . ğ‘ ğ‘› , ğ‘ 2 . . . . ğ‘ ğ‘š )}. If â‰¾ O is</formula><p>Remark 5.9 (completeness). By completeness for a preorder â‰¾ O , we refer to the possibility of handling any relation R âŠ† â‰¾ O in the framework. We can distinguish completeness for sound functions, meaning that for any R âŠ† â‰¾ O there is a sound function F with R âŸ©â‡€F (R); and the analogous completeness for weight-preserving functions.</p><p>The inductive enhancements are trivially complete for sound functions: the function that maps a relation R onto the universal relation if R âŠ† â‰¾ O , and to the empty relation otherwise, is sound.</p><p>In the form stated above, completeness for weight-preserving functions fails. For instance, taking â‰¾ TR to be the trace preorder, there are processes ğ‘ƒ, ğ‘„ such that ğ‘ƒ â‰¾ TR ğ‘„ but there is no compliant relation R containing the pair (ğ‘ƒ, ğ‘„) that semi-progresses to F (R) for some F that preserves weights. To see this, consider ğ‘ƒ However a weaker form of completeness holds: if ğ‘ƒ â‰¾ ğ‘„ then there is a weight-preserving function F and a compliant relation R with ğœ‡. ğ‘ƒ R ğœ‡. ğ‘„, for some ğœ‡, and with R âŸ©â‡€F (R) (we can use for this the constant function that maps any relation onto the trace preorder). We can then derive ğ‘ƒ â‰¾ ğ‘„ from ğœ‡. ğ‘ƒ â‰¾ ğœ‡. ğ‘„ using the cancellation law for prefixes</p><formula xml:id="formula_15">'ğœ‡. ğ‘ƒ â‰¾ ğœ‡. ğ‘„ implies ğ‘ƒ â‰¾ ğ‘„'</formula><p>The law is valid in all preorders of Section 3; in fact, it is valid in any preorder whose grammar for observables includes the diamond operator (see on this also the Appendix).</p></div>
<div><head n="6">INSTANCES OF ENHANCEMENT</head><p>We test the usability of the weight-based condition for enhancements (Definition 5.5). We show that a number of useful functions preserve weights. For this we also introduce forms of functional composition that preserve weights, with the idea of producing complex sound functions from simpler ones. The first-order and higher-order functions considered in this section are inspired by the most common ones used in coinductive enhancements. Below we omit the family O when clear, e.g., abbreviating â‰¾ O as â‰¾.</p><p>Basic functions and constructors. A function that takes first-order functions as arguments and yields back another first-order function as a result is a second-order function or, briefly, a constructor. A constructor preserves weights if whenever its first-order function arguments preserve weights on â‰¾, then also the first-order function result preserves weights on â‰¾, for any â‰¾.</p><p>We write I for the identity function, and X for the reflexive function, mapping any relation onto the purely reflexive relation whose elements are all pairs of the form (ğ‘ƒ, ğ‘ƒ). For a given preorder â‰¾, we write U â‰¾ for the constant-to-â‰¾ function, mapping every relation onto the preorder â‰¾ itself. Lemma 6.1 (identity and constant-to-â‰¾ functions). The identity function I, the reflexive function X, and the constant-to-â‰¾ function U â‰¾ preserve weights on â‰¾, for any â‰¾.</p><p>The basic constructors we consider are composition ( â€¢ ), union (âˆª) and chaining ( âŒ¢ ), so defined:</p><formula xml:id="formula_16">(G â€¢ F ) (R) def = G(F (R)) ( ğ‘– âˆˆğ¼ F ğ‘– ) (R) def = ğ‘– âˆˆğ¼ (F ğ‘– (R)) (G âŒ¢ F ) (R) def = G(R) F (R) = {(ğ‘ƒ, ğ‘ƒ â€² ) | âˆƒ ğ‘ƒ â€²â€² . (ğ‘ƒ, ğ‘ƒ â€²â€² ) âˆˆ G(R) , (ğ‘ƒ â€²â€² , ğ‘ƒ â€² ) âˆˆ F (R) }</formula><p>(Formally, for arity reasons, there is a different union operator for all ğ‘› âˆˆ {0, 1, . . . , ğœ” }.) Lemma 6.2 (composition, union, chaining). The composition, union and chaining constructors preserve weights.</p><p>Derived functions. We derive now more complex functions, exploiting the earlier basic functions and constructors. Then we examine the context-closure function.</p><p>Corollary 6.3. The following functions preserve weights on â‰¾, for any â‰¾:</p><formula xml:id="formula_17">D ğ‘› def = I âŒ¢ . . . âŒ¢ I , ğ‘› times (ğ‘› &gt; 0) P â‰¾ def = U â‰¾ âŒ¢ I âŒ¢ U â‰¾ T def = ğ‘›&gt;0 D ğ‘› B def = X âˆª T</formula><p>On a relation R: function D ğ‘› makes the composition of R with itself ğ‘› times; function P â‰¾ is the 'preorder counterpart' of the 'bisimulation up to bisimilarity' enhancement <ref type="bibr" target="#b31">[Milner 1989</ref>], as (ğ‘ƒ, ğ‘„) âˆˆ P â‰¾ (R) if there are ğ‘ƒ â€² and ğ‘„ â€² with ğ‘ƒ â‰¾ ğ‘ƒ â€² R ğ‘„ â€² â‰¾ ğ‘„; function T returns the transitive closure of R; function B returns the preorder induced by R (the reflexive and transitive closure of R).</p><p>The composition and union constructors are particularly useful. Composition allows us to freely combine a set of weight-preserving functions, and union allows us to use different combinations of the functions in different parts of a proof. We formalise this via the closure construction below, which we shall use later in examples.</p><p>Let {F 1 , . . . , F ğ‘š } be a set of functions. It is convenient to assume that the identity I is in the set, otherwise we can add it. Abbreviating {F 1 , . . . , F ğ‘š } as F , the ğ‘›-th closure of a relation R with respect to F , written L F ğ‘› (R), is inductively defined as follows:</p><formula xml:id="formula_18">L F 1 (R) def = I (R) = R L F ğ‘›+1 (R) def = ğ‘– F ğ‘– (L F ğ‘› (R)) As I âˆˆ F , we have L F ğ‘› (R) âŠ† L F ğ‘›+1 (R), for any ğ‘›. Then the closure L F (R) with respect to F is L F (R) def = ğ‘› L F ğ‘› (R).</formula><p>Thus a pair of processes is in the closure L F (R) if the pair can be obtained starting from R and then applying the functions in F an arbitrary number of times, using composition and union. Corollary 6.4. If functions F preserve weights on â‰¾, then so does the closure function L F . Context closure. We now introduce a function that gives us the context-closure of a relation. For this, we have to assume -as usual in process algebras -that the class of processes is defined as the term algebra generated by some signature. A context is a an element of the term algebra with at most one occurrence of the hole [â€¢] in it, taking [â€¢] as a further operator of the signature with arity 0. Definition 6.5. If C is a set of contexts, then the C -closure function is the function C C that takes a relation and returns the closure of that relation with respect to the contexts in C :</p><formula xml:id="formula_19">C C (R) def = {(ğ¶ [ğ‘ƒ], ğ¶ [ğ‘„]) | ğ‘ƒ R ğ‘„ and ğ¶ is a context in C }</formula><p>We simply write C when C is the set of all contexts, and call it the context-closure function.</p><p>It is sufficient to use contexts with at most one occurrence of a unique hole. More sophisticated closures, involving ğ‘›-ary contexts, i.e., contexts that may contain different holes, to be filled with possibly different processes, can be recovered with a combination of the function C C and the transitive-closure function as</p><formula xml:id="formula_20">T â€¢ C C .</formula><p>We present an abstract property on contexts that can be used to show that the corresponding function C C preserves weights. The proof is straightforward, following the definitions. Below we discuss a CCS language, showing that all its contexts are measurably faithful for the observables required by all the preorders discussed in Section 3.</p><p>Context closure in CCS ! . We have so far developed a theory of inductive enhancements based on functions that are weight-preserving and, earlier in this section, we have presented a number of functions that are captured by such a theory. Among them we have discussed the context-closure function, introducing an abstract condition on contexts, measurable faithfulness, that guarantees soundness. Below we show an example of how such a property can be proved. For this, however, we have to pick a specific language and family of observables. Thus the language is essentially CCS and the observables are any family used for the preorders examined in Section 3.</p><p>We assume a (countably) infinite set {ğ‘, ğ‘, . . . , } of names, which does not contain the special symbol ğœ. The class of the CCS ! processes is built from the operators of input prefix, output prefix, silent prefix, parallel composition, countable sum, restriction, and replication:</p><formula xml:id="formula_21">ğ‘ƒ := ğœ‡. ğ‘ƒ | ğ‘ƒ 1 | ğ‘ƒ 2 | ğ‘– âˆˆğ¼ ğ‘ƒ ğ‘– | ğ‚ğ‘ ğ‘ƒ | !ğ‘ƒ ğœ‡ := ğ‘ | ğ‘ | ğœ .</formula><p>We sometimes use the binary sum ğ‘ƒ 1 + ğ‘ƒ 2 ; and write 0 for the sum in which the indexing set is empty. We have omitted the relabeling operator (it would not however bring complications into the theory), and included replication, which will be used in some examples --hence the name CCS ! . (Other operators could be added to the process language, see Remark 6.10.) The operational semantics of the calculus is reported in the Appendix. Lemma 6.8. In CCS ! , all contexts are measurably faithful for O, for all the families of observables O described in Section 3 (i.e., from those yielding trace preorder to those yielding ready trace preorder). Corollary 6.9. In CCS ! , the context-closure function C (Definition 6.5) preserves weights on â‰¾ O , for all the families of observables O described in Section 3.</p><p>We can thus combine the 'up-to context' function C with other weight-preserving functions, using the constructors introduced earlier in this section. For instance we thus obtain the soundness of the 'up-to ğ‘›-ary context' function C T def = T â€¢ C or, for any preorder â‰¾, and of the 'up-to â‰¾ and context' function</p><formula xml:id="formula_22">C â‰¾ def = P â‰¾ â€¢ C = U â‰¾ âŒ¢ C âŒ¢ U â‰¾ . That is, C â‰¾ (R) def = {(ğ‘ƒ, ğ‘„) | there are ğ‘ƒ â€² , ğ‘„ â€² , ğ¶ with ğ‘ƒ â‰¾ ğ¶ [ğ‘ƒ â€² ], ğ¶ [ğ‘„ â€² ] â‰¾ ğ‘„ and ğ‘ƒ â€² Rğ‘„ â€² }</formula><p>(The function can be made more powerful using T â€¢ C C . in place of C.) Function C â‰¾ is the counterpart of the common 'up-to context and bisimilarity' enhancement of the coinductive setting, with a preorder in place of an equivalence.</p><p>Remark 6.10. Corollary 6.9 can be strengthened to show that the set of contexts produced by the operators of CCS ! preserves weights in any extension of the language. That is, consider a process language whose contexts include the set C described by the following grammar:</p><formula xml:id="formula_23">ğ¶ := ğœ‡. ğ¶ | ğ¶ | ğ‘ƒ | ğ‘ƒ | ğ¶ | ğ¶ + ğ‘ƒ | ğ‘ƒ + ğ¶ | ğ‚ğ‘ ğ¶ | !ğ¶</formula><p>where ğ‘ƒ is any process of the language and where, for simplicity, we use only binary sums. Then function C C preserves weights. In some of the examples we shall indeed employ extensions of CCS ! , for instance including a recursion operator.</p></div>
<div><head n="7">EQUIVALENCES</head><p>The equivalence induced by a preorder â‰¾ is â‰¾ âˆ© â‰¿. We write âˆ¼ O for the equivalence induced by the preorder â‰¾ O ; we simply write âˆ¼ when non ambiguous. All definitions and results in previous sections can be straightforwardly extended to equivalences, simply adding the 'converse direction'. Below are the main results needed for obtaining the enhancement techniques. In particular, we move from semi-progressions to progressions. We write R -1 for the inverse of a relation R.</p><p>Definition 7.1 (progression). Given two relations R and S, we say that R progresses to S, written R âŸ©â†’ S, if both R âŸ©â‡€ S and R -1 âŸ©â‡€ S -1 .</p></div>
<div><head>Definition 7.2 (soundness, for equivalences). A function</head><formula xml:id="formula_24">F is sound for âˆ¼ O if R âŸ©â†’F (R) implies R âŠ† âˆ¼ O .</formula><p>In the definition of soundness, now compliance is not mentioned as implied by the use of progressions in place of semi-progressions. The function and constructors examined in Section 6 for preorders and semi-progressions may thus be used to reason about equivalences.</p></div>
<div><head n="8">EXAMPLE 1: CONGRUENCE FOR RECURSION</head><p>A congruence proof that is notoriously delicate in concurrency concerns the recursion operator. In this section we show that the enhancement techniques can relieve such a proof. Precisely we exhibit a congruence proof that is parametric on the process language and the preorder â‰¾. Besides some mild assumptions, we only require â‰¾ to be measurable (Definition 4.4). Below we sketch the elements for the proof, referring to the Appendix for more details.</p><p>The language includes a recursion operator rec ğ‘‹ . ğ‘ƒ, which, as usual, represents a binding occurrence for ğ‘‹ in the body ğ‘ƒ. The main assumptions on language and preorder are: the presence of an action prefix operator ğœ‡. ğ‘ƒ, akin to CCS prefix, so to be able to say that an expression ğ¸ is guarded in ğº if all occurrences of ğ¸ in ğº are underneath a prefix; the variable ğ‘‹ of a recursion rec ğ‘‹ . ğ¸ is guarded in the body ğ¸; a cancellation property for prefixes, that is, ğœ‡. ğ‘ƒ â‰¾ ğœ‡. ğ‘„ implies ğ‘ƒ â‰¾ ğ‘„. (These are basic and standard assumptions, see also the discussion in the Appendix.)</p><p>We use ğ‘‹, ğ‘Œ as recursion variables, and write fv(ğº) for the free recursion variables of an expression ğº. We let ğ¸, ğ¹, ğº range over open expressions (i.e., expressions that may contain free occurrences of the recursion variables), and ğ‘ƒ, ğ‘„ over the closed ones. A preorder â‰¾ is extended to open expressions ğ¸, ğ¹ , with fv(ğ¸, ğ¹ ) âŠ† { ğ‘‹ }, by stipulating that ğ¸ â‰¾ ğ¹ if ğ¸{ ğ‘ƒ / ğ‘‹ } â‰¾ ğ¹ { ğ‘ƒ / ğ‘‹ } for all closed processes ğ‘ƒ. (processes in R are closed, thus ğº has at most ğ‘Œ as a free recursion variable). If we show R âŠ† â‰¾, then we are done: we have ğœ‡. ğ‘ƒ R ğœ‡. ğ‘„, for any ğœ‡, and then the result in the theorem follows from the cancellation property on prefixes. Relation R is compliant; we prove the semi-progression</p><formula xml:id="formula_25">R âŸ©â‡€P â‰¾ (R) (that is, R âŸ©â‡€â‰¾Râ‰¾).</formula><p>For this, we consider a transition ğº { ğ‘ƒ /ğ‘Œ } ğœ‡ -â†’ ğ‘ƒ â€² and show that we can find ğº # guarded such that</p><formula xml:id="formula_26">ğ‘ƒ â€² â‰¾ ğº # { ğ‘ƒ /ğ‘Œ } and ğº { ğ‘„ /ğ‘Œ } ğœ‡ -â†’ â‰¿ ğº # { ğ‘„ /ğ‘Œ }</formula><p>We first write ğ‘ƒ â€² as ğº * { ğ‘ƒ /ğ‘Œ }, for some ğº * , and on the unguarded occurrences of ğ‘Œ in ğº * we unfold the substitution { ğ‘ƒ /ğ‘Œ } as { (ğ¸{ ğ‘ƒ /ğ‘‹ }) /ğ‘Œ }. We proceed similarly on ğº { ğ‘„ /ğ‘Œ } and, in addition, we replace all unguarded occurrences of ğ¹ so produced with ğ¸, using the hypothesis of the theorem. We extract ğº # from the final expression.</p><p>The result can be transported to the equivalence induced by the preorder, exploiting the result for the preorder.</p></div>
<div><head n="9">EXAMPLE 2: TWO SERVERS</head><p>We use the enhancement techniques to related two servers, and some variants of them. The results are valid for all preorders of Sections 3 and their induced equivalences; the last two systems may however be related only by the preorders. None of the results are valid for coinductive behavioral relations such as bisimilarity (not even for similarity). Thus in this section â‰¾ is any of the preorders of Sections 3, and âˆ¼ its induced equivalence.</p><p>As a language, we use the value-passing version of the CCS language in Section 6. While the value-passing language could be translated into pure CCS <ref type="bibr" target="#b31">[Milner 1989</ref>], having explicit values improves readability (adapting the results in this paper to value-passing CCS anyhow is simple). In a value-passing calculus, ğ‘(ğ‘¥). ğ‘ƒ is an input at ğ‘ in which ğ‘¥ is the placeholder for the value received, whereas ğ‘âŸ¨ğ‘›âŸ©. ğ‘ƒ is an output at ğ‘ of the value ğ‘›.</p><p>We wish to implement a server that may be interrogated by clients at a channel ğ‘, so to start a certain interaction protocol with the client; for this however the server must also consult two auxiliary servers ğ´ and ğµ, respectively at ğ‘ and ğ‘. The auxiliary servers ğ´ and ğµ are nondeterministic, and always return, respectively, an arbitrary integer and arbitrary boolean (we write t and f for the two boolean values):</p><formula xml:id="formula_27">ğ´ def = ! Î£ ğ‘› âˆˆğ‘ ğ‘âŸ¨ğ‘›âŸ© ğµ def = ! (ğ‘ âŸ¨tâŸ© + ğ‘ âŸ¨fâŸ©)</formula><p>We consider two implementations, ğ¿ and ğ‘€, of the server. The difference between them is that the order in which the two auxiliary servers are interrogated is swapped. Both servers are represented using a replication operator; a channel ğ‘’ is used to activate a new copy of the body of the replication. Here ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§) represents the interaction protocol that is started with a client, and can be any process. It may use, and depend on, the values ğ‘§, ğ‘¥ and ğ‘¦ (obtained from the client and the auxiliary servers). Process ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§) may also use channel ğ‘, and therefore trigger further interactions with the server; in contrast, ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§) may not use ğ‘ and ğ‘ to interrogate the auxiliary servers. We wish to relate the composition of the two servers with the auxiliary servers ğ´ and ğµ :</p><formula xml:id="formula_28">ğ¿ğ‘† def = (ğ‚ğ‘, ğ‘) (ğ´ | ğµ | ğ¿) ğ‘€ğ‘† def = (ğ‚ğ‘, ğ‘) (ğ´ | ğµ | ğ‘€)</formula><p>We prove ğ¿ğ‘† âˆ¼ ğ‘€ğ‘† using the enhancements (where âˆ¼ is the equivalence induced by any of the preorders in Section 3). The relation R we use for this is a singleton, and has just one pair, namely (ğ¿ğ‘†, ğ‘€ğ‘†). The relation is compliant; we show the progression R âŸ©â†’C â‰¾ (R) (i.e., R âŸ©â†’â‰¾C (R)â‰¾), so to conclude ğ¿ğ‘† âˆ¼ ğ‘€ğ‘† by Theorem 7.3. For this, we consider the semi-progression R âŸ©â‡€C â‰¾ (R), the converse direction being similar. The only immediate transitions of the two processes are: We now apply some simple and common laws, valid even for bisimilarity (the expansion law, laws for shrinking the scope of a restriction, and for duplicating a replication) so to explicitly internalise the interactions of ğ¿ 1 and ğ‘€ 1 with the auxiliary servers and obtain: We can proceed similarly on ğ‘€ğ‘†. Thus, also rearranging the order of the summands, we have:</p><formula xml:id="formula_29">ğ¿ğ‘† ğ‘’ -â†’ (ğ‚ğ‘, ğ‘) (ğ´ | ğµ | ğ¿ 1 | ğ¿) def = ğ¿ğ‘† 1 ğ‘€ğ‘† ğ‘’ -â†’ (ğ‚ğ‘, ğ‘) (ğ´ | ğµ | ğ‘€ 1 | ğ‘€) def = ğ‘€ğ‘† 1 where ğ¿ 1 def = ğ‘ (ğ‘¦). ğ‘<label>(</label></formula><formula xml:id="formula_30">ğ¿ğ‘† 1 âˆ¼ ğ¿ 2 | ğ¿ğ‘†</formula><formula xml:id="formula_31">ğ¿ğ‘† ğ‘’ -â†’ âˆ¼ ğ¿ 3 | ğ¿ğ‘† ğ‘€ğ‘† ğ‘’ -â†’ âˆ¼ ğ¿ 3 | ğ‘€ğ‘†</formula><p>This closes the proof, up to â‰¾ and context, since ğ¿ğ‘† R ğ‘€ğ‘† and âˆ¼ implies both â‰¾ and its inverse.</p><p>The above results cannot be proved purely algebraically using standard axiom systems for the preorders or equivalences, because the systems compared are not finite or finite state (axiomatisations are complete only on these systems, and do not contain, for instance, axioms for inverting the order of prefixes in a process). One could proceed reasoning by induction on, e.g., the length of the involved traces; the proof would be tedious, for instance because ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§) can be any process.</p><p>The result does not hold under bisimilarity, which is too fine a relation. The reason is that, intuitively, ğ¿ğ‘† 1 can produce an interaction at ğ‘ involving the auxiliary server ğµ that makes a commitment to using a specific boolean in the communication protocol with the next client. In contrast, ğ‘€ğ‘† 1 makes an initial commitment on the integer to be used, in an interaction involving the other auxiliary server ğ´. Thus the transition from ğ¿ğ‘† 1 cannot be matched by ğ‘€ğ‘† 1 , and conversely. (Indeed the two systems may not even be related by similarity.)</p><p>Consider now a variant of the first server, ğ¿, that throws away the boolean received at ğ‘ and always uses the boolean t:</p><formula xml:id="formula_32">ğ¿ def = !ğ‘’. ğ‘ (ğ‘¦). ğ‘ (ğ‘§). ğ‘(ğ‘¥). (ğ‘’ |ğ‘…(ğ‘, ğ‘¥, t, ğ‘§))</formula><p>In this case ğ¿ğ‘† âˆ¼ ğ‘€ğ‘† does not hold. We can however take the preorder â‰¾ and prove ğ¿ğ‘† â‰¾ ğ‘€ğ‘†, using the semi-progression R âŸ©â‡€C â‰¾ (R). The main difference with the proof above is that we also use the law ğœ. ğ‘ƒ â‰¾ ğœ. ğ‘ƒ + ğœ. ğ‘„ (again, this law is valid for all preorders discussed in Section 3). Intuitively, in a preorder, a deterministic system is 'below' a non-deterministic one. This kind of reasoning cannot be made for bisimilarity, which, as discussed in Section 1, does not have a natural associated preorder.</p></div>
<div><head n="10">EXAMPLE 3: HENNESSY'S PROOF SYSTEM FOR THE TRACE PREORDER</head><p>In this section we use the theory of enhanced induction to prove the soundness of Hennessy's proof system for the trace preorder <ref type="bibr" target="#b23">[Hennessy 2017</ref>]. The motivation for the example is twofold: it allows us to explain the peculiarities of Hennessy's proof (his proof system is a non-standard one, in the realm of behavioural preorders) using the theory of enhancements; it involves a combination of several functional enhancements.</p><p>The structure of Hennessy's proof system follows Salomaa's <ref type="bibr" target="#b47">[Salomaa 1966</ref>] for trace equivalence (called language equivalence in <ref type="bibr" target="#b47">[Salomaa 1966</ref>], trace equivalence being a more common terminology for behavioural equivalences); related works are also Kozen <ref type="bibr" target="#b27">[Kozen 1994</ref>] and Rabinovich <ref type="bibr" target="#b43">[Rabinovich 1993</ref>]. The most important difference in Hennessy's system is that Salomaa's key rule, unique fixed-point induction (Ufi), is replaced by rule</p><formula xml:id="formula_33">CoRec CoRec Î“, ğ‘. ğ‘ƒ 1 â‰¤ ğ‘. ğ‘ƒ 2 âŠ¢ ğ‘ƒ 1 â‰¤ ğ‘ƒ 2 Î“ âŠ¢ ğ‘. ğ‘ƒ 1 â‰¤ ğ‘. ğ‘ƒ 2 ( * )</formula><p>(the rule has a coinductive flavour because the conclusion of the rule is one of its hypotheses, though the proof system is inductive). Indeed, as Hennessy deals with a preorder rather than an equivalence, it is unclear what could be a complete induction principle to be used in place of Ufi. The new 'coinductive' rule, however, makes the soundness of Hennessy system delicate; see <ref type="bibr">[Hennessy 2017, section 5]</ref> for a discussion. The language is the following subset of CCS:</p><formula xml:id="formula_34">ğ¸ := 0 | ğœ‡. ğ¸ | ğ¸ 1 + ğ¸ 2 | ğ‘‹ | rec ğ‘‹ . ğ¸</formula><p>The variable ğ‘‹ of a recursion rec ğ‘‹ . ğ¸ is guarded in the body ğ¸. We maintain the notations for earlier process languages, e.g., in Section 8, and let ğ¸, ğ¹, ğº range over open expressions, and ğ‘ƒ, ğ‘„, ğ‘… over the closed ones. In this section, following Salomaa and others <ref type="bibr" target="#b27">[Kozen 1994;</ref><ref type="bibr" target="#b43">Rabinovich 1993;</ref><ref type="bibr" target="#b47">Salomaa 1966</ref>] we take the ordinary trace preorder. Hennessy works in a weak semantics, which abstracts from ğœ actions; the proof for weak semantics is discussed in Section 14. In the proof system, judgments are of the form Î“ âŠ¢ ğ‘ƒ â‰¤ ğ‘ƒ â€² , where ğ‘ƒ, ğ‘ƒ â€² are closed terms, and Î“ is a finite set of assumptions of the form ğ‘ƒ â‰¤ ğ‘ƒ â€² . The whole proof system is reported in the Appendix. Example of rules are, besides CoRec above, the following ones, where Tr is transitivity, Pl is the structural rule for sum, Hyp and W deal with the assumptions:</p><formula xml:id="formula_35">Tr Î“ âŠ¢ ğ‘ƒ 1 â‰¤ ğ‘ƒ 2 Î“ âŠ¢ ğ‘ƒ 2 â‰¤ ğ‘ƒ 3 Î“ âŠ¢ ğ‘ƒ 1 â‰¤ ğ‘ƒ 3 Pl Î“ âŠ¢ ğ‘ƒ â‰¤ ğ‘ƒ â€² Î“ âŠ¢ ğ‘ƒ + ğ‘„ â‰¤ ğ‘ƒ â€² + ğ‘„ Hyp ğ‘ƒ â‰¤ ğ‘ƒ â€² âŠ¢ ğ‘ƒ â‰¤ ğ‘ƒ â€² W Î“ â€² âŠ¢ ğ‘ƒ â‰¤ ğ‘ƒ â€² Î“ â€² âŠ† Î“ Î“ âŠ¢ ğ‘ƒ â‰¤ ğ‘ƒ â€²</formula><p>Hennessy's soundness proof makes use of a semantic interpretation of the judgments Î“ âŠ¢ ğ‘ƒ â‰¤ ğ‘„ . Using â‰¾ TR for the trace preorder, the obvious choice would be to interpret a judgment</p><formula xml:id="formula_36">ğ‘ƒ 1 â‰¤ ğ‘ƒ â€² 1 , . . . , ğ‘ƒ ğ‘š â‰¤ ğ‘ƒ â€² ğ‘š âŠ¢ ğ‘ƒ â‰¤ ğ‘ƒ â€² (1)</formula><p>as valid whenever ğ‘ƒ ğ‘– â‰¾ TR ğ‘ƒ â€² ğ‘– for each ğ‘– âˆˆ {1, . . . , ğ‘š} implies ğ‘ƒ â‰¾ TR ğ‘ƒ â€² . It turns out that this is unsound <ref type="bibr" target="#b23">[Hennessy 2017</ref>]. Therefore Hennessy uses a stratified semantic interpretation inspired by the soundness proof of Brandt and Henglein's proof system for recursive types <ref type="bibr" target="#b11">[Brandt and Henglein 1998</ref>]. Recasted in our notation, the semantic interpretation says that a judgment (1) is valid if, for all ğ‘›, ğ‘ƒ ğ‘– â‰¾ TR ğ‘› ğ‘ƒ â€² ğ‘– for each ğ‘– âˆˆ {1, . . . , ğ‘š} implies ğ‘ƒ â‰¾ TR ğ‘› ğ‘ƒ â€² . In the soundness proof each proof rule is shown to preserve the stratified semantics. The unsoundness of the non-stratified interpretation of judgments recalls the unsoundness of the definition of weight-preserving in Remark 5.8. Similarly, the stratification and the implication in the validity assertion recall those in the definition of weight-preserving functions (Definition 5.5 ).</p><p>Indeed, reformulated in our setting, each proof rule corresponds to a function that preserves weights. Such functions include: the transitive-closure function T , the identity function I, the context-closure function C, the reflexive function X, the constant-to-â‰¾ TR function U â‰¾ TR . Call F the set of all such functions. Then the crux of the proof consists in showing that any given proof tree ğ›¿ yields a relation R ğ›¿ on processes that semi-progresses to the closure L F (R). That is, we use the semi-progression R ğ›¿ âŸ©â‡€L F (R ğ›¿ ), which, by Corollary 6.4, preserves weights.</p><p>More precisely, R ğ›¿ is the set all pairs (ğ‘. ğ‘ƒ 1 , ğ‘. ğ‘ƒ 2 ) for which there is a CoRec node in ğ›¿ of the form ( * ) above, for some Î“. For the semi-progression to hold, we then have to show that for any such (ğ‘. ğ‘ƒ 1 , ğ‘. ğ‘ƒ 2 ) âˆˆ R ğ›¿ we have (ğ‘ƒ 1 , ğ‘ƒ 2 ) âˆˆ L F (R ğ›¿ ). We derive this from the following property:</p><formula xml:id="formula_37">if Î” âŠ¢ ğ‘ƒ â‰¤ ğ‘„ is a node in ğ›¿ then (ğ‘ƒ, ğ‘„) is in the closure L F (R ğ›¿ ) of R ğ›¿ .</formula><p>The proof proceeds by induction of the depth of ğ›¿, using a case analysis on the rule whose conclusion is the root of ğ›¿. As an example, if the last rule is Tr, then the node is of the form</p><formula xml:id="formula_38">Tr Î” âŠ¢ ğ‘ƒ â‰¤ ğ‘… Î” âŠ¢ ğ‘… â‰¤ ğ‘„ Î” âŠ¢ ğ‘ƒ â‰¤ ğ‘„</formula><p>By induction, (ğ‘ƒ, ğ‘…) and (ğ‘…, ğ‘„) are in the closure L F (R). Hence also (ğ‘ƒ, ğ‘„) is in the closure, as the transitive-closure function is in F . Similarly, if the rule is Pl, the node is of the form</p><formula xml:id="formula_39">Pl Î” âŠ¢ ğ‘ƒ â‰¤ ğ‘„ Î” âŠ¢ ğ‘ƒ + ğ‘… â‰¤ ğ‘„ + ğ‘…</formula><p>By induction, (ğ‘ƒ, ğ‘„) is in the closure L F (R); hence, also (ğ‘ƒ + ğ‘…, ğ‘„ + ğ‘…), as the context-closure function is in F .</p></div>
<div><head n="11">WEAK SEMANTICS</head><p>By weak semantics we refer to behavioural relations that distinguish between internal process activities and visible actions. In this section and up to Section 14 we discuss the extension of the theory presented to behavioural relations obtained from weak inductive observables.</p></div>
<div><head n="11.1">Differences between Strong and Weak Semantics</head><p>There are two major differences with respect to the theory of strong semantics in earlier sections. The first difference concerns weights and relational progressions. We begin by examining weights for weak observables similar to those used for the strong observables. However, as some useful enhancements are not captured, we then also consider more sophisticated weights, namely composite weights that separate the contributions of internal actions from that of the external ones. This in turn yields progressions in which different functions may be employed according to whether the action performed is internal or external.</p><p>The other main difference is that the observables used in weak semantics may refer to state predicates such as stability, that did not appear in the observables for the strong semantics. For instance, all the preorders discussed in Section 3 except trace equivalence mention ready or refusal sets of processes. In weak semantics, the observations of such sets are only made on stable processes.</p><p>The second of the two differences above is specific to the inductive setting, as with bisimulation state predicates like stability are usually ignored. In contrast, the first difference is related to the soundness problems of weak coinductive enhancements -due to which theories of weak coinductive enhancements tend to be rather more involved than the 'strong' theories. Some of the technical solutions that we adopt for the inductive setting are inspired from those used in the coinductive setting, others are specific to the weight-based conditions of the inductive setting.</p></div>
<div><head n="11.2">Weak Observables</head><p>The set of actions Ağ‘ğ‘¡ now contains a special element ğœ that represents internal activities in a process. As before, ğœ‡ ranges over Ağ‘ğ‘¡. We now use â„“ to range over Ağ‘ğ‘¡ -{ğœ }, the visible (or external) actions. Some standard notations for weak transitions: =â‡’ is the reflexive and transitive closure of With respect to the strong case, the additional requirement âŸ¨âŸ¨ ğœ âŸ©âŸ©. ğœƒ âˆˆ O is needed in the soundness proofs; intuitively it is part of the downward-closure property because a process with an observable âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. ğœƒ will also have the observable âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. âŸ¨âŸ¨ ğœ âŸ©âŸ©. ğœƒ .</p><p>Satisfaction is defined as in the strong case; the only difference is in the weak diamond where abstraction from internal transition is expressed.</p><p>w-act</p><formula xml:id="formula_40">ğ‘ƒ ğœ‡ = â‡’ ğ‘ƒ â€² ğ‘ƒ â€² âŠ¨ ğœƒ ğ‘ƒ âŠ¨ âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. ğœƒ w-conj ğ‘ƒ âŠ¨ ğœƒ ğ‘— for all ğ‘— âˆˆ ğ½ ğ‘ƒ âŠ¨ ğ‘— âˆˆğ½ ğœƒ ğ‘— w-at ğ‘ƒ âˆˆ [[a]] ğ‘ƒ âŠ¨ a</formula><p>In w-act, when ğœ‡ = ğœ process ğ‘ƒ need not move, hence we may have ğ‘ƒ â€² = ğ‘ƒ.</p><p>In the strong case, to derive the preorders of Section 3 we used the atomic observable ref ğœ‡ and the 'barb' observable âŸ¨ ğœ‡ âŸ©. true. Their weak counterpart, Ref ğœ‡ and Acc ğœ‡ , are both atomic since employed on stable processes:</p><formula xml:id="formula_41">ğ‘ƒ âˆˆ Ref â„“ if (ğ‘ƒ stable and ğ‘ƒ Ì¸ â„“ -â†’) ğ‘ƒ âˆˆ Acc â„“ if (ğ‘ƒ stable and ğ‘ƒ â„“ -â†’)</formula><p>More generally, as in the strong case, the atomic observables should be local: they can be checked by looking only at the immediate outgoing transitions emanating from a state. The preorder induced by a family O of weak observables is written â‰¾ O .</p><p>When the atomic observables refer to stability, the preorder may distinguish between stable and non-stable processes such as ğœ. ğ‘ and ğ‘ (however ğœ‡. ğœ. ğ‘ƒ and ğœ‡. ğ‘ƒ are always equated). Such distinctions are often found in the literature (the resulting preorders are sometimes called rooted), and are needed to guarantee substitutivity of the preorder on operators such as summation.</p><p>Remark 11.2 (Non-local atomic observables and divergence). Non-local atomic observables can be accommodated in the theory, but care would be required in the context-closure function, which may become troublesome. In the literature for weak semantics, a non-local observable that is sometimes found is divergence (a process is divergent if it can perform an infinite sequente of ğœ-transitions). There are many ways in which divergence is taken into account in the literature. For instance, in failure equivalence sometimes divergence is taken as chaotic <ref type="bibr">[Brookes et al. 1984]</ref>, in that a divergent process is supposed to have all possible failures; similarly, in ready semantics, when testing processes, sometimes divergence is taken to yield a separate outcome (besides the ordinary success and failure outcomes). Indeed, a number of variations are possible, see e.g., discussions in <ref type="bibr" target="#b4">[Bergstra et al. 1987;</ref><ref type="bibr" target="#b19">Glabbeek 1993]</ref>. Most important, divergence is a coinductive predicate, whereas the theory developed in this paper deals with observables that are inductively defined.</p><p>A comprehensive treatment of divergence, capable of covering its various uses in inductive equivalences in the literature, or perhaps pinpointing which instances can be handled, or are easier to handle, requires a dedicated study, related to the extension of the theory with coinductive observables, which we leave for future work (Section 16).</p></div>
<div><head n="11.3">Weak-preorder Instances</head><p>On LTSs that do not contain divergences, the weak versions of the strong preorders of Section 3 (e.g., trace, failure, failure trace, ready, ready trace preorders) are obtained by abstracting, in the definition of traces, from the silent transitions performed (e.g., an arbitrary number of silent transitions may be performed between two visible actions), and by imposing that refusal and ready sets are only observed on stable states. And, as in the strong case, the characterisation results mentioned (e.g., failure versus must testing) require image-finite LTSs. Similarly, in the formulas for observables, the main difference is the replacement of the strong diamond âŸ¨ ğœ‡ âŸ©. ğœƒ with the weak diamond âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. ğœƒ , and the use of the stable-sensitive (atomic) observables Acc ğœ‡ and Ref ğœ‡ .</p></div>
<div><head n="11.4">Weak Weights</head><p>As in strong semantics, so in weak semantics ğ‘ƒ âŠ¨ ğ‘› ğœƒ means that the observable ğœƒ can be checked by exploring the transitions emanating from ğ‘ƒ up to a depth at most ğ‘›. The rules for weak weighed satisfaction are:</p><formula xml:id="formula_42">w-at+ ğ‘ƒ âˆˆ [[a]] 1 â‰¤ ğ‘› ğ‘ƒ âŠ¨ ğ‘› a w-act+ ğ‘ƒ ğœ‡ = â‡’ ğ‘  ğ‘ƒ â€² ğ‘ƒ â€² âŠ¨ ğ‘š ğœƒ ğ‘  + ğ‘š â‰¤ ğ‘› ğ‘ƒ âŠ¨ ğ‘› âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. ğœƒ w-conj+ ğ‘ƒ âŠ¨ ğ‘š ğ‘— ğœƒ ğ‘— ğ‘š ğ‘— â‰¤ ğ‘› for all ğ‘— âˆˆ ğ½ ğ‘ƒ âŠ¨ ğ‘›</formula><p>ğ‘— âˆˆğ½ ğœƒ ğ‘— The definitions and results here are the expected modifications of those in the strong case. Proof details may be found in the Appendix Definition 11.3. A family of weak observables O and the corresponding preorder â‰¾ O are measurable if, for any LTS (over the same set of actions) and process ğ‘ƒ of the LTS, and for any observable ğœƒ âˆˆ O, whenever ğ‘ƒ âŠ¨ ğœƒ then also ğ‘ƒ âŠ¨ ğ‘› ğœƒ , for some ğ‘›.</p><p>All preorders of Section 11.3 are measurable.</p><p>Definition 11.4 (weak stratification). Suppose â‰¾ O is the preorder induced by a family O of weak observables. We write</p><formula xml:id="formula_43">ğ‘ƒ â‰¾ O ğ‘› ğ‘„ if ğ‘ƒ âŠ¨ ğ‘› ğœƒ implies ğ‘„ âŠ¨ ğœƒ , for all ğœƒ âˆˆ O.</formula><p>The relations â‰¾ O ğ‘› need not be transitive. For instance, in the trace preorder we have ğ‘ â‰¾ TR 1 ğœ. ğ‘ and ğœ. ğ‘ â‰¾ TR 1 ğ‘ but not ğ‘ â‰¾ TR 1 ğ‘.</p><p>Lemma 11.5. If O is measurable, then â‰¾ O = âˆ© ğ‘› â‰¾ O ğ‘› . Definition 11.6 (weak semi-progression). Given two relations R and S, we say that R weakly semi-progresses to S, written R âŸ©âŸ© â‡€ S, if ğ‘ƒ R ğ‘„ implies:</p><formula xml:id="formula_44">â€¢ whenever ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² , there exists ğ‘„ â€² such that ğ‘„ ğœ‡ = â‡’ ğ‘„ â€² and ğ‘ƒ â€² S ğ‘„ â€² . We recall that R is compliant (with O) if for all ğ‘ƒ R ğ‘„ and a âˆˆ O, ğ‘ƒ âˆˆ [[a]] implies ğ‘„ âˆˆ [[a]]. Definition 11.7 (soundness). A function F is sound for â‰¾ O if R âŸ©âŸ© â‡€F (R) implies R âŠ† â‰¾ O , for any compliant R.</formula><p>Definition 11.8 (weak-weight-preserving function). A function F preserves weak weights on â‰¾ O when, for all ğ‘› and for all R, if R âŠ† â‰¾ O ğ‘› , then also F (R) âŠ† â‰¾ O ğ‘› . Function F preserves weak weights if it preserves weak weights on â‰¾ O , for any â‰¾ O . Theorem 11.9. If O is measurable and F preserves weak weights on â‰¾ O , then F is sound for â‰¾ O .</p></div>
<div><head n="11.5">Functions and Constructors that Preserve Weak Weights</head><p>All the functions and constructors from the strong case (Section 6) behave well also in the weak case, with the exception of chaining. In the strong case, the main usefulness of chaining was in deriving the soundness of the up-to-preorder function. In Section 11.6 we study ways of replacing this function. Whenever non ambiguous, we abbreviate â‰¾ O as â‰¾.</p><p>11.5.1 Functions. The notion of 'weak-weight preserving', for functions and constructors, and related results, are transported to the weak case in the expected manner. For instance, we have: Lemma 11.10. The composition and union constructors preserve weak weights.</p><p>The only result from Section 6 that does not carry over concerns the chaining constructor and all functions derived from it. We show that chaining does not preserve weak weights on the up-to-preorder function P â‰¾ , that maps a relation R onto</p><formula xml:id="formula_45">{(ğ‘ƒ, ğ‘„) | ğ‘ƒ â‰¾ ğ‘ƒ â€² , ğ‘„ â€² â‰¾ ğ‘„ and ğ‘ƒ â€² R ğ‘„ â€² for some ğ‘ƒ â€² , ğ‘„ â€² }</formula><p>This function is obtained (as in the strong case) by chaining the identity and constant-to-â‰¾ functions (which preserve weights). When â‰¾ is the trace preorder and R def = {(ğœ. ğ‘, 0)}, we have R âŠ† â‰¾ 1 (the only observable for ğœ. ğ‘ in â‰¾ 1 is true). However, as ğ‘ â‰¾ ğœ. ğ‘ and â‰¾ is reflexive, we also have ğ‘ P â‰¾ (R) 0, which shows P â‰¾ (R) âŠˆ â‰¾ 1 because ğ‘ âŠ¨ 1 âŸ¨âŸ¨ ğ‘ âŸ©âŸ©. true whereas not 0 âŠ¨ 1 âŸ¨âŸ¨ ğ‘ âŸ©âŸ©. true. It would be indeed unsound to use P â‰¾ in progressions. For this, we can use a similar counterexample: take R def = {(ğœ. ğ‘, 0)}; then R âŸ©âŸ© â‡€P â‰¾ (R), yet ğœ. ğ‘ and 0 are not in the trace preorder. (The same R is used in the literature to show the unsoundness of "weak bisimulation up-to weak bisimilarity" <ref type="bibr" target="#b51">[Sangiorgi and Milner 1992]</ref>, though the reasoning is different.)</p></div>
<div><head n="11.6">Contraction Preorders</head><p>We introduce some useful functions that, while more restrictive than the (unsound) P â‰¾ above, may often be used in places where P â‰¾ would be needed.</p><p>In the coinductive case a useful auxiliary preorder that is used for similar purposes is the expansion preorder <ref type="bibr" target="#b51">[Sangiorgi and Milner 1992</ref>], a refinement of which is the contraction preorder <ref type="bibr" target="#b50">[Sangiorgi 2017</ref>]. We import the idea into the inductive setting.</p><p>Definition 11.11. For any O, the contraction preorder O is defined thus:</p><formula xml:id="formula_46">â€¢ ğ‘ƒ O ğ‘„ if ğ‘ƒ âŠ¨ ğ‘› ğœƒ implies ğ‘„ âŠ¨ ğ‘› ğœƒ , for all ğœƒ âˆˆ O.</formula><p>Thus, while in the ordinary preorder â‰¾ O the answer from ğ‘„ uses ğ‘„ âŠ¨ ğœƒ , here we find ğ‘„ âŠ¨ ğ‘› ğœƒ ; that is, the observable for ğ‘„ must be at least as efficient as that for ğ‘ƒ. Thus O âŠ† â‰¾ O . Still, is coarser than the strong preorder â‰¾; for instance only the former may relate ğ‘. ğœ. ğ‘ and ğ‘. ğ‘.</p><p>We recall that U R is the constant function mapping all relations onto R, for any relation R, that I is the identity function, and that âŒ¢ is the chaining constructor (Section 6). Lemma 11.12. Suppose F preserves weak weights on â‰¾. Then also U âŒ¢ F and F âŒ¢ U â‰¾ preserve weak weights on â‰¾.</p><p>We write P â‰¾ for the function mapping a relation R onto {(ğ‘ƒ, ğ‘„) | there are ğ‘ƒ â€² , ğ‘„ â€² and ğ‘ƒ ğ‘ƒ â€² , ğ‘ƒ â€² R ğ‘„ â€² , ğ‘„ â€² â‰¾ ğ‘„ } Lemma 11.13. Function P â‰¾ preserves weak weights on â‰¾.</p><p>We derive Lemma 11.13 from Lemmas 11.12 and 11.10, as P â‰¾ is obtained by composition of the functions U âŒ¢ I and I âŒ¢ U â‰¾ .</p></div>
<div><head n="11.7">Context Closure</head><p>The analogous of the results in Section 6 holds for weak weights; i.e., the up-to context function preserves weak weights for all families of observables in Section 11.3. As in the strong case, the key property for contexts is measure faithfulness (Definition 6.6, the same definition applies to the weak case). The proofs are similar to those for the strong case; some care however is needed with stability.</p><p>Theorem 11.14. In the language CCS ! , function C preserves weak weights on â‰¾ O , for all the families of weak observables O in Section 11.3. Definition 12.3 (soundness, with a pair of functions). A pair of functions âŸ¨F , GâŸ© is sound for</p><formula xml:id="formula_47">â‰¾ O if R âŸ©âŸ© â‡€ âŸ¨F (R), G(R)âŸ© implies R âŠ† â‰¾ O , for any compliant R.</formula><p>Theorem 12.4. If O is measurable, F preserves composite weights on â‰¾ O and G preserves visible weights on â‰¾ O , then âŸ¨F , GâŸ© is sound for â‰¾ O .</p><p>See the Appendix for a discussion on the hypothesis of Theorem 12.4. A relation is stable if all the processes in the pairs of the relation are stable. If R is stable, then in a semi-progression R âŸ©âŸ© â‡€ âŸ¨F (R), G(R)âŸ©, the relation F (R) is irrelevant. In this case we therefore write the semi-progression as R âŸ©âŸ© â‡€ âŸ¨-, G(R)âŸ© Definition 12.5 (soundness on stable relations). A function G is sound for â‰¾ O under stability if, whenever R is stable and compliant, then</p><formula xml:id="formula_48">R âŸ©âŸ© â‡€ âŸ¨-, G(R)âŸ© implies R âŠ† â‰¾ O .</formula><p>Corollary 12.6 (soundness of functions that preserve visible weights under stability).</p><p>If O is measurable, and G preserves visible weights on â‰¾ , then G is sound for â‰¾ O under stability.</p><p>Corollary 12.6 only refers to visible weights (i.e., natural numbers) and to a single weightpreserving function. It is unclear, however, how to derive the result without going through the composite weights and the two kinds of functions employed in Theorem 12.4.</p></div>
<div><head n="12.2">Instances for Composite and Visible Weights</head><p>We revisit the functions and constructors examined in Section 11.5 for weak weights, this time with respect to the property of preserving composite and visible weigths. We only mention the two results that differ; everything else is maintained, including the results about contractions.</p><p>â€¢ The chaining constructor preserves visible weights (we saw that it does not preserve weak weights). â€¢ The (full) context-closure function of CCS ! does not preserve composite and visible weights.</p><p>The reason for the failure of the context-closure function is that a context may transform a visible action of a process into a silent action. This interferes with the definition of composite and visible weights, in which visible and silent actions are separated. We show below that, on certain subsets of contexts, the closure may be recovered.</p><p>Intuitively, a context is light for a process ğ‘ƒ if the context and the process will never interact. For instance, the following grammar trivially defines light CCS contexts, as a process in the hole will never run with components of the context in parallel:</p><formula xml:id="formula_49">ğ¶ := [â€¢] | ğœ‡. ğ¶ | ğ¶ + ğ‘… (2)</formula><p>where ğ‘… is any process. We write C L for the context closure of a relation with respect to such light contexts:</p><formula xml:id="formula_50">C L (R) def = {(ğ¶ [ğ‘ƒ], ğ¶ [ğ‘„]) | ğ‘ƒ R ğ‘„ and C is a context of grammar (2)}</formula><p>The light contexts defined by the grammar above are sufficient for illustrating the concept and for the examples in this paper. It is possible to define richer classes of light contexts, for instance requiring that the free names of a context do not appear as free names of the process that fills its hole.</p><p>Theorem 12.7. For any â‰¾ O , the light-context function C L preserves composite weights and visible weights.</p><p>Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 18. Publication date: January 2022.</p><p>From Enhanced Coinduction towards Enhanced Induction 18:23 13 WEAK SEMANTICS: A SUMMARY For weak semantics we have defined two main forms of enhancements, corresponding to semiprogressions of the form R âŸ©âŸ© â‡€F (R) and R âŸ©âŸ© â‡€ âŸ¨F (R), G(R)âŸ© (a third form, namely, R âŸ©âŸ© â‡€ âŸ¨-, G(R)âŸ©, is a special case of the latter). We regard the semi-progressions R âŸ©âŸ© â‡€F (R), which are the simplest, as the most important ones. The main problem for them is that chaining, and hence the up-to-preorder enhancement, become unsound. A limited form of up-to-preorder, using contractions, is however sound <ref type="bibr">(Section 11.6)</ref>.</p><p>Whenever chaining and the full up-to-preorder enhancement are needed, one may use the 'composite' semi-progressions R âŸ©âŸ© â‡€ âŸ¨F (R), G(R)âŸ©. Here, however, the context-closure function may not be used (though we do not know if it is unsound); one may however use the closure under light contexts. The final example of the next section shows an application of this form of semi-progression (actually R âŸ©âŸ© â‡€ âŸ¨-, G(R)âŸ© is sufficient), where we take full advantage of chaining.</p></div>
<div><head n="14">WEAK SEMANTICS: THE EXAMPLES, REVISITED</head><p>Congruence for recursion. The schema of the proof of congruence for recursion in Section 8 can be adapted to weak semantics. For this, however, we need an advanced form of enhancement, involving contractions.</p><p>As before we assume that the syntax of the language includes an action prefix operator ğœ‡. ğ‘ƒ and a recursion operator rec ğ‘‹ . ğ¸ in which ğ‘‹ is guarded in the body ğ¸. The guard need not be a visible prefix -it may also be ğœ. Thus, here â‰¾ is any measurable weak preorder, as defined in Section 11.4, and its corresponding contraction preorder. The assumptions we need are similar to those for the strong case: Guard is actually the same; in Cong and Canc we simply replace the strong preorder â‰¾ with the weak one â‰¾. Two servers. We revisit the example of the two servers, in Section 9. The same results and proofs in that section can be repeated under weak semantics. However a weak semantics allows us some greater flexibility. Consider for instance an eager variant of the first server, ğ¿, that interrogates both auxiliary servers ğµ and ğ´, at ğ‘ and ğ‘, before accepting a request from a client at ğ‘: ğ¿ E def = !ğ‘’. ğ‘ (ğ‘¦). ğ‘(ğ‘¥). ğ‘ (ğ‘§). (ğ‘’ |ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§))</p><p>and let ğ¿ğ‘† E be the system defined as ğ¿ğ‘† but with ğ¿ E in place of ğ¿. In ğ¿ğ‘† E a visible action at ğ‘ is only possible after two ğœ actions (the two interrogations with the auxiliary servers), whereas in ğ‘€ğ‘† only one ğœ action is produced. Hence ğ¿ğ‘† E and ğ‘€ğ‘† may not be related by a strong equivalence.</p><p>Let â‰¾ be any of the weak preorders in Section 11.3, its corresponding contraction, and â‰ˆ the equivalence induced by â‰¾. (The systems have no divergences, assuming the protocol ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§)</p><p>does not produce divergences, hence the characterisation results in Section 11.3 hold). We can prove ğ¿ğ‘† E â‰ˆ ğ‘€ğ‘† using a weak progression R âŸ©âŸ©â†’(P â‰¾ â€¢ C) (R) (i.e., R âŸ©âŸ©â†’ C(R) â‰¾, Section 11.7).</p><p>The proof is similar to those in Section 9; R is the singleton {(ğ¿ğ‘† E , ğ‘€ğ‘†)}. The only addition is the application of the law ğœ‡. ğœ. ğ‘ƒ = ğœ‡. ğ‘ƒ. Precisely, we need ğœ‡. ğœ. ğ‘ƒ ğœ‡. ğ‘ƒ and ğœ‡. ğœ. ğ‘ƒ â‰¿ ğœ‡. ğ‘ƒ (these laws are valid for all the contractions and preorders discussed).</p><p>Hennessy's proof system for trace preorder. Moving to weak trace preorder, the only difference in Hennessy's proof system discussed in Section 10 is the addition of the pairs of axioms ğœ. ğ‘ƒ â‰¤ ğ‘ƒ and ğ‘ƒ â‰¤ ğœ. ğ‘ƒ. The soundness of the proof system therefore requires the (straightforward) soundness proof of these two extra axioms.</p><p>An important technical remark, however, is mandatory. In the strong case our proof employed a sophisticated semi-progression, involving the closure with respect to various functions, including up-to preorder, up-to context, up-to transitivity. Some of these functions are derived from the chaining constructor. In the weak case, chaining is not sound for weak weights; it is only sound for the visible weights of Section 12. We therefore appeal to enhancement functions that preserve visible weights and to the stability condition of Corollary 12.6. We can do so because the relation on which the semi-progression is applied has, as in the strong case, only pairs of processes of the form (ğ‘. ğ‘ƒ, ğ‘. ğ‘„), which are stable, and because the contexts that are needed in the closure are the light contexts of Section 12.2. In other words, the semi-progression employed uses the weak version of the closure function in the proof for strong semantics in Section 10, tailored to functions that preserve visible weights.</p></div>
<div><head n="15">COMPARISONS AND RELATED WORK</head><p>We are not aware of theories of enhancements for 'inductive behavioural relations' (i.e., relations defined from inductive observables). In this respect, all the material in the paper, beginning at Section 2, is new. We have been inspired by theories of enhancements for coinductive behavioural equivalences; these are however technically quite different, because they are not based on weights and weight-preserving functions (see the discussion below). A key ingredient for our enhancements are inductive stratifications, or approximations, of behavioural relations. This is a well-know tool in concurrency and more generally in semantics (e.g., <ref type="bibr" target="#b22">[Hennessy 1988;</ref><ref type="bibr" target="#b31">Milner 1989;</ref><ref type="bibr" target="#b44">Roscoe 1998</ref>]); our use of stratification, to define weights and then the weight-preserving functions, in turn used to derive the inductive enhancements, is novel.</p><p>Coinductive enhancements. In the coinductive case, the condition on functions used to yield sound enhancements is respectfulness or compatibility <ref type="bibr" target="#b41">[Pous and Sangiorgi 2012]</ref>. In both cases, the key requirement is the lifting of a progression R âŸ©â†’ S to F (R)âŸ©â†’F (S), where F is the function. For compatibility, this is the only condition; respectfulness has the additional hypothesis R âŠ† S and then requires F (R) âŠ† F (S). These conditions are the coinductive counterpart of our weight-preserving condition (Definition 5.5). The remarks below on respectfulness also hold for compatibility.</p><p>As sets of functions, the weight-preserving and the respectful ones are incomparable. This already shows up in strong semantics. An easy way to obtain a respectful function that is not weight-preserving for a given inductive equivalence exploits languages in which bisimilarity is a congruence whereas the inductive equivalence is not. As an example for trace equivalence, consider the language of processes</p><formula xml:id="formula_51">ğ‘ƒ := ğ‘. ğ‘ƒ | ğ‘ƒ 1 + ğ‘ƒ 2 | 0 | ğ‘“ (ğ‘ƒ)</formula><p>where the SOS rule for the unary operator ğ‘“ is:</p><formula xml:id="formula_52">ğ‘ƒ ğ‘ -â†’ ğ‘ƒ â€² ğ‘“ (ğ‘ƒ) ğ‘ -â†’ ğ‘“ (ğ‘ƒ â€² ) ğ‘ â‰  ğ‘ ğ‘ƒ ğ‘ -â†’ ğ‘ƒ â€² ğ‘ƒ ğ‘ -â†’ ğ‘ƒ â€²â€² ğ‘“ (ğ‘ƒ) ğ‘ -â†’ ğ‘ƒ â€²</formula><p>The up-to context function for this language is respectful, yet it is not weight-preserving for trace equivalence (indeed trace equivalence is not preserved by the operator ğ‘“ (-) above). Similar counterexamples can be exhibited for other inductive equivalences. This may appear puzzling at first, because respectfulness ensures soundness for bisimilarity and, as bisimilarity is more demanding than any of the inductive relations in the paper, soundness for bisimilarity implies soundness for the inductive relations. What the above counterexample rather shows is that adding the set of respectful functions to the set of weight-preserving functions would yield a set of functions without good closure properties. For instance the composition of two functions might not be sound. We show a counterexample in the language above, using the up-to context function C and the constant-to-âˆ¼ function U âˆ¼ (C is respectful and U âˆ¼ is weight-preserving).</p><p>Consider ğ‘ƒ def = ğ‘. ğ‘“ (ğ‘. (ğ‘ + ğ‘)) and ğ‘„ def = ğ‘. ğ‘“ (ğ‘. ğ‘ + ğ‘. ğ‘)), and let âˆ¼ be trace equivalence. Then ğ‘ƒ âˆ¼ ğ‘„ does not hold, as only the former processes has the trace ğ‘; ğ‘; ğ‘. However, if</p><formula xml:id="formula_53">R def = {ğ‘ƒ, ğ‘„ } then R âŸ©â†’ C(U âˆ¼ (R)) = C(âˆ¼), as ğ‘ƒ ğ‘ -â†’ ğ‘“ (ğ‘. (ğ‘ + ğ‘)) def = ğ‘ƒ â€² ğ‘„ ğ‘ -â†’ ğ‘“ (ğ‘. ğ‘ + ğ‘. ğ‘)) def = ğ‘„ â€² and (ğ‘ƒ â€² , ğ‘„ â€² ) âˆˆ C(âˆ¼).</formula><p>On the other hand, the 'up-to context' function C of the language CCS ! in Section 6 is not respectful (though it is contained in a larger respectful function, for instance, the function T â€¢ C that yields 'up-to polyadic contexts') while, as shown in that Section 6, C is weight-preserving for all families of observables there discussed. Moreover, for any equivalence âˆ¼ induced by a measurable preorder, function P âˆ¼ (the 'up to âˆ¼' in Corollary 6.3, for an equivalence in place of a preorder) is not sound for any equivalence finer than âˆ¼; hence, in particular, P âˆ¼ is not sound for bisimilarity (let alone respectful). None of the enhancements used in Sections 8-10 and 14 corresponds to a respectful function.</p><p>Unique solutions of equations. In <ref type="bibr" target="#b17">[Durier et al. 2019;</ref><ref type="bibr" target="#b50">Sangiorgi 2017</ref>] the authors study proof techniques for weak bisimilarity based on unique solutions of equations and special inequations called contractions. These techniques give one the power of some bisimulation enhancements such as 'up-to context'. Moreover, the authors transport them onto trace equivalence and trace preorder. Such techniques seem to have a limited applicability to preorders (they can only be used to show that a given process is related to the syntactic solution of an equation, that is, the process whose syntactic definition is the equation itself), and adapting them to a new equivalence seems to require considerable work. Milner <ref type="bibr" target="#b31">[Milner 1989</ref>] presents unique solution of equations as a proof technique alternative to the bisimulation proof method. In this sense, we may say that <ref type="bibr" target="#b17">[Durier et al. 2019;</ref><ref type="bibr" target="#b50">Sangiorgi 2017</ref>] follow the former style of proof technique, whereas in this paper we follow the latter.</p><p>Further related work. The idea of developing a theory of enhancements, for the bisimulation proof method, is put forward in <ref type="bibr" target="#b48">[Sangiorgi 1998</ref>], introducing the notion of progression and of respectful function. Later <ref type="bibr" target="#b38">[Pous 2007</ref><ref type="bibr" target="#b39">[Pous , 2016] ]</ref> the theory has been both generalised to the coinduction proof method, using complete lattices, and refined, first replacing respectfulness with compatibility (simpler though more restrictive), then focusing on the largest compatible function, called the companion (that also coincides with the largest respectful function). The companion can also be obtained using Kleene's construction of the greatest fixed-point <ref type="bibr" target="#b34">[Parrow and Weber 2016]</ref>.</p><p>Abstract formulations of the meaning of coinductive enhancements have also been given using category theory. The main technical tools are final semantics, coalgebras, spans of coalgebra homomorphisms, fibrations, and corecursion schemes. See, e.g., <ref type="bibr" target="#b3">[Basold et al. 2017;</ref><ref type="bibr" target="#b40">Pous and Rot 2017;</ref><ref type="bibr" target="#b45">Rot et al. 2017</ref>] (based on earlier works such as <ref type="bibr" target="#b2">[Bartels 2004;</ref><ref type="bibr" target="#b26">Jacobs 2006;</ref><ref type="bibr" target="#b29">Lenisa et al. 2000;</ref><ref type="bibr" target="#b30">Milius et al. 2013;</ref><ref type="bibr" target="#b54">Uustalu et al. 2001]</ref>), and <ref type="bibr" target="#b1">[Bartels 2003;</ref><ref type="bibr">Bonchi et al. 2018b</ref><ref type="bibr">Bonchi et al. , 2017b;;</ref><ref type="bibr" target="#b28">Lenisa 1999]</ref>. Enhancements of corecursion schemes may also be examined using the generalised powerset construction <ref type="bibr" target="#b52">[Silva et al. 2010]</ref>. For the more details on coinductive enhancements, we refer to the technical survey <ref type="bibr" target="#b41">[Pous and Sangiorgi 2012]</ref> and to the historical review <ref type="bibr" target="#b42">[Pous and Sangiorgi 2019]</ref>.</p><p>Bisimilarity (and similar coinductive relations) has been employed to reason about inductive relations by relying on transformations of the transitions systems that modify the nondeterminism and the set of states, in such a way that a given equivalence on the original systems corresponds to bisimilarity on the altered systems. For instance, trace equivalence on nondeterministic processes can be reduced to bisimilarity on deterministic processes, following the powerset construction for automata <ref type="bibr" target="#b25">[Hopcroft et al. 2006</ref>]; a similar reduction can be made for testing equivalence <ref type="bibr" target="#b14">[Cleaveland and Hennessy 1993]</ref>. <ref type="bibr" target="#b15">In [de Frutos-Escrig and Gregorio-RodrÃ­guez 2009]</ref>, related processes may be rewritten using a (possibly inductive) equivalence so to characterise, using a bisimulation-like game, the equivalence itself, and similarly for preorders; the main goal is to exploit such a homogeneous presentation to derive axiomatisations for a broad spectrum of behavioural relations.</p><p>The bisimulation enhancements have been shown to be useful not only for Labeled Transition Systems. For example, efficient algorithms for equivalence (and inclusion) of automata and streams have been obtained, e.g., <ref type="bibr">[Bonchi et al. 2017a;</ref><ref type="bibr" target="#b10">Bonchi and Pous 2013;</ref><ref type="bibr" target="#b46">Rot et al. 2016</ref>]. In the powerset construction from non-deterministic to deterministic automata, up-to techniques are employed to avoid the construction of the whole automata. The algorithms exploit the property that language equivalence coincides with bisimilarity on deterministic systems. Up-to techniques have also been proposed for streams to facilitate coinductive definitions in Coq, e.g., <ref type="bibr" target="#b18">[Endrullis et al. 2013]</ref>.</p><p>Proofs of soundness for the coinductive enhancements have been related to proofs of completeness for domains of abstract interpretations <ref type="bibr">[Bonchi et al. 2018a</ref>].</p></div>
<div><head n="16">CONCLUSIONS AND FUTURE WORK</head><p>In this paper we have studied how to transport the well-known enhancements of the proof method for coinductively-defined behavioural relations, notably bisimilarity, onto inductive behaviour relations, i.e., behaviour relations defined from inductive observables. We have formalised the observables by means of operators from modal logics, so to capture the most common inductive behavioural relations in the literature. Following the coinductive setting, our theory makes use of semi-progressions of the form R âŸ©â‡€F (R) where F is a function on relations. The functions sound for a given preorder are those for which R âŸ©â‡€F (R) implies that R is contained in the preorder; and similarly for equivalences. We have introduced weights on the observables, and a weight-preserving condition on functions that guarantees soundness. We have shown that the class of weight-preserving functions contains non-trivial functions and that it enjoys closure properties with respect to desirable function constructors, so to be able to derive sophisticated sound functions (and hence sophisticated proof techniques) from simpler ones. For weak semantics we have considered two forms of weights. (We have summarised the differences between the theories for strong and weak semantics in Section 11.1, and those between the two forms of weights in Section 13.) We have shown our enhancements at work on a few non-trivial examples, both in the strong and in the weak case: the examples about recursion illustrate the possibility of deriving proofs that are parametric on the behavioural relation of interest; the proofs about the servers show our techniques at work in cases where the bisimulation enhancements may not be used because bisimilarity is too fine or does not have a natural associated preorder; the examples about Hennessy's proof system use the enhancements to explain Hennessy's non-standard proof, and bring up a sophisticated combination of enhancements.</p><p>We would like to see if and how the theory of inductive enhancements in the paper can be formulated in a more abstract setting, e.g., fixed-point theory or category theory. Proposals along these lines exist for the coinductive enhancements (c.f., references in Section 15). Their meaning in our setting is unclear, both because the observables are inductive and because of the coinductive flavour of the semi-progressions at the heart of the theory. For this, one may consider variant formulation of the weight-preserving condition. For instance (as pointed out by one of the anonymous referees), requiring in Definition 5.5 the function F to be monotone and with F (â‰¾ O ğ‘› ) âŠ† â‰¾ O ğ‘› , for all ğ‘›. We would also to see if the theory presented can be lifted to a probabilistic setting and labelled Markov processes.</p><p>A powerful enhancement is up-to context. We have studied it in a CCS-like language. We would like to see if there are general conditions that guarantee its soundness, more precisely the weightpreserving property. Such conditions could, for instance, look at the format of the rules defining the operational behaviour of the operators of the language. In coinduction, up-to-context has been shown very effective in higher-order languages, such as ğœ†-calculi or languages enriched with functional features, and nominal languages such as the ğœ‹-calculus. More generally, here the goal would be transferring the inductive enhancements in the paper to these classes of languages.</p><p>The up-to-context enhancement could also be used to derive general congruence properties for inductive behavioural relations; e.g., for CCS ! one exploits Corollary 6.9.</p><p>As enhancement functions, we have considered functions inspired by the most common ones used in coinductive enhancements. This suggests another direction to investigate, namely the search of other useful functions that preserve weights.</p><p>We have studied enhancements for behavioural relations defined from inductive observables. We have not considered observables that are naturally defined coinductively, such as infinite traces and divergence. It would be interesting to see if the theory developed can be extended so to accommodate both inductive and coinductive observables. This would be particularly relevant for divergence in weak semantics (c.f., Remark 11.2).</p></div><figure xml:id="fig_0"><head /><label /><figDesc>Definition 4.5 (stratification). Two processes ğ‘ƒ, ğ‘„ are in the ğ‘›-th approximant of â‰¾ O , written ğ‘ƒ â‰¾ O ğ‘› ğ‘„, if ğ‘ƒ âŠ¨ ğ‘› ğœƒ implies ğ‘„ âŠ¨ ğœƒ , for all ğœƒ .</figDesc></figure>
<figure xml:id="fig_1"><head /><label /><figDesc>trace preorder, then such a function would preserve weights according to ( * ). Yet for R def = {(ğ‘. ğ‘, ğ‘. ğ‘)} we have R âŸ©â‡€F (R), although the processes in R are not in the trace preorder.</figDesc></figure>
<figure xml:id="fig_2"><head>def=</head><label /><figDesc>ğ‘. (ğ‘ + ğ‘) and ğ‘„ def = ğ‘. ğ‘ + ğ‘. ğ‘, where ğ‘ƒ â‰¾ TR ğ‘„ holds. We have ğ‘ƒ ğ‘ -â†’ ğ‘ + ğ‘, which can only be matched by ğ‘„ ğ‘ -â†’ ğ‘ or ğ‘„ ğ‘ -â†’ ğ‘. However, we cannot have (ğ‘ + ğ‘, ğ‘) or (ğ‘ + ğ‘, ğ‘) in F (R), for some R with (ğ‘ƒ, ğ‘„) âˆˆ R âŠ† â‰¾ TR and F that preserves weights: when a function preserves weights, it must map any relation included in â‰¾ TR onto a relation with the same property, but ğ‘ + ğ‘ Ì¸ â‰¾ TR ğ‘ and ğ‘ + ğ‘ Ì¸ â‰¾ TR ğ‘.</figDesc></figure>
<figure xml:id="fig_3"><head /><label /><figDesc>Definition 6.6. A context ğ¶ is measurably faithful for (a family of measurable observables) O if for all ğ‘›, ğ‘ƒ and ğœƒ âˆˆ O there is ğœ such that ğ¶ [ğ‘ƒ] âŠ¨ ğ‘› ğœƒ implies ğ‘ƒ âŠ¨ ğ‘› ğœ , and moreover for all ğ‘„ with ğ‘„ âŠ¨ ğœ also ğ¶ [ğ‘„] âŠ¨ ğœƒ holds. Theorem 6.7. If all contexts in C are measurably faithful for O, then function C C preserves weights on â‰¾ O .</figDesc></figure>
<figure xml:id="fig_4"><head /><label /><figDesc>Theorem 7.3 (soundness of weight-preserving functions for eqivalences). Suppose F preserves weights on â‰¾ O . Then F is sound for âˆ¼ O . In Theorem 7.3, we need not have the same R or the same function to prove the two directions of the progression: Theorem 7.4. Suppose F and G preserve weights on â‰¾ O . If R âŸ©â‡€F (R) and S âŸ©â‡€G (S) then R âˆ© S -1 âŠ† âˆ¼ O .</figDesc></figure>
<figure xml:id="fig_5"><head /><label /><figDesc>Theorem 8.1 (congruence for recursion). Assume ğ‘‹ guarded in ğ¸ and ğ¹ . If ğ¸ â‰¾ ğ¹ , then rec ğ‘‹ . ğ¸ â‰¾ rec ğ‘‹ . ğ¹ . Proof. [Sketch] Following the definition of â‰¾ on open expressions, it is sufficient to carry out the proof in the case when ğ‘‹ is the only possible free variable of ğ¸, ğ¹ . Let ğ‘ƒ def = rec ğ‘‹ . ğ¸ and ğ‘„ def = rec ğ‘‹ . ğ¹ . Take R def = {(ğº { ğ‘ƒ /ğ‘Œ }, ğº { ğ‘„ /ğ‘Œ }) | ğ‘Œ guarded in ğº }</figDesc></figure>
<figure xml:id="fig_6"><head /><label /><figDesc>ğ¿ def = !ğ‘’. ğ‘ (ğ‘¦). ğ‘ (ğ‘§). ğ‘(ğ‘¥). (ğ‘’ |ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§)) ğ‘€ def = !ğ‘’. ğ‘(ğ‘¥). ğ‘ (ğ‘§). ğ‘ (ğ‘¦). (ğ‘’ |ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§))</figDesc></figure>
<figure xml:id="fig_7"><head /><label /><figDesc>ğ‘§). ğ‘(ğ‘¥). (ğ‘’ |ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§)) ğ‘€ 1 def = ğ‘(ğ‘¥). ğ‘ (ğ‘§). ğ‘ (ğ‘¦). (ğ‘’ |ğ‘…(ğ‘, ğ‘¥, ğ‘¦, ğ‘§))</figDesc></figure>
<figure xml:id="fig_8"><head /><label /><figDesc>=â‡’ ğœ‡ -â†’=â‡’ (the composition of the three relations). Moreover, ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² holds if ğ‘ƒ ğœ‡ -â†’ ğ‘ƒ â€² or (ğœ‡ = ğœ and ğ‘ƒ = ğ‘ƒ â€² ); similarly ğ‘ƒ ğœ‡ = â‡’ ğ‘ƒ â€² holds if ğ‘ƒ ğœ‡ = â‡’ ğ‘ƒ â€² or (ğœ‡ = ğœ and ğ‘ƒ = ğ‘ƒ â€² ). We also use weighted transitions, writing ğ‘ƒ =â‡’ ğ‘› ğ‘ƒ â€² if ğ‘ƒ may evolve into ğ‘ƒ â€² by performing ğ‘› ğœ-transitions, and ğ‘ƒ ğœ‡= â‡’ ğ‘› ğ‘ƒ â€² if ğ‘ƒ =â‡’ ğ‘š ğœ‡ -â†’=â‡’ ğ‘  ğ‘ƒ â€² , for some ğ‘š, ğ‘  with ğ‘š + ğ‘  + 1 = ğ‘›; similarly for ğ‘ƒ ğœ‡ = â‡’ ğ‘› ğ‘ƒ â€² . A process ğ‘ƒ is stable if ğ‘ƒ Ì¸ ğœ -â†’, i.e., ğ‘ƒ cannot perform internal actions. In the grammars for observables, the weak diamond âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. ğœƒ , insensitive to ğœ-transitions, replaces the strong diamond âŸ¨ ğœ‡ âŸ©. ğœƒ . Definition 11.1. A family of weak observables (over Ağ‘ğ‘¡ and A) is a subset O of the formulas inductively generated by the following grammar:ğœƒ := âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. ğœƒ | ğ‘— âˆˆğ½ ğœƒ ğ‘— | awhere, as before, ğœ‡ âˆˆ Ağ‘ğ‘¡, a âˆˆ A, ğ½ is a countable set, and: â€¢ (downward-closure) if âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. ğœƒ âˆˆ O then also ğœƒ âˆˆ O, and similarly if ğ‘— âˆˆğ½ ğœƒ ğ‘— âˆˆ O then also ğœƒ ğ‘— âˆˆ O for each ğ‘—; if âŸ¨âŸ¨ ğœ‡ âŸ©âŸ©. ğœƒ âˆˆ O then also âŸ¨âŸ¨ ğœ âŸ©âŸ©. ğœƒ âˆˆ O.</figDesc></figure>
<figure xml:id="fig_9"><head /><label /><figDesc>Theorem 14.1. Assume ğ‘‹ guarded in ğ¸ and ğ¹ . If ğ¸ â‰¾ ğ¹ , then rec ğ‘‹ . ğ¸ â‰¾ rec ğ‘‹ . ğ¹ . The proof is similar to the strong case. The relation to be used, for ğ‘ƒ def = rec ğ‘‹ . ğ¸ and ğ‘„ def= rec ğ‘‹ . ğ¹ , is R def = {(ğº { ğ‘ƒ /ğ‘Œ }, ğº { ğ‘„ /ğ‘Œ }) | ğ‘Œ guarded in ğº }We derive R âŠ† â‰¾ using the function P â‰¾ (Lemma 11.13, the 'up-to and â‰¾' technique). We show that a transition ğº { ğ‘ƒ /ğ‘Œ } ğœ‡ -â†’ ğº * { ğ‘ƒ /ğ‘Œ } is matched by ğº { ğ‘„ /ğ‘Œ } ğœ‡ -â†’ ğº * { ğ‘„ /ğ‘Œ } by finding a ğº # guarded such that ğº * { ğ‘ƒ /ğ‘Œ } ğº # { ğ‘ƒ /ğ‘Œ } and ğº * { ğ‘„ /ğ‘Œ } â‰¿ ğº # { ğ‘„ /ğ‘Œ }, using the hypothesis of the theorem, assumptions Guard, Cong, and Canc, and the inclusion â‰¾ âŠ† when folding or unfolding the recursions.</figDesc></figure>
<figure type="table" xml:id="tab_0"><head>â€¢</head><label /><figDesc>The observable ref ğ‘ âˆ§ ref ğ‘ is satisfied by any process that cannot perform ğ‘ or ğ‘ actions. O on the processes, whereby ğ‘ƒ â‰¾ O ğ‘„ if ğ‘ƒ âŠ¨ ğœƒ implies ğ‘„ âŠ¨ ğœƒ for all ğœƒ âˆˆ O.</figDesc><table /><note><p>â€¢ The observable âŸ¨ ğ‘ âŸ©. âŸ¨ ğ‘ âŸ©. (âŸ¨ ğ‘ âŸ©. true âˆ§ ref ğ‘‘ ) checks whether a process, upon performing the actions ğ‘ and ğ‘, can reach a state in which ğ‘ is possible but not ğ‘‘. Definition 2.3 (preorder induced by O). A family O of observables induces a preorder â‰¾</p></note></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>for ğ¿ 2</figDesc><table><row><cell>From Enhanced Coinduction towards Enhanced Induction</cell><cell>18:15</cell></row></table><note><p>def = Î£ ğ‘£ âˆˆBool ğœ. ğ‘ (ğ‘§). Î£ ğ‘› âˆˆğ‘ ğœ. (ğ‘’ |ğ‘…(ğ‘, ğ‘›, ğ‘£, ğ‘§)) Now, we use twice a basic law for the inductive preorders [Glabbeek 2001], namely ğœ†. Î£ ğ‘– ğœ‡. ğ‘ƒ ğ‘– âˆ¼ Î£ ğ‘– ğœ†. ğœ‡. ğ‘ƒ ğ‘– This law is valid for all the equivalences induced by the inductive preorders of Section 3, whereas it fails for coinductive relations such as similarity or bisimilarity. We thus derive ğ¿ 2 âˆ¼ Î£ ğ‘£ âˆˆBool Î£ ğ‘› âˆˆğ‘ ğœ. ğ‘ (ğ‘§). ğœ. (ğ‘’ |ğ‘…(ğ‘, ğ‘›, ğ‘£, ğ‘§)) def = ğ¿ 3 Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 18. Publication date: January 2022.</p></note></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 18. Publication date: January 2022.</figDesc><table /></figure>
			<note place="foot" xml:id="foot_0"><p>Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 18. Publication date: January 2022.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>I benefitted from exchanges and comments from <rs type="person">Matthew Hennessy</rs>. I would also like to thank <rs type="person">Rob van Glabbeek</rs>, for discussions about inductive equivalences and for suggesting Example 1 about recursion, and the anonymous referees, for various useful comments.</p><p>This material is based upon work supported by the <rs type="programName">MIUR-PRIN project 'Analysis of Program Analyses'</rs> (<rs type="projectName">ASPRA</rs>, <rs type="grantNumber">ID 201784YSZ5_004</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_9TY89bm">
					<idno type="grant-number">ID 201784YSZ5_004</idno>
					<orgName type="project" subtype="full">ASPRA</orgName>
					<orgName type="program" subtype="full">MIUR-PRIN project 'Analysis of Program Analyses'</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div><p>We can thus combine the context-closure function with other functions that preserve weak weights. For instance, combining P â‰¾ (Lemma 11.13) with C we derive the function P â‰¾ â€¢ C whereby </p></div>
<div><head n="12">COMPOSITE WEIGHTS AND COMPOSITE SEMI-PROGRESSIONS</head><p>In this section we examine a different form of weights for the weak enhancements. We replace weak weights with composite weights and visible weights. The former are the important ones, the latter are derived from the former. The reason for the two kinds of weights is that we can then define semi-progressions with two functions, one to be used after a silent-action challenge, the other after a visible-action challenge. Two functions yield more flexibility and allow us to obtain more powerful enhancements.</p></div>
<div><head n="12.1">Composite and Visible Weights</head><p>Composite weights are pairs (ğ‘›, ğ‘š) of integers. We use the lexicographical order to compare composite weights, in which (ğ‘›, ğ‘š) &lt; (ğ‘› â€² , ğ‘š â€² ) if ğ‘š &lt; ğ‘š â€² or (ğ‘š = ğ‘š â€² and ğ‘› &lt; ğ‘› â€² ). Addition and subtraction on composite weights are computed componentwise.</p><p>Roughly, ğ‘ƒ âŠ¨ (ğ‘›,ğ‘š) ğœƒ says that ğ‘ƒ âŠ¨ ğœƒ has a proof in which the sequences of transitions from ğ‘ƒ that are unrolled have at most ğ‘› silent transitions and ğ‘š visible transitions. More precisely, a proof of ğ‘ƒ âŠ¨ (ğ‘›,ğ‘š) ğœƒ explores a finite tree of transitions with ğ‘ƒ as a root; and if ğ‘› â€² and ğ‘š â€² are the number of silent and visible actions in a path of the tree, then (ğ‘› â€² , ğ‘š â€² ) â‰¤ (ğ‘›, ğ‘š). We require however a bound on the number of silent actions in any path of the tree; as a consequence, the meaning of 'O measurable' is the same, under weak or composite weights. We use ğ‘¢, ğ‘£, ğ‘¤ to range over composite weights.</p><p>Visible weights are written ğ‘š, where ğ‘š is an integer. We define satisfaction under visible weights on top of satisfaction under composite weights, writing ğ‘ƒ âŠ¨ ğ‘š ğœƒ if ğ‘ƒ âŠ¨ (ğ‘›,ğ‘š) ğœƒ , for some ğ‘› (defining ğ‘ƒ âŠ¨ ğ‘š ğœƒ in terms of ğ‘ƒ âŠ¨ (ğ‘›,ğ‘š) ğœƒ , rather than with dedicated rules, is convenient in proofs in which the two forms of weights are intertwined, notably the proof of Theorem 12.4). Thus, roughly ğ‘ƒ âŠ¨ ğ‘š ğœƒ implies that the observable ğœƒ can be checked on ğ‘ƒ by exploring a tree of transitions in whose paths there are at most ğ‘š visible actions.</p><p>Concerning the rules that assign composite weights to weak observables, the stratifications of a preorder â‰¾ O for composite and visible weights, respectively written â‰¾ O ğ‘¢ and â‰¾ O ğ‘š , the meaning of functions that preserve composite and visible weights: these notions are defined by modifying those for weak weights in Section 11 as expected.</p><p>Lemma 12.1. For any â‰¾ O , if a function preserves composite weights, then it also preserves weak weights and visible weights.</p><p>We only present here the soundness of semi-progressions using two functions, one to be used after a silent-action challenge, the other after a visible-action challenge, and similarly for semiprogressions on stable relations, in which only functions preserving visible weights are involved.</p><p>Definition 12.2 (semi-progression, with two relations). Given three relations R and S, T , we say that R semi-progresses to âŸ¨S, T âŸ©, written R âŸ©âŸ© â‡€ âŸ¨S, T âŸ©, if ğ‘ƒ R ğ‘„ implies:</p><p>(1) whenever ğ‘ƒ ğœ -â†’ ğ‘ƒ â€² , there exists ğ‘„ â€² such that ğ‘„ =â‡’ ğ‘„ â€² and ğ‘ƒ â€² S ğ‘„ â€² ;</p><p>(2) whenever ğ‘ƒ â„“ -â†’ ğ‘ƒ â€² , there exists ğ‘„ â€² such that ğ‘„ â„“ = â‡’ ğ‘„ â€² and ğ‘ƒ â€² T ğ‘„ â€² .</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Ready-Trace Semantics for Concrete Process Algebra with the Priority Operator</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Jos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><forename type="middle">A</forename><surname>Baeten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><forename type="middle">Willem</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><surname>Klop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="498" to="506" />
			<date type="published" when="1987">1987. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Generalised Coinduction</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bartels</surname></persName>
		</author>
		<idno type="DOI">10.1017/S0960129502003900</idno>
		<ptr target="https://doi.org/10.1017/S0960129502003900" />
	</analytic>
	<monogr>
		<title level="j">Math. Struct. in Computer Science</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="321" to="348" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">On generalised coinduction and probabilistic specification formats</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bartels</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
		<respStmt>
			<orgName>CWI</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Monoidal company for accessible functors</title>
		<author>
			<persName><forename type="first">Henning</forename><surname>Basold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damien</forename><surname>Pous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jurriaan</forename><surname>Rot</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CALCO.2017.5</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CALCO.2017" />
	</analytic>
	<monogr>
		<title level="m">Proc. CALCO (LIPIcs</title>
		<title level="s">Schloss Dagstuhl -Leibniz-Zentrum fÃ¼r Informatik</title>
		<meeting>CALCO (LIPIcs</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">72</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Failures without Chaos: a Process Semantics for Fair Abstraction</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-R</forename><surname>Olderog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IFIP Formal Description of Programming Concepts -III</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier Science Publishers B.V</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="77" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Bisimulation can't be Traced</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bloom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Istrail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Meyer</surname></persName>
		</author>
		<idno type="DOI">10.1145/200836.200876</idno>
		<ptr target="https://doi.org/10.1145/200836.200876" />
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="232" to="268" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">a. Sound up-to techniques and Complete abstract domains</title>
		<author>
			<persName><forename type="first">Filippo</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Ganty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Giacobazzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dusko</forename><surname>Pavlovic</surname></persName>
		</author>
		<idno type="DOI">10.1145/3209108.3209169</idno>
		<ptr target="https://doi.org/10.1145/3209108.3209169Proc" />
	</analytic>
	<monogr>
		<title level="m">LICS 2018</title>
		<editor>
			<persName><forename type="first">Anuj</forename><surname>Dawar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Erich</forename><surname>GrÃ¤del</surname></persName>
		</editor>
		<imprint>
			<publisher>POPL</publisher>
			<date type="published" when="2018-01">2018. January 2022</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="175" to="184" />
		</imprint>
	</monogr>
	<note>Article 18. Publication date</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">a. Up-To Techniques for Weighted Systems</title>
		<author>
			<persName><forename type="first">Filippo</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barbara</forename><surname>KÃ¶nig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>KÃ¼pper</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-54577-5_31</idno>
		<ptr target="https://doi.org/10.1007/978-3-662-54577-5_31" />
	</analytic>
	<monogr>
		<title level="m">TACAS 2017</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Axel</forename><surname>Legay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tiziana</forename><surname>Margaria</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10205</biblScope>
			<biblScope unit="page" from="535" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Up-To Techniques for Behavioural Metrics via Fibrations</title>
		<author>
			<persName><forename type="first">Filippo</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barbara</forename><surname>KÃ¶nig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Petrisan</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CONCUR.2018.17</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CONCUR.2018" />
	</analytic>
	<monogr>
		<title level="m">CONCUR'18</title>
		<editor>
			<persName><forename type="first">Sven</forename><surname>Schewe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lijun</forename><surname>Zhang</surname></persName>
		</editor>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">118</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A general account of coinduction up-to</title>
		<author>
			<persName><forename type="first">Filippo</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Petrisan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damien</forename><surname>Pous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jurriaan</forename><surname>Rot</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00236-016-0271-4</idno>
		<ptr target="https://doi.org/10.1007/s00236-016-0271-4" />
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="127" to="190" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Checking NFA equivalence with bisimulations up to congruence</title>
		<author>
			<persName><forename type="first">Filippo</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damien</forename><surname>Pous</surname></persName>
		</author>
		<idno type="DOI">10.1145/2429069.2429124</idno>
		<ptr target="https://doi.org/10.1145/2429069.2429124" />
	</analytic>
	<monogr>
		<title level="m">Proc. POPL'13</title>
		<editor>
			<persName><forename type="first">Roberto</forename><surname>Giacobazzi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Radhia</forename><surname>Cousot</surname></persName>
		</editor>
		<meeting>POPL'13</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="457" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Coinductive Axiomatization of Recursive Type Equality and Subtyping</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fritz</forename><surname>Henglein</surname></persName>
		</author>
		<idno type="DOI">10.3233/FI-1998-33401</idno>
		<ptr target="https://doi.org/10.3233/FI-1998-33401" />
	</analytic>
	<monogr>
		<title level="j">Fundam. Inform</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="309" to="338" />
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Theory of Communicating Sequential Processes</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">D</forename><surname>Brookes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="560" to="599" />
			<date type="published" when="1984">1984. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An Improved Failures Model for Communicating Processes</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">D</forename><surname>Brookes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seminar on Concurrency</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Stephen</forename><forename type="middle">D</forename><surname>Brookes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Glynn</forename><surname>Winskel</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">197</biblScope>
			<biblScope unit="page" from="281" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Testing Equivalence as a Bisimulation Equivalence</title>
		<author>
			<persName><forename type="first">Rance</forename><surname>Cleaveland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Hennessy</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF01211314</idno>
		<ptr target="https://doi.org/10.1007/BF01211314" />
	</analytic>
	<monogr>
		<title level="j">Formal Asp. Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="20" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Bi)simulations up-to characterise process semantics</title>
		<author>
			<persName><forename type="first">David</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frutos-Escrig</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Gregorio-RodrÃ­guez</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ic.2007.12.003</idno>
		<ptr target="https://doi.org/10.1016/j.ic.2007.12.003" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">207</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="146" to="170" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Testing Equivalences for Processes</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hennessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="83" to="133" />
			<date type="published" when="1984">1984. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Divergence and unique solution of equations</title>
		<author>
			<persName><forename type="first">Adrien</forename><surname>Durier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Hirschkoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
		</author>
		<idno type="DOI">10.23638/LMCS-15(3:12)2019</idno>
		<ptr target="https://doi.org/10.23638/LMCS-15(3:12)2019" />
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Circular Coinduction in Coq Using Bisimulation-Up-To Techniques</title>
		<author>
			<persName><forename type="first">JÃ¶rg</forename><surname>Endrullis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitri</forename><surname>Hendriks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Bodin</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-39634-2_26</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-39634-2_26" />
	</analytic>
	<monogr>
		<title level="m">ITP 2013</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Sandrine</forename><surname>Blazy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Christine</forename><surname>Paulin-Mohring</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Pichardie</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013. 7998</date>
			<biblScope unit="page" from="354" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The linear time-branching time spectrum II (The semantics of sequential systems with silent moves)</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Van Glabbeek</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-57208-2_6</idno>
		<ptr target="https://doi.org/10.1007/3-540-57208-2_6" />
	</analytic>
	<monogr>
		<title level="m">Proc. CONCUR '93</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Best</surname></persName>
		</editor>
		<meeting>CONCUR '93</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">715</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The linear time-branching time spectrum I</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Van Glabbeek</surname></persName>
		</author>
		<idno type="DOI">10.1016/b978-044482830-9/50019-9</idno>
		<ptr target="https://doi.org/10.1016/b978-044482830-9/50019-9" />
	</analytic>
	<monogr>
		<title level="m">Handbook of Process Algebra</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Ponse</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Bergstra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Smolka</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="3" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Structured Operational Semantics and Bisimulation as a Congruence</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Vaandrager</surname></persName>
		</author>
		<idno type="DOI">10.1016/0890-5401(92)90013-6</idno>
		<ptr target="https://doi.org/10.1016/0890-5401(92)90013-6" />
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="202" to="260" />
			<date type="published" when="1992">1992. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Algebraic Theory of Processes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A Coinductive Equational Characterisation of Trace Inclusion for Regular Processes</title>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Hennessy</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-63121-9_22</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-63121-9_22" />
	</analytic>
	<monogr>
		<title level="m">Models, Algorithms, Logics and Tools</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Aceto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Bacci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Bacci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>IngÃ³lfsdÃ³ttir</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Legay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Mardare</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10460</biblScope>
			<biblScope unit="page" from="449" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Algebraic Laws for Nondeterminism and Concurrency</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="137" to="161" />
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Introduction to Automata Theory, Languages, and Computation (3rd Edition)</title>
		<meeting><address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Distributive laws for the coinductive solution of recursive equations</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ic.2005.03.006</idno>
		<ptr target="https://doi.org/10.1016/j.ic.2005.03.006" />
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">204</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="561" to="587" />
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A Completeness Theorem for Kleene Algebras and the Algebra of Regular Events</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
		<idno type="DOI">10.1006/inco.1994.1037</idno>
		<ptr target="https://doi.org/10.1006/inco.1994.1037" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="366" to="390" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">From Set-theoretic Coinduction to Coalgebraic Coinduction: some results, some problems</title>
		<author>
			<persName><forename type="first">Marina</forename><surname>Lenisa</surname></persName>
		</author>
		<idno type="DOI">10.1016/S1571-0661(05)80265-8</idno>
		<ptr target="https://doi.org/10.1016/S1571-0661(05)80265-8" />
	</analytic>
	<monogr>
		<title level="j">Electronical Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="2" to="22" />
			<date type="published" when="1999">1999. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Distributivity for endofunctors, pointed and co-pointed endofunctors, monads and comonads</title>
		<author>
			<persName><forename type="first">Marina</forename><surname>Lenisa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hiroshi</forename><surname>Watanabe</surname></persName>
		</author>
		<idno type="DOI">10.1016/S1571-0661(05)80350-0</idno>
		<ptr target="https://doi.org/10.1016/S1571-0661(05)80350-0" />
	</analytic>
	<monogr>
		<title level="j">Electronical Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="230" to="260" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Abstract GSOS Rules and a Modular Treatment of Recursive Definitions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Milius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schwencke</surname></persName>
		</author>
		<idno type="DOI">10.2168/LMCS-9(3:28)2013</idno>
		<ptr target="https://doi.org/10.2168/LMCS-9(3:28)2013" />
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Communication and Concurrency</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Specification-Oriented Semantics for Communicating Processes</title>
		<author>
			<persName><forename type="first">Ernst-RÃ¼diger</forename><surname>Olderog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="66" />
			<date type="published" when="1986">1986. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A New Equivalence notion for Communicating Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin EATCS</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Maurer</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="78" to="80" />
			<date type="published" when="1981-03">1981. March. January 2022</date>
			<publisher>POPL</publisher>
			<pubPlace>Bad Honnef</pubPlace>
		</imprint>
	</monogr>
	<note>Abstract of the talk presented at the Second Workshop on the Semantics of Programming Languages. Article 18. Publication date. From Enhanced Coinduction towards Enhanced Induction 18:29 16-20 1981. Abstracts collected in the Bulletin by B. Mayoh</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The Largest Respectful Function</title>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tjark</forename><surname>Weber</surname></persName>
		</author>
		<idno type="DOI">10.2168/LMCS-12(2:11)2016</idno>
		<ptr target="https://doi.org/10.2168/LMCS-12(2:11)2016" />
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Refusal Testing</title>
		<author>
			<persName><forename type="first">Iain</forename><surname>Phillips</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP'86</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>ICALP'86</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1987">1987. 1987</date>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="241" to="284" />
		</imprint>
	</monogr>
	<note>A preliminary version</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Linear and Branching Structures in the Semantics and Logics of Reactive Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th ICALP</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Brauer</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">194</biblScope>
			<biblScope unit="page" from="15" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Some equivalence notions for concurrent systems. An overview</title>
		<author>
			<persName><forename type="first">Lucia</forename><surname>Pomello</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0016202</idno>
		<ptr target="https://doi.org/10.1007/BFb0016202" />
	</analytic>
	<monogr>
		<title level="m">Advances in Petri Nets 1985</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Grzegorz</forename><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">222</biblScope>
			<biblScope unit="page" from="381" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Complete Lattices and Up-To Techniques</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pous</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-76637-7_24</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-540-76637-7_24" />
	</analytic>
	<monogr>
		<title level="m">Proc. APLAS '07</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>APLAS '07</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4807</biblScope>
			<biblScope unit="page" from="351" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Coinduction all the way up</title>
		<author>
			<persName><forename type="first">Damien</forename><surname>Pous</surname></persName>
		</author>
		<idno type="DOI">10.1145/2933575.2934564</idno>
		<ptr target="https://doi.org/10.1145/2933575.2934564" />
	</analytic>
	<monogr>
		<title level="m">Proc. LICS. ACM</title>
		<meeting>LICS. ACM</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="307" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Companions, Codensity, and Causality</title>
		<author>
			<persName><forename type="first">Damien</forename><surname>Pous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jurriaan</forename><surname>Rot</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-54458-7_7</idno>
		<ptr target="https://doi.org/10.1007/978-3-662-54458-7_7" />
	</analytic>
	<monogr>
		<title level="m">Proc. FoSSaCS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>FoSSaCS</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10203</biblScope>
			<biblScope unit="page" from="106" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Enhancements of the bisimulation proof method</title>
		<author>
			<persName><forename type="first">Damien</forename><surname>Pous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Topics in Bisimulation and Coinduction</title>
		<editor>
			<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Rutten</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Bisimulation and Coinduction Enhancements: A Historical Perspective</title>
		<author>
			<persName><forename type="first">Damien</forename><surname>Pous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00165-019-00497-w</idno>
		<ptr target="https://doi.org/10.1007/s00165-019-00497-w" />
	</analytic>
	<monogr>
		<title level="j">Formal Asp. Comput</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="733" to="749" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A Complete Axiomatisation for Trace Congruence of Finite State Behaviors</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Moshe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rabinovich</forename></persName>
		</author>
		<idno type="DOI">10.1007/3-540-58027-1_25</idno>
		<ptr target="https://doi.org/10.1007/3-540-58027-1_25" />
	</analytic>
	<monogr>
		<title level="m">Proc. 9th MFPS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Stephen</forename><forename type="middle">D</forename><surname>Brookes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Michael</forename><forename type="middle">G</forename><surname>Main</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Austin</forename><surname>Melton</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Michael</forename><forename type="middle">W</forename><surname>Mislove</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Schmidt</surname></persName>
		</editor>
		<meeting>9th MFPS</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">802</biblScope>
			<biblScope unit="page" from="530" to="543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</author>
		<ptr target="http://www.cs.ox.ac.uk/people/bill.roscoe/publications/68b.pdf" />
		<title level="m">The theory and practice of concurrency</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Enhanced coalgebraic bisimulation</title>
		<author>
			<persName><forename type="first">Jurriaan</forename><surname>Rot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filippo</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcello</forename><forename type="middle">M</forename><surname>Bonsangue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damien</forename><surname>Pous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Rutten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Silva</surname></persName>
		</author>
		<idno type="DOI">10.1017/S0960129515000523</idno>
		<ptr target="https://doi.org/10.1017/S0960129515000523" />
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1236" to="1264" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Proving language inclusion and equivalence by coinduction</title>
		<author>
			<persName><forename type="first">Jurriaan</forename><surname>Rot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcello</forename><forename type="middle">M</forename><surname>Bonsangue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Rutten</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ic.2015.11.009</idno>
		<ptr target="https://doi.org/10.1016/j.ic.2015.11.009" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">246</biblScope>
			<biblScope unit="page" from="62" to="76" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Two Complete Axiom Systems for the Algebra of Regular Events</title>
		<author>
			<persName><forename type="first">Arto</forename><surname>Salomaa</surname></persName>
		</author>
		<idno type="DOI">10.1145/321312.321326</idno>
		<ptr target="https://doi.org/10.1145/321312.321326" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="158" to="169" />
			<date type="published" when="1966">1966. 1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">On the bisimulation proof method</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
		<idno type="DOI">10.1017/S0960129598002527</idno>
		<ptr target="https://doi.org/10.1017/S0960129598002527" />
	</analytic>
	<monogr>
		<title level="j">Journal of Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="447" to="479" />
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<author>
			<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
		</author>
		<idno type="DOI">10.1017/CBO9780511777110</idno>
		<ptr target="https://doi.org/10.1017/CBO9780511777110" />
		<title level="m">Introduction to Bisimulation and Coinduction</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Equations, Contractions, and Unique Solutions</title>
		<author>
			<persName><forename type="first">Davide</forename><surname>Sangiorgi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2971339</idno>
		<ptr target="https://doi.org/10.1145/2971339" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Log</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The problem of "Weak Bisimulation up to</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0084781</idno>
		<ptr target="https://doi.org/10.1007/BFb0084781" />
	</analytic>
	<monogr>
		<title level="m">Proc. CONCUR '92</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Cleveland</surname></persName>
		</editor>
		<meeting>CONCUR '92</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">630</biblScope>
			<biblScope unit="page" from="32" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Generalizing the powerset construction, coalgebraically</title>
		<author>
			<persName><forename type="first">A</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bonsangue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.FSTTCS.2010.272</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.FSTTCS.2010.272" />
	</analytic>
	<monogr>
		<title level="m">FSTTCS (LIPIcs). Schloss Dagstuhl -Leibniz-Zentrum fÃ¼r Informatik</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="272" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Modal and temporal properties of processes</title>
		<author>
			<persName><forename type="first">Colin</forename><surname>Stirling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Recursion Schemes from Comonads</title>
		<author>
			<persName><forename type="first">Tarmo</forename><surname>Uustalu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Varmo</forename><surname>Vene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Pardo</surname></persName>
		</author>
		<ptr target="http://www.cs.helsinki.fi/njc/References/uustaluvp2001:366.html" />
	</analytic>
	<monogr>
		<title level="j">Nord. J. Comput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="366" to="390" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>